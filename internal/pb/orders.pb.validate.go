// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: orders.proto

package contractv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on TradesStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradesStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradesStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradesStreamRequestMultiError, or nil if none found.
func (m *TradesStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TradesStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PingDelayMs != nil {
		// no validation rules for PingDelayMs
	}

	if len(errors) > 0 {
		return TradesStreamRequestMultiError(errors)
	}

	return nil
}

// TradesStreamRequestMultiError is an error wrapping multiple validation
// errors returned by TradesStreamRequest.ValidateAll() if the designated
// constraints aren't met.
type TradesStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradesStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradesStreamRequestMultiError) AllErrors() []error { return m }

// TradesStreamRequestValidationError is the validation error returned by
// TradesStreamRequest.Validate if the designated constraints aren't met.
type TradesStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradesStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradesStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradesStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradesStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradesStreamRequestValidationError) ErrorName() string {
	return "TradesStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TradesStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradesStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradesStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradesStreamRequestValidationError{}

// Validate checks the field values on TradesStreamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradesStreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradesStreamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradesStreamResponseMultiError, or nil if none found.
func (m *TradesStreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TradesStreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *TradesStreamResponse_OrderTrades:
		if v == nil {
			err := TradesStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOrderTrades()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradesStreamResponseValidationError{
						field:  "OrderTrades",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradesStreamResponseValidationError{
						field:  "OrderTrades",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOrderTrades()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradesStreamResponseValidationError{
					field:  "OrderTrades",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TradesStreamResponse_Ping:
		if v == nil {
			err := TradesStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPing()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradesStreamResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradesStreamResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPing()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradesStreamResponseValidationError{
					field:  "Ping",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TradesStreamResponse_Subscription:
		if v == nil {
			err := TradesStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscription()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradesStreamResponseValidationError{
						field:  "Subscription",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradesStreamResponseValidationError{
						field:  "Subscription",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscription()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradesStreamResponseValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TradesStreamResponseMultiError(errors)
	}

	return nil
}

// TradesStreamResponseMultiError is an error wrapping multiple validation
// errors returned by TradesStreamResponse.ValidateAll() if the designated
// constraints aren't met.
type TradesStreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradesStreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradesStreamResponseMultiError) AllErrors() []error { return m }

// TradesStreamResponseValidationError is the validation error returned by
// TradesStreamResponse.Validate if the designated constraints aren't met.
type TradesStreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradesStreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradesStreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradesStreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradesStreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradesStreamResponseValidationError) ErrorName() string {
	return "TradesStreamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TradesStreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradesStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradesStreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradesStreamResponseValidationError{}

// Validate checks the field values on OrderTrades with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderTrades) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderTrades with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderTradesMultiError, or
// nil if none found.
func (m *OrderTrades) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderTrades) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderTradesValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderTradesValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderTradesValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Direction

	// no validation rules for Figi

	for idx, item := range m.GetTrades() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderTradesValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderTradesValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderTradesValidationError{
					field:  fmt.Sprintf("Trades[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AccountId

	// no validation rules for InstrumentUid

	if len(errors) > 0 {
		return OrderTradesMultiError(errors)
	}

	return nil
}

// OrderTradesMultiError is an error wrapping multiple validation errors
// returned by OrderTrades.ValidateAll() if the designated constraints aren't met.
type OrderTradesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderTradesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderTradesMultiError) AllErrors() []error { return m }

// OrderTradesValidationError is the validation error returned by
// OrderTrades.Validate if the designated constraints aren't met.
type OrderTradesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderTradesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderTradesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderTradesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderTradesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderTradesValidationError) ErrorName() string { return "OrderTradesValidationError" }

// Error satisfies the builtin error interface
func (e OrderTradesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderTrades.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderTradesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderTradesValidationError{}

// Validate checks the field values on OrderTrade with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderTrade) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderTrade with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderTradeMultiError, or
// nil if none found.
func (m *OrderTrade) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderTrade) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderTradeValidationError{
					field:  "DateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderTradeValidationError{
					field:  "DateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderTradeValidationError{
				field:  "DateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderTradeValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderTradeValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderTradeValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	// no validation rules for TradeId

	if len(errors) > 0 {
		return OrderTradeMultiError(errors)
	}

	return nil
}

// OrderTradeMultiError is an error wrapping multiple validation errors
// returned by OrderTrade.ValidateAll() if the designated constraints aren't met.
type OrderTradeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderTradeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderTradeMultiError) AllErrors() []error { return m }

// OrderTradeValidationError is the validation error returned by
// OrderTrade.Validate if the designated constraints aren't met.
type OrderTradeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderTradeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderTradeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderTradeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderTradeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderTradeValidationError) ErrorName() string { return "OrderTradeValidationError" }

// Error satisfies the builtin error interface
func (e OrderTradeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderTrade.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderTradeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderTradeValidationError{}

// Validate checks the field values on PostOrderRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PostOrderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostOrderRequestMultiError, or nil if none found.
func (m *PostOrderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PostOrderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Quantity

	// no validation rules for Direction

	// no validation rules for AccountId

	// no validation rules for OrderType

	// no validation rules for OrderId

	// no validation rules for InstrumentId

	// no validation rules for TimeInForce

	// no validation rules for PriceType

	if m.Figi != nil {
		// no validation rules for Figi
	}

	if m.Price != nil {

		if all {
			switch v := interface{}(m.GetPrice()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PostOrderRequestValidationError{
						field:  "Price",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PostOrderRequestValidationError{
						field:  "Price",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PostOrderRequestValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PostOrderRequestMultiError(errors)
	}

	return nil
}

// PostOrderRequestMultiError is an error wrapping multiple validation errors
// returned by PostOrderRequest.ValidateAll() if the designated constraints
// aren't met.
type PostOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostOrderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostOrderRequestMultiError) AllErrors() []error { return m }

// PostOrderRequestValidationError is the validation error returned by
// PostOrderRequest.Validate if the designated constraints aren't met.
type PostOrderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostOrderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostOrderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostOrderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostOrderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostOrderRequestValidationError) ErrorName() string { return "PostOrderRequestValidationError" }

// Error satisfies the builtin error interface
func (e PostOrderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostOrderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostOrderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostOrderRequestValidationError{}

// Validate checks the field values on PostOrderResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PostOrderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostOrderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostOrderResponseMultiError, or nil if none found.
func (m *PostOrderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PostOrderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for ExecutionReportStatus

	// no validation rules for LotsRequested

	// no validation rules for LotsExecuted

	if all {
		switch v := interface{}(m.GetInitialOrderPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "InitialOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "InitialOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialOrderPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "InitialOrderPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutedOrderPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "ExecutedOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "ExecutedOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedOrderPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "ExecutedOrderPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalOrderAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "TotalOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "TotalOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalOrderAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "TotalOrderAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInitialCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "InitialCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "InitialCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "InitialCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutedCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "ExecutedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "ExecutedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "ExecutedCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAciValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "AciValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "AciValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAciValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "AciValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Figi

	// no validation rules for Direction

	if all {
		switch v := interface{}(m.GetInitialSecurityPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "InitialSecurityPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "InitialSecurityPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialSecurityPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "InitialSecurityPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OrderType

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetInitialOrderPricePt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "InitialOrderPricePt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "InitialOrderPricePt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialOrderPricePt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "InitialOrderPricePt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstrumentUid

	// no validation rules for OrderRequestId

	if all {
		switch v := interface{}(m.GetResponseMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "ResponseMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PostOrderResponseValidationError{
					field:  "ResponseMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponseMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PostOrderResponseValidationError{
				field:  "ResponseMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PostOrderResponseMultiError(errors)
	}

	return nil
}

// PostOrderResponseMultiError is an error wrapping multiple validation errors
// returned by PostOrderResponse.ValidateAll() if the designated constraints
// aren't met.
type PostOrderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostOrderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostOrderResponseMultiError) AllErrors() []error { return m }

// PostOrderResponseValidationError is the validation error returned by
// PostOrderResponse.Validate if the designated constraints aren't met.
type PostOrderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostOrderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostOrderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostOrderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostOrderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostOrderResponseValidationError) ErrorName() string {
	return "PostOrderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PostOrderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostOrderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostOrderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostOrderResponseValidationError{}

// Validate checks the field values on PostOrderAsyncRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostOrderAsyncRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostOrderAsyncRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostOrderAsyncRequestMultiError, or nil if none found.
func (m *PostOrderAsyncRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PostOrderAsyncRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for Quantity

	// no validation rules for Direction

	// no validation rules for AccountId

	// no validation rules for OrderType

	// no validation rules for OrderId

	if m.Price != nil {

		if all {
			switch v := interface{}(m.GetPrice()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PostOrderAsyncRequestValidationError{
						field:  "Price",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PostOrderAsyncRequestValidationError{
						field:  "Price",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PostOrderAsyncRequestValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.TimeInForce != nil {
		// no validation rules for TimeInForce
	}

	if m.PriceType != nil {
		// no validation rules for PriceType
	}

	if len(errors) > 0 {
		return PostOrderAsyncRequestMultiError(errors)
	}

	return nil
}

// PostOrderAsyncRequestMultiError is an error wrapping multiple validation
// errors returned by PostOrderAsyncRequest.ValidateAll() if the designated
// constraints aren't met.
type PostOrderAsyncRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostOrderAsyncRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostOrderAsyncRequestMultiError) AllErrors() []error { return m }

// PostOrderAsyncRequestValidationError is the validation error returned by
// PostOrderAsyncRequest.Validate if the designated constraints aren't met.
type PostOrderAsyncRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostOrderAsyncRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostOrderAsyncRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostOrderAsyncRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostOrderAsyncRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostOrderAsyncRequestValidationError) ErrorName() string {
	return "PostOrderAsyncRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PostOrderAsyncRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostOrderAsyncRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostOrderAsyncRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostOrderAsyncRequestValidationError{}

// Validate checks the field values on PostOrderAsyncResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PostOrderAsyncResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PostOrderAsyncResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PostOrderAsyncResponseMultiError, or nil if none found.
func (m *PostOrderAsyncResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PostOrderAsyncResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderRequestId

	// no validation rules for ExecutionReportStatus

	if m.TradeIntentId != nil {
		// no validation rules for TradeIntentId
	}

	if len(errors) > 0 {
		return PostOrderAsyncResponseMultiError(errors)
	}

	return nil
}

// PostOrderAsyncResponseMultiError is an error wrapping multiple validation
// errors returned by PostOrderAsyncResponse.ValidateAll() if the designated
// constraints aren't met.
type PostOrderAsyncResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PostOrderAsyncResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PostOrderAsyncResponseMultiError) AllErrors() []error { return m }

// PostOrderAsyncResponseValidationError is the validation error returned by
// PostOrderAsyncResponse.Validate if the designated constraints aren't met.
type PostOrderAsyncResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PostOrderAsyncResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PostOrderAsyncResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PostOrderAsyncResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PostOrderAsyncResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PostOrderAsyncResponseValidationError) ErrorName() string {
	return "PostOrderAsyncResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PostOrderAsyncResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPostOrderAsyncResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PostOrderAsyncResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PostOrderAsyncResponseValidationError{}

// Validate checks the field values on CancelOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelOrderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelOrderRequestMultiError, or nil if none found.
func (m *CancelOrderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelOrderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for OrderId

	if m.OrderIdType != nil {
		// no validation rules for OrderIdType
	}

	if len(errors) > 0 {
		return CancelOrderRequestMultiError(errors)
	}

	return nil
}

// CancelOrderRequestMultiError is an error wrapping multiple validation errors
// returned by CancelOrderRequest.ValidateAll() if the designated constraints
// aren't met.
type CancelOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelOrderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelOrderRequestMultiError) AllErrors() []error { return m }

// CancelOrderRequestValidationError is the validation error returned by
// CancelOrderRequest.Validate if the designated constraints aren't met.
type CancelOrderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelOrderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelOrderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelOrderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelOrderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelOrderRequestValidationError) ErrorName() string {
	return "CancelOrderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelOrderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelOrderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelOrderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelOrderRequestValidationError{}

// Validate checks the field values on CancelOrderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelOrderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelOrderResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelOrderResponseMultiError, or nil if none found.
func (m *CancelOrderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelOrderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelOrderResponseValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelOrderResponseValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelOrderResponseValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponseMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelOrderResponseValidationError{
					field:  "ResponseMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelOrderResponseValidationError{
					field:  "ResponseMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponseMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelOrderResponseValidationError{
				field:  "ResponseMetadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelOrderResponseMultiError(errors)
	}

	return nil
}

// CancelOrderResponseMultiError is an error wrapping multiple validation
// errors returned by CancelOrderResponse.ValidateAll() if the designated
// constraints aren't met.
type CancelOrderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelOrderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelOrderResponseMultiError) AllErrors() []error { return m }

// CancelOrderResponseValidationError is the validation error returned by
// CancelOrderResponse.Validate if the designated constraints aren't met.
type CancelOrderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelOrderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelOrderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelOrderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelOrderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelOrderResponseValidationError) ErrorName() string {
	return "CancelOrderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelOrderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelOrderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelOrderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelOrderResponseValidationError{}

// Validate checks the field values on GetOrderStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrderStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrderStateRequestMultiError, or nil if none found.
func (m *GetOrderStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for OrderId

	// no validation rules for PriceType

	if m.OrderIdType != nil {
		// no validation rules for OrderIdType
	}

	if len(errors) > 0 {
		return GetOrderStateRequestMultiError(errors)
	}

	return nil
}

// GetOrderStateRequestMultiError is an error wrapping multiple validation
// errors returned by GetOrderStateRequest.ValidateAll() if the designated
// constraints aren't met.
type GetOrderStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderStateRequestMultiError) AllErrors() []error { return m }

// GetOrderStateRequestValidationError is the validation error returned by
// GetOrderStateRequest.Validate if the designated constraints aren't met.
type GetOrderStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderStateRequestValidationError) ErrorName() string {
	return "GetOrderStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrderStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderStateRequestValidationError{}

// Validate checks the field values on GetOrdersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetOrdersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrdersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrdersRequestMultiError, or nil if none found.
func (m *GetOrdersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrdersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return GetOrdersRequestMultiError(errors)
	}

	return nil
}

// GetOrdersRequestMultiError is an error wrapping multiple validation errors
// returned by GetOrdersRequest.ValidateAll() if the designated constraints
// aren't met.
type GetOrdersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrdersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrdersRequestMultiError) AllErrors() []error { return m }

// GetOrdersRequestValidationError is the validation error returned by
// GetOrdersRequest.Validate if the designated constraints aren't met.
type GetOrdersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrdersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrdersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrdersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrdersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrdersRequestValidationError) ErrorName() string { return "GetOrdersRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetOrdersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrdersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrdersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrdersRequestValidationError{}

// Validate checks the field values on GetOrdersResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetOrdersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrdersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrdersResponseMultiError, or nil if none found.
func (m *GetOrdersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrdersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOrders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOrdersResponseValidationError{
						field:  fmt.Sprintf("Orders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOrdersResponseValidationError{
						field:  fmt.Sprintf("Orders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOrdersResponseValidationError{
					field:  fmt.Sprintf("Orders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetOrdersResponseMultiError(errors)
	}

	return nil
}

// GetOrdersResponseMultiError is an error wrapping multiple validation errors
// returned by GetOrdersResponse.ValidateAll() if the designated constraints
// aren't met.
type GetOrdersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrdersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrdersResponseMultiError) AllErrors() []error { return m }

// GetOrdersResponseValidationError is the validation error returned by
// GetOrdersResponse.Validate if the designated constraints aren't met.
type GetOrdersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrdersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrdersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrdersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrdersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrdersResponseValidationError) ErrorName() string {
	return "GetOrdersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrdersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrdersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrdersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrdersResponseValidationError{}

// Validate checks the field values on OrderState with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderState with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderStateMultiError, or
// nil if none found.
func (m *OrderState) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for ExecutionReportStatus

	// no validation rules for LotsRequested

	// no validation rules for LotsExecuted

	if all {
		switch v := interface{}(m.GetInitialOrderPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "InitialOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "InitialOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialOrderPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "InitialOrderPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutedOrderPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "ExecutedOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "ExecutedOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedOrderPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "ExecutedOrderPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalOrderAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "TotalOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "TotalOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalOrderAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "TotalOrderAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAveragePositionPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "AveragePositionPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "AveragePositionPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAveragePositionPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "AveragePositionPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInitialCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "InitialCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "InitialCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "InitialCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutedCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "ExecutedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "ExecutedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "ExecutedCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Figi

	// no validation rules for Direction

	if all {
		switch v := interface{}(m.GetInitialSecurityPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "InitialSecurityPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "InitialSecurityPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialSecurityPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "InitialSecurityPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetStages() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderStateValidationError{
						field:  fmt.Sprintf("Stages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderStateValidationError{
						field:  fmt.Sprintf("Stages[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderStateValidationError{
					field:  fmt.Sprintf("Stages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetServiceCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "ServiceCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "ServiceCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "ServiceCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for OrderType

	if all {
		switch v := interface{}(m.GetOrderDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "OrderDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateValidationError{
					field:  "OrderDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateValidationError{
				field:  "OrderDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstrumentUid

	// no validation rules for OrderRequestId

	if len(errors) > 0 {
		return OrderStateMultiError(errors)
	}

	return nil
}

// OrderStateMultiError is an error wrapping multiple validation errors
// returned by OrderState.ValidateAll() if the designated constraints aren't met.
type OrderStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderStateMultiError) AllErrors() []error { return m }

// OrderStateValidationError is the validation error returned by
// OrderState.Validate if the designated constraints aren't met.
type OrderStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderStateValidationError) ErrorName() string { return "OrderStateValidationError" }

// Error satisfies the builtin error interface
func (e OrderStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderStateValidationError{}

// Validate checks the field values on OrderStage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderStage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderStage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderStageMultiError, or
// nil if none found.
func (m *OrderStage) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderStage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStageValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStageValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStageValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	// no validation rules for TradeId

	if all {
		switch v := interface{}(m.GetExecutionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStageValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStageValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStageValidationError{
				field:  "ExecutionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OrderStageMultiError(errors)
	}

	return nil
}

// OrderStageMultiError is an error wrapping multiple validation errors
// returned by OrderStage.ValidateAll() if the designated constraints aren't met.
type OrderStageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderStageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderStageMultiError) AllErrors() []error { return m }

// OrderStageValidationError is the validation error returned by
// OrderStage.Validate if the designated constraints aren't met.
type OrderStageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderStageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderStageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderStageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderStageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderStageValidationError) ErrorName() string { return "OrderStageValidationError" }

// Error satisfies the builtin error interface
func (e OrderStageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderStage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderStageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderStageValidationError{}

// Validate checks the field values on ReplaceOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReplaceOrderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReplaceOrderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReplaceOrderRequestMultiError, or nil if none found.
func (m *ReplaceOrderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReplaceOrderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for OrderId

	// no validation rules for IdempotencyKey

	// no validation rules for Quantity

	if m.Price != nil {

		if all {
			switch v := interface{}(m.GetPrice()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReplaceOrderRequestValidationError{
						field:  "Price",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReplaceOrderRequestValidationError{
						field:  "Price",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReplaceOrderRequestValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.PriceType != nil {
		// no validation rules for PriceType
	}

	if len(errors) > 0 {
		return ReplaceOrderRequestMultiError(errors)
	}

	return nil
}

// ReplaceOrderRequestMultiError is an error wrapping multiple validation
// errors returned by ReplaceOrderRequest.ValidateAll() if the designated
// constraints aren't met.
type ReplaceOrderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReplaceOrderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReplaceOrderRequestMultiError) AllErrors() []error { return m }

// ReplaceOrderRequestValidationError is the validation error returned by
// ReplaceOrderRequest.Validate if the designated constraints aren't met.
type ReplaceOrderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReplaceOrderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReplaceOrderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReplaceOrderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReplaceOrderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReplaceOrderRequestValidationError) ErrorName() string {
	return "ReplaceOrderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReplaceOrderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReplaceOrderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReplaceOrderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReplaceOrderRequestValidationError{}

// Validate checks the field values on GetMaxLotsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetMaxLotsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxLotsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMaxLotsRequestMultiError, or nil if none found.
func (m *GetMaxLotsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxLotsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for InstrumentId

	if m.Price != nil {

		if all {
			switch v := interface{}(m.GetPrice()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetMaxLotsRequestValidationError{
						field:  "Price",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetMaxLotsRequestValidationError{
						field:  "Price",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetMaxLotsRequestValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetMaxLotsRequestMultiError(errors)
	}

	return nil
}

// GetMaxLotsRequestMultiError is an error wrapping multiple validation errors
// returned by GetMaxLotsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetMaxLotsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxLotsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxLotsRequestMultiError) AllErrors() []error { return m }

// GetMaxLotsRequestValidationError is the validation error returned by
// GetMaxLotsRequest.Validate if the designated constraints aren't met.
type GetMaxLotsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxLotsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxLotsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxLotsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxLotsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxLotsRequestValidationError) ErrorName() string {
	return "GetMaxLotsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMaxLotsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxLotsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxLotsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxLotsRequestValidationError{}

// Validate checks the field values on GetMaxLotsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMaxLotsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxLotsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMaxLotsResponseMultiError, or nil if none found.
func (m *GetMaxLotsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxLotsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetBuyLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMaxLotsResponseValidationError{
					field:  "BuyLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMaxLotsResponseValidationError{
					field:  "BuyLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuyLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMaxLotsResponseValidationError{
				field:  "BuyLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBuyMarginLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMaxLotsResponseValidationError{
					field:  "BuyMarginLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMaxLotsResponseValidationError{
					field:  "BuyMarginLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuyMarginLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMaxLotsResponseValidationError{
				field:  "BuyMarginLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSellLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMaxLotsResponseValidationError{
					field:  "SellLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMaxLotsResponseValidationError{
					field:  "SellLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSellLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMaxLotsResponseValidationError{
				field:  "SellLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSellMarginLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMaxLotsResponseValidationError{
					field:  "SellMarginLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMaxLotsResponseValidationError{
					field:  "SellMarginLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSellMarginLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMaxLotsResponseValidationError{
				field:  "SellMarginLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetMaxLotsResponseMultiError(errors)
	}

	return nil
}

// GetMaxLotsResponseMultiError is an error wrapping multiple validation errors
// returned by GetMaxLotsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetMaxLotsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxLotsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxLotsResponseMultiError) AllErrors() []error { return m }

// GetMaxLotsResponseValidationError is the validation error returned by
// GetMaxLotsResponse.Validate if the designated constraints aren't met.
type GetMaxLotsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxLotsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxLotsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxLotsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxLotsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxLotsResponseValidationError) ErrorName() string {
	return "GetMaxLotsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMaxLotsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxLotsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxLotsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxLotsResponseValidationError{}

// Validate checks the field values on GetOrderPriceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrderPriceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderPriceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrderPriceRequestMultiError, or nil if none found.
func (m *GetOrderPriceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderPriceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for InstrumentId

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceRequestValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceRequestValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceRequestValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Direction

	// no validation rules for Quantity

	if len(errors) > 0 {
		return GetOrderPriceRequestMultiError(errors)
	}

	return nil
}

// GetOrderPriceRequestMultiError is an error wrapping multiple validation
// errors returned by GetOrderPriceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetOrderPriceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderPriceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderPriceRequestMultiError) AllErrors() []error { return m }

// GetOrderPriceRequestValidationError is the validation error returned by
// GetOrderPriceRequest.Validate if the designated constraints aren't met.
type GetOrderPriceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderPriceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderPriceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderPriceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderPriceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderPriceRequestValidationError) ErrorName() string {
	return "GetOrderPriceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrderPriceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderPriceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderPriceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderPriceRequestValidationError{}

// Validate checks the field values on GetOrderPriceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrderPriceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderPriceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrderPriceResponseMultiError, or nil if none found.
func (m *GetOrderPriceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderPriceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTotalOrderAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "TotalOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "TotalOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalOrderAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponseValidationError{
				field:  "TotalOrderAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInitialOrderAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "InitialOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "InitialOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialOrderAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponseValidationError{
				field:  "InitialOrderAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LotsRequested

	if all {
		switch v := interface{}(m.GetExecutedCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "ExecutedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "ExecutedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponseValidationError{
				field:  "ExecutedCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutedCommissionRub()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "ExecutedCommissionRub",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "ExecutedCommissionRub",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedCommissionRub()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponseValidationError{
				field:  "ExecutedCommissionRub",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetServiceCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "ServiceCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "ServiceCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponseValidationError{
				field:  "ServiceCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDealCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "DealCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponseValidationError{
					field:  "DealCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDealCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponseValidationError{
				field:  "DealCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.InstrumentExtra.(type) {
	case *GetOrderPriceResponse_ExtraBond_:
		if v == nil {
			err := GetOrderPriceResponseValidationError{
				field:  "InstrumentExtra",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExtraBond()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOrderPriceResponseValidationError{
						field:  "ExtraBond",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOrderPriceResponseValidationError{
						field:  "ExtraBond",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExtraBond()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOrderPriceResponseValidationError{
					field:  "ExtraBond",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GetOrderPriceResponse_ExtraFuture_:
		if v == nil {
			err := GetOrderPriceResponseValidationError{
				field:  "InstrumentExtra",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExtraFuture()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOrderPriceResponseValidationError{
						field:  "ExtraFuture",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOrderPriceResponseValidationError{
						field:  "ExtraFuture",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExtraFuture()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOrderPriceResponseValidationError{
					field:  "ExtraFuture",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return GetOrderPriceResponseMultiError(errors)
	}

	return nil
}

// GetOrderPriceResponseMultiError is an error wrapping multiple validation
// errors returned by GetOrderPriceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetOrderPriceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderPriceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderPriceResponseMultiError) AllErrors() []error { return m }

// GetOrderPriceResponseValidationError is the validation error returned by
// GetOrderPriceResponse.Validate if the designated constraints aren't met.
type GetOrderPriceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderPriceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderPriceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderPriceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderPriceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderPriceResponseValidationError) ErrorName() string {
	return "GetOrderPriceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrderPriceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderPriceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderPriceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderPriceResponseValidationError{}

// Validate checks the field values on OrderStateStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderStateStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderStateStreamRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderStateStreamRequestMultiError, or nil if none found.
func (m *OrderStateStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderStateStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PingDelayMs != nil {
		// no validation rules for PingDelayMs
	}

	if len(errors) > 0 {
		return OrderStateStreamRequestMultiError(errors)
	}

	return nil
}

// OrderStateStreamRequestMultiError is an error wrapping multiple validation
// errors returned by OrderStateStreamRequest.ValidateAll() if the designated
// constraints aren't met.
type OrderStateStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderStateStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderStateStreamRequestMultiError) AllErrors() []error { return m }

// OrderStateStreamRequestValidationError is the validation error returned by
// OrderStateStreamRequest.Validate if the designated constraints aren't met.
type OrderStateStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderStateStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderStateStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderStateStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderStateStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderStateStreamRequestValidationError) ErrorName() string {
	return "OrderStateStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OrderStateStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderStateStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderStateStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderStateStreamRequestValidationError{}

// Validate checks the field values on SubscriptionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionResponseMultiError, or nil if none found.
func (m *SubscriptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackingId

	// no validation rules for Status

	// no validation rules for StreamId

	if m.Error != nil {

		if all {
			switch v := interface{}(m.GetError()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscriptionResponseValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscriptionResponseValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscriptionResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscriptionResponseMultiError(errors)
	}

	return nil
}

// SubscriptionResponseMultiError is an error wrapping multiple validation
// errors returned by SubscriptionResponse.ValidateAll() if the designated
// constraints aren't met.
type SubscriptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionResponseMultiError) AllErrors() []error { return m }

// SubscriptionResponseValidationError is the validation error returned by
// SubscriptionResponse.Validate if the designated constraints aren't met.
type SubscriptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionResponseValidationError) ErrorName() string {
	return "SubscriptionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionResponseValidationError{}

// Validate checks the field values on OrderStateStreamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderStateStreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderStateStreamResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderStateStreamResponseMultiError, or nil if none found.
func (m *OrderStateStreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderStateStreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *OrderStateStreamResponse_OrderState_:
		if v == nil {
			err := OrderStateStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOrderState()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderStateStreamResponseValidationError{
						field:  "OrderState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderStateStreamResponseValidationError{
						field:  "OrderState",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOrderState()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderStateStreamResponseValidationError{
					field:  "OrderState",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OrderStateStreamResponse_Ping:
		if v == nil {
			err := OrderStateStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPing()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderStateStreamResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderStateStreamResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPing()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderStateStreamResponseValidationError{
					field:  "Ping",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *OrderStateStreamResponse_Subscription:
		if v == nil {
			err := OrderStateStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscription()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderStateStreamResponseValidationError{
						field:  "Subscription",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderStateStreamResponseValidationError{
						field:  "Subscription",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscription()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderStateStreamResponseValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return OrderStateStreamResponseMultiError(errors)
	}

	return nil
}

// OrderStateStreamResponseMultiError is an error wrapping multiple validation
// errors returned by OrderStateStreamResponse.ValidateAll() if the designated
// constraints aren't met.
type OrderStateStreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderStateStreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderStateStreamResponseMultiError) AllErrors() []error { return m }

// OrderStateStreamResponseValidationError is the validation error returned by
// OrderStateStreamResponse.Validate if the designated constraints aren't met.
type OrderStateStreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderStateStreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderStateStreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderStateStreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderStateStreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderStateStreamResponseValidationError) ErrorName() string {
	return "OrderStateStreamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OrderStateStreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderStateStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderStateStreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderStateStreamResponseValidationError{}

// Validate checks the field values on GetMaxLotsResponse_BuyLimitsView with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetMaxLotsResponse_BuyLimitsView) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxLotsResponse_BuyLimitsView with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetMaxLotsResponse_BuyLimitsViewMultiError, or nil if none found.
func (m *GetMaxLotsResponse_BuyLimitsView) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxLotsResponse_BuyLimitsView) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBuyMoneyAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetMaxLotsResponse_BuyLimitsViewValidationError{
					field:  "BuyMoneyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetMaxLotsResponse_BuyLimitsViewValidationError{
					field:  "BuyMoneyAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuyMoneyAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetMaxLotsResponse_BuyLimitsViewValidationError{
				field:  "BuyMoneyAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BuyMaxLots

	// no validation rules for BuyMaxMarketLots

	if len(errors) > 0 {
		return GetMaxLotsResponse_BuyLimitsViewMultiError(errors)
	}

	return nil
}

// GetMaxLotsResponse_BuyLimitsViewMultiError is an error wrapping multiple
// validation errors returned by
// GetMaxLotsResponse_BuyLimitsView.ValidateAll() if the designated
// constraints aren't met.
type GetMaxLotsResponse_BuyLimitsViewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxLotsResponse_BuyLimitsViewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxLotsResponse_BuyLimitsViewMultiError) AllErrors() []error { return m }

// GetMaxLotsResponse_BuyLimitsViewValidationError is the validation error
// returned by GetMaxLotsResponse_BuyLimitsView.Validate if the designated
// constraints aren't met.
type GetMaxLotsResponse_BuyLimitsViewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxLotsResponse_BuyLimitsViewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxLotsResponse_BuyLimitsViewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxLotsResponse_BuyLimitsViewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxLotsResponse_BuyLimitsViewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxLotsResponse_BuyLimitsViewValidationError) ErrorName() string {
	return "GetMaxLotsResponse_BuyLimitsViewValidationError"
}

// Error satisfies the builtin error interface
func (e GetMaxLotsResponse_BuyLimitsViewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxLotsResponse_BuyLimitsView.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxLotsResponse_BuyLimitsViewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxLotsResponse_BuyLimitsViewValidationError{}

// Validate checks the field values on GetMaxLotsResponse_SellLimitsView with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetMaxLotsResponse_SellLimitsView) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMaxLotsResponse_SellLimitsView
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetMaxLotsResponse_SellLimitsViewMultiError, or nil if none found.
func (m *GetMaxLotsResponse_SellLimitsView) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMaxLotsResponse_SellLimitsView) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SellMaxLots

	if len(errors) > 0 {
		return GetMaxLotsResponse_SellLimitsViewMultiError(errors)
	}

	return nil
}

// GetMaxLotsResponse_SellLimitsViewMultiError is an error wrapping multiple
// validation errors returned by
// GetMaxLotsResponse_SellLimitsView.ValidateAll() if the designated
// constraints aren't met.
type GetMaxLotsResponse_SellLimitsViewMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMaxLotsResponse_SellLimitsViewMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMaxLotsResponse_SellLimitsViewMultiError) AllErrors() []error { return m }

// GetMaxLotsResponse_SellLimitsViewValidationError is the validation error
// returned by GetMaxLotsResponse_SellLimitsView.Validate if the designated
// constraints aren't met.
type GetMaxLotsResponse_SellLimitsViewValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMaxLotsResponse_SellLimitsViewValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMaxLotsResponse_SellLimitsViewValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMaxLotsResponse_SellLimitsViewValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMaxLotsResponse_SellLimitsViewValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMaxLotsResponse_SellLimitsViewValidationError) ErrorName() string {
	return "GetMaxLotsResponse_SellLimitsViewValidationError"
}

// Error satisfies the builtin error interface
func (e GetMaxLotsResponse_SellLimitsViewValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMaxLotsResponse_SellLimitsView.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMaxLotsResponse_SellLimitsViewValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMaxLotsResponse_SellLimitsViewValidationError{}

// Validate checks the field values on GetOrderPriceResponse_ExtraBond with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrderPriceResponse_ExtraBond) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderPriceResponse_ExtraBond with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetOrderPriceResponse_ExtraBondMultiError, or nil if none found.
func (m *GetOrderPriceResponse_ExtraBond) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderPriceResponse_ExtraBond) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAciValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponse_ExtraBondValidationError{
					field:  "AciValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponse_ExtraBondValidationError{
					field:  "AciValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAciValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponse_ExtraBondValidationError{
				field:  "AciValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNominalConversionRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponse_ExtraBondValidationError{
					field:  "NominalConversionRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponse_ExtraBondValidationError{
					field:  "NominalConversionRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominalConversionRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponse_ExtraBondValidationError{
				field:  "NominalConversionRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOrderPriceResponse_ExtraBondMultiError(errors)
	}

	return nil
}

// GetOrderPriceResponse_ExtraBondMultiError is an error wrapping multiple
// validation errors returned by GetOrderPriceResponse_ExtraBond.ValidateAll()
// if the designated constraints aren't met.
type GetOrderPriceResponse_ExtraBondMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderPriceResponse_ExtraBondMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderPriceResponse_ExtraBondMultiError) AllErrors() []error { return m }

// GetOrderPriceResponse_ExtraBondValidationError is the validation error
// returned by GetOrderPriceResponse_ExtraBond.Validate if the designated
// constraints aren't met.
type GetOrderPriceResponse_ExtraBondValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderPriceResponse_ExtraBondValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderPriceResponse_ExtraBondValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderPriceResponse_ExtraBondValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderPriceResponse_ExtraBondValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderPriceResponse_ExtraBondValidationError) ErrorName() string {
	return "GetOrderPriceResponse_ExtraBondValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrderPriceResponse_ExtraBondValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderPriceResponse_ExtraBond.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderPriceResponse_ExtraBondValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderPriceResponse_ExtraBondValidationError{}

// Validate checks the field values on GetOrderPriceResponse_ExtraFuture with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetOrderPriceResponse_ExtraFuture) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderPriceResponse_ExtraFuture
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetOrderPriceResponse_ExtraFutureMultiError, or nil if none found.
func (m *GetOrderPriceResponse_ExtraFuture) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderPriceResponse_ExtraFuture) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitialMargin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderPriceResponse_ExtraFutureValidationError{
					field:  "InitialMargin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderPriceResponse_ExtraFutureValidationError{
					field:  "InitialMargin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialMargin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderPriceResponse_ExtraFutureValidationError{
				field:  "InitialMargin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetOrderPriceResponse_ExtraFutureMultiError(errors)
	}

	return nil
}

// GetOrderPriceResponse_ExtraFutureMultiError is an error wrapping multiple
// validation errors returned by
// GetOrderPriceResponse_ExtraFuture.ValidateAll() if the designated
// constraints aren't met.
type GetOrderPriceResponse_ExtraFutureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderPriceResponse_ExtraFutureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderPriceResponse_ExtraFutureMultiError) AllErrors() []error { return m }

// GetOrderPriceResponse_ExtraFutureValidationError is the validation error
// returned by GetOrderPriceResponse_ExtraFuture.Validate if the designated
// constraints aren't met.
type GetOrderPriceResponse_ExtraFutureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderPriceResponse_ExtraFutureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderPriceResponse_ExtraFutureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderPriceResponse_ExtraFutureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderPriceResponse_ExtraFutureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderPriceResponse_ExtraFutureValidationError) ErrorName() string {
	return "GetOrderPriceResponse_ExtraFutureValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrderPriceResponse_ExtraFutureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderPriceResponse_ExtraFuture.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderPriceResponse_ExtraFutureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderPriceResponse_ExtraFutureValidationError{}

// Validate checks the field values on OrderStateStreamResponse_OrderState with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *OrderStateStreamResponse_OrderState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderStateStreamResponse_OrderState
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// OrderStateStreamResponse_OrderStateMultiError, or nil if none found.
func (m *OrderStateStreamResponse_OrderState) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderStateStreamResponse_OrderState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OrderId

	// no validation rules for ClientCode

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateStreamResponse_OrderStateValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExecutionReportStatus

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for LotSize

	// no validation rules for Direction

	// no validation rules for TimeInForce

	// no validation rules for OrderType

	// no validation rules for AccountId

	if all {
		switch v := interface{}(m.GetInitialOrderPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "InitialOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "InitialOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialOrderPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateStreamResponse_OrderStateValidationError{
				field:  "InitialOrderPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOrderPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "OrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "OrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateStreamResponse_OrderStateValidationError{
				field:  "OrderPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutedOrderPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "ExecutedOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "ExecutedOrderPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedOrderPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateStreamResponse_OrderStateValidationError{
				field:  "ExecutedOrderPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	// no validation rules for LotsRequested

	// no validation rules for LotsExecuted

	// no validation rules for LotsLeft

	// no validation rules for LotsCancelled

	for idx, item := range m.GetTrades() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderStateStreamResponse_OrderStateValidationError{
					field:  fmt.Sprintf("Trades[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCompletionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "CompletionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
					field:  "CompletionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompletionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderStateStreamResponse_OrderStateValidationError{
				field:  "CompletionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Exchange

	// no validation rules for InstrumentUid

	if m.OrderRequestId != nil {
		// no validation rules for OrderRequestId
	}

	if m.StatusInfo != nil {
		// no validation rules for StatusInfo
	}

	if m.Amount != nil {

		if all {
			switch v := interface{}(m.GetAmount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
						field:  "Amount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderStateStreamResponse_OrderStateValidationError{
						field:  "Amount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAmount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderStateStreamResponse_OrderStateValidationError{
					field:  "Amount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Marker != nil {
		// no validation rules for Marker
	}

	if len(errors) > 0 {
		return OrderStateStreamResponse_OrderStateMultiError(errors)
	}

	return nil
}

// OrderStateStreamResponse_OrderStateMultiError is an error wrapping multiple
// validation errors returned by
// OrderStateStreamResponse_OrderState.ValidateAll() if the designated
// constraints aren't met.
type OrderStateStreamResponse_OrderStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderStateStreamResponse_OrderStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderStateStreamResponse_OrderStateMultiError) AllErrors() []error { return m }

// OrderStateStreamResponse_OrderStateValidationError is the validation error
// returned by OrderStateStreamResponse_OrderState.Validate if the designated
// constraints aren't met.
type OrderStateStreamResponse_OrderStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderStateStreamResponse_OrderStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderStateStreamResponse_OrderStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderStateStreamResponse_OrderStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderStateStreamResponse_OrderStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderStateStreamResponse_OrderStateValidationError) ErrorName() string {
	return "OrderStateStreamResponse_OrderStateValidationError"
}

// Error satisfies the builtin error interface
func (e OrderStateStreamResponse_OrderStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderStateStreamResponse_OrderState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderStateStreamResponse_OrderStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderStateStreamResponse_OrderStateValidationError{}
