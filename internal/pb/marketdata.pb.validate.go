// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: marketdata.proto

package contractv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on MarketDataRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MarketDataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarketDataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarketDataRequestMultiError, or nil if none found.
func (m *MarketDataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MarketDataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *MarketDataRequest_SubscribeCandlesRequest:
		if v == nil {
			err := MarketDataRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeCandlesRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeCandlesRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeCandlesRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeCandlesRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataRequestValidationError{
					field:  "SubscribeCandlesRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataRequest_SubscribeOrderBookRequest:
		if v == nil {
			err := MarketDataRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeOrderBookRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeOrderBookRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeOrderBookRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeOrderBookRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataRequestValidationError{
					field:  "SubscribeOrderBookRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataRequest_SubscribeTradesRequest:
		if v == nil {
			err := MarketDataRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeTradesRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeTradesRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeTradesRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeTradesRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataRequestValidationError{
					field:  "SubscribeTradesRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataRequest_SubscribeInfoRequest:
		if v == nil {
			err := MarketDataRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeInfoRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeInfoRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeInfoRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeInfoRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataRequestValidationError{
					field:  "SubscribeInfoRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataRequest_SubscribeLastPriceRequest:
		if v == nil {
			err := MarketDataRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeLastPriceRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeLastPriceRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "SubscribeLastPriceRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeLastPriceRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataRequestValidationError{
					field:  "SubscribeLastPriceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataRequest_GetMySubscriptions:
		if v == nil {
			err := MarketDataRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetMySubscriptions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "GetMySubscriptions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "GetMySubscriptions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetMySubscriptions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataRequestValidationError{
					field:  "GetMySubscriptions",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataRequest_Ping:
		if v == nil {
			err := MarketDataRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPing()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPing()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataRequestValidationError{
					field:  "Ping",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataRequest_PingSettings:
		if v == nil {
			err := MarketDataRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPingSettings()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "PingSettings",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataRequestValidationError{
						field:  "PingSettings",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPingSettings()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataRequestValidationError{
					field:  "PingSettings",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MarketDataRequestMultiError(errors)
	}

	return nil
}

// MarketDataRequestMultiError is an error wrapping multiple validation errors
// returned by MarketDataRequest.ValidateAll() if the designated constraints
// aren't met.
type MarketDataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarketDataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarketDataRequestMultiError) AllErrors() []error { return m }

// MarketDataRequestValidationError is the validation error returned by
// MarketDataRequest.Validate if the designated constraints aren't met.
type MarketDataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarketDataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarketDataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarketDataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarketDataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarketDataRequestValidationError) ErrorName() string {
	return "MarketDataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MarketDataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarketDataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarketDataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarketDataRequestValidationError{}

// Validate checks the field values on MarketDataServerSideStreamRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MarketDataServerSideStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarketDataServerSideStreamRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// MarketDataServerSideStreamRequestMultiError, or nil if none found.
func (m *MarketDataServerSideStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MarketDataServerSideStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubscribeCandlesRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeCandlesRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeCandlesRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscribeCandlesRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketDataServerSideStreamRequestValidationError{
				field:  "SubscribeCandlesRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscribeOrderBookRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeOrderBookRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeOrderBookRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscribeOrderBookRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketDataServerSideStreamRequestValidationError{
				field:  "SubscribeOrderBookRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscribeTradesRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeTradesRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeTradesRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscribeTradesRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketDataServerSideStreamRequestValidationError{
				field:  "SubscribeTradesRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscribeInfoRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeInfoRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeInfoRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscribeInfoRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketDataServerSideStreamRequestValidationError{
				field:  "SubscribeInfoRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubscribeLastPriceRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeLastPriceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "SubscribeLastPriceRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscribeLastPriceRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketDataServerSideStreamRequestValidationError{
				field:  "SubscribeLastPriceRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPingSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "PingSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MarketDataServerSideStreamRequestValidationError{
					field:  "PingSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPingSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MarketDataServerSideStreamRequestValidationError{
				field:  "PingSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MarketDataServerSideStreamRequestMultiError(errors)
	}

	return nil
}

// MarketDataServerSideStreamRequestMultiError is an error wrapping multiple
// validation errors returned by
// MarketDataServerSideStreamRequest.ValidateAll() if the designated
// constraints aren't met.
type MarketDataServerSideStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarketDataServerSideStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarketDataServerSideStreamRequestMultiError) AllErrors() []error { return m }

// MarketDataServerSideStreamRequestValidationError is the validation error
// returned by MarketDataServerSideStreamRequest.Validate if the designated
// constraints aren't met.
type MarketDataServerSideStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarketDataServerSideStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarketDataServerSideStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarketDataServerSideStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarketDataServerSideStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarketDataServerSideStreamRequestValidationError) ErrorName() string {
	return "MarketDataServerSideStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e MarketDataServerSideStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarketDataServerSideStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarketDataServerSideStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarketDataServerSideStreamRequestValidationError{}

// Validate checks the field values on MarketDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MarketDataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MarketDataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MarketDataResponseMultiError, or nil if none found.
func (m *MarketDataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MarketDataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *MarketDataResponse_SubscribeCandlesResponse:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeCandlesResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeCandlesResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeCandlesResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeCandlesResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "SubscribeCandlesResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_SubscribeOrderBookResponse:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeOrderBookResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeOrderBookResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeOrderBookResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeOrderBookResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "SubscribeOrderBookResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_SubscribeTradesResponse:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeTradesResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeTradesResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeTradesResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeTradesResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "SubscribeTradesResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_SubscribeInfoResponse:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeInfoResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeInfoResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeInfoResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeInfoResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "SubscribeInfoResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_Candle:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCandle()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "Candle",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "Candle",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCandle()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "Candle",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_Trade:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrade()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "Trade",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "Trade",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrade()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "Trade",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_Orderbook:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOrderbook()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "Orderbook",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "Orderbook",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOrderbook()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "Orderbook",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_TradingStatus:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTradingStatus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "TradingStatus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "TradingStatus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTradingStatus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "TradingStatus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_Ping:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPing()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPing()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "Ping",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_SubscribeLastPriceResponse:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscribeLastPriceResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeLastPriceResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "SubscribeLastPriceResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscribeLastPriceResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "SubscribeLastPriceResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MarketDataResponse_LastPrice:
		if v == nil {
			err := MarketDataResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLastPrice()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "LastPrice",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MarketDataResponseValidationError{
						field:  "LastPrice",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastPrice()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MarketDataResponseValidationError{
					field:  "LastPrice",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MarketDataResponseMultiError(errors)
	}

	return nil
}

// MarketDataResponseMultiError is an error wrapping multiple validation errors
// returned by MarketDataResponse.ValidateAll() if the designated constraints
// aren't met.
type MarketDataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MarketDataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MarketDataResponseMultiError) AllErrors() []error { return m }

// MarketDataResponseValidationError is the validation error returned by
// MarketDataResponse.Validate if the designated constraints aren't met.
type MarketDataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MarketDataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MarketDataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MarketDataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MarketDataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MarketDataResponseValidationError) ErrorName() string {
	return "MarketDataResponseValidationError"
}

// Error satisfies the builtin error interface
func (e MarketDataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMarketDataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MarketDataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MarketDataResponseValidationError{}

// Validate checks the field values on SubscribeCandlesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeCandlesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeCandlesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeCandlesRequestMultiError, or nil if none found.
func (m *SubscribeCandlesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeCandlesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionAction

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeCandlesRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeCandlesRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeCandlesRequestValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for WaitingClose

	if m.CandleSourceType != nil {
		// no validation rules for CandleSourceType
	}

	if len(errors) > 0 {
		return SubscribeCandlesRequestMultiError(errors)
	}

	return nil
}

// SubscribeCandlesRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeCandlesRequest.ValidateAll() if the designated
// constraints aren't met.
type SubscribeCandlesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeCandlesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeCandlesRequestMultiError) AllErrors() []error { return m }

// SubscribeCandlesRequestValidationError is the validation error returned by
// SubscribeCandlesRequest.Validate if the designated constraints aren't met.
type SubscribeCandlesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeCandlesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeCandlesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeCandlesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeCandlesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeCandlesRequestValidationError) ErrorName() string {
	return "SubscribeCandlesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeCandlesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeCandlesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeCandlesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeCandlesRequestValidationError{}

// Validate checks the field values on CandleInstrument with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CandleInstrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CandleInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CandleInstrumentMultiError, or nil if none found.
func (m *CandleInstrument) ValidateAll() error {
	return m.validate(true)
}

func (m *CandleInstrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Interval

	// no validation rules for InstrumentId

	if len(errors) > 0 {
		return CandleInstrumentMultiError(errors)
	}

	return nil
}

// CandleInstrumentMultiError is an error wrapping multiple validation errors
// returned by CandleInstrument.ValidateAll() if the designated constraints
// aren't met.
type CandleInstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CandleInstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CandleInstrumentMultiError) AllErrors() []error { return m }

// CandleInstrumentValidationError is the validation error returned by
// CandleInstrument.Validate if the designated constraints aren't met.
type CandleInstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CandleInstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CandleInstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CandleInstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CandleInstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CandleInstrumentValidationError) ErrorName() string { return "CandleInstrumentValidationError" }

// Error satisfies the builtin error interface
func (e CandleInstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCandleInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CandleInstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CandleInstrumentValidationError{}

// Validate checks the field values on SubscribeCandlesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeCandlesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeCandlesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeCandlesResponseMultiError, or nil if none found.
func (m *SubscribeCandlesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeCandlesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackingId

	for idx, item := range m.GetCandlesSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeCandlesResponseValidationError{
						field:  fmt.Sprintf("CandlesSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeCandlesResponseValidationError{
						field:  fmt.Sprintf("CandlesSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeCandlesResponseValidationError{
					field:  fmt.Sprintf("CandlesSubscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribeCandlesResponseMultiError(errors)
	}

	return nil
}

// SubscribeCandlesResponseMultiError is an error wrapping multiple validation
// errors returned by SubscribeCandlesResponse.ValidateAll() if the designated
// constraints aren't met.
type SubscribeCandlesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeCandlesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeCandlesResponseMultiError) AllErrors() []error { return m }

// SubscribeCandlesResponseValidationError is the validation error returned by
// SubscribeCandlesResponse.Validate if the designated constraints aren't met.
type SubscribeCandlesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeCandlesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeCandlesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeCandlesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeCandlesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeCandlesResponseValidationError) ErrorName() string {
	return "SubscribeCandlesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeCandlesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeCandlesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeCandlesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeCandlesResponseValidationError{}

// Validate checks the field values on CandleSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CandleSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CandleSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CandleSubscriptionMultiError, or nil if none found.
func (m *CandleSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *CandleSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Interval

	// no validation rules for SubscriptionStatus

	// no validation rules for InstrumentUid

	// no validation rules for WaitingClose

	// no validation rules for StreamId

	// no validation rules for SubscriptionId

	if m.CandleSourceType != nil {
		// no validation rules for CandleSourceType
	}

	if len(errors) > 0 {
		return CandleSubscriptionMultiError(errors)
	}

	return nil
}

// CandleSubscriptionMultiError is an error wrapping multiple validation errors
// returned by CandleSubscription.ValidateAll() if the designated constraints
// aren't met.
type CandleSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CandleSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CandleSubscriptionMultiError) AllErrors() []error { return m }

// CandleSubscriptionValidationError is the validation error returned by
// CandleSubscription.Validate if the designated constraints aren't met.
type CandleSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CandleSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CandleSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CandleSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CandleSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CandleSubscriptionValidationError) ErrorName() string {
	return "CandleSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e CandleSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCandleSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CandleSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CandleSubscriptionValidationError{}

// Validate checks the field values on SubscribeOrderBookRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeOrderBookRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeOrderBookRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeOrderBookRequestMultiError, or nil if none found.
func (m *SubscribeOrderBookRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeOrderBookRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionAction

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeOrderBookRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeOrderBookRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeOrderBookRequestValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribeOrderBookRequestMultiError(errors)
	}

	return nil
}

// SubscribeOrderBookRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeOrderBookRequest.ValidateAll() if the
// designated constraints aren't met.
type SubscribeOrderBookRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeOrderBookRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeOrderBookRequestMultiError) AllErrors() []error { return m }

// SubscribeOrderBookRequestValidationError is the validation error returned by
// SubscribeOrderBookRequest.Validate if the designated constraints aren't met.
type SubscribeOrderBookRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeOrderBookRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeOrderBookRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeOrderBookRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeOrderBookRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeOrderBookRequestValidationError) ErrorName() string {
	return "SubscribeOrderBookRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeOrderBookRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeOrderBookRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeOrderBookRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeOrderBookRequestValidationError{}

// Validate checks the field values on OrderBookInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderBookInstrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderBookInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderBookInstrumentMultiError, or nil if none found.
func (m *OrderBookInstrument) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderBookInstrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Depth

	// no validation rules for InstrumentId

	// no validation rules for OrderBookType

	if len(errors) > 0 {
		return OrderBookInstrumentMultiError(errors)
	}

	return nil
}

// OrderBookInstrumentMultiError is an error wrapping multiple validation
// errors returned by OrderBookInstrument.ValidateAll() if the designated
// constraints aren't met.
type OrderBookInstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderBookInstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderBookInstrumentMultiError) AllErrors() []error { return m }

// OrderBookInstrumentValidationError is the validation error returned by
// OrderBookInstrument.Validate if the designated constraints aren't met.
type OrderBookInstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderBookInstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderBookInstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderBookInstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderBookInstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderBookInstrumentValidationError) ErrorName() string {
	return "OrderBookInstrumentValidationError"
}

// Error satisfies the builtin error interface
func (e OrderBookInstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderBookInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderBookInstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderBookInstrumentValidationError{}

// Validate checks the field values on SubscribeOrderBookResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeOrderBookResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeOrderBookResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeOrderBookResponseMultiError, or nil if none found.
func (m *SubscribeOrderBookResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeOrderBookResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackingId

	for idx, item := range m.GetOrderBookSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeOrderBookResponseValidationError{
						field:  fmt.Sprintf("OrderBookSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeOrderBookResponseValidationError{
						field:  fmt.Sprintf("OrderBookSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeOrderBookResponseValidationError{
					field:  fmt.Sprintf("OrderBookSubscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribeOrderBookResponseMultiError(errors)
	}

	return nil
}

// SubscribeOrderBookResponseMultiError is an error wrapping multiple
// validation errors returned by SubscribeOrderBookResponse.ValidateAll() if
// the designated constraints aren't met.
type SubscribeOrderBookResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeOrderBookResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeOrderBookResponseMultiError) AllErrors() []error { return m }

// SubscribeOrderBookResponseValidationError is the validation error returned
// by SubscribeOrderBookResponse.Validate if the designated constraints aren't met.
type SubscribeOrderBookResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeOrderBookResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeOrderBookResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeOrderBookResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeOrderBookResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeOrderBookResponseValidationError) ErrorName() string {
	return "SubscribeOrderBookResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeOrderBookResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeOrderBookResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeOrderBookResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeOrderBookResponseValidationError{}

// Validate checks the field values on OrderBookSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OrderBookSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderBookSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OrderBookSubscriptionMultiError, or nil if none found.
func (m *OrderBookSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderBookSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Depth

	// no validation rules for SubscriptionStatus

	// no validation rules for InstrumentUid

	// no validation rules for StreamId

	// no validation rules for SubscriptionId

	// no validation rules for OrderBookType

	if len(errors) > 0 {
		return OrderBookSubscriptionMultiError(errors)
	}

	return nil
}

// OrderBookSubscriptionMultiError is an error wrapping multiple validation
// errors returned by OrderBookSubscription.ValidateAll() if the designated
// constraints aren't met.
type OrderBookSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderBookSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderBookSubscriptionMultiError) AllErrors() []error { return m }

// OrderBookSubscriptionValidationError is the validation error returned by
// OrderBookSubscription.Validate if the designated constraints aren't met.
type OrderBookSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderBookSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderBookSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderBookSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderBookSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderBookSubscriptionValidationError) ErrorName() string {
	return "OrderBookSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e OrderBookSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderBookSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderBookSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderBookSubscriptionValidationError{}

// Validate checks the field values on SubscribeTradesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeTradesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeTradesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeTradesRequestMultiError, or nil if none found.
func (m *SubscribeTradesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeTradesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionAction

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeTradesRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeTradesRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeTradesRequestValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TradeSource

	if len(errors) > 0 {
		return SubscribeTradesRequestMultiError(errors)
	}

	return nil
}

// SubscribeTradesRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeTradesRequest.ValidateAll() if the designated
// constraints aren't met.
type SubscribeTradesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeTradesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeTradesRequestMultiError) AllErrors() []error { return m }

// SubscribeTradesRequestValidationError is the validation error returned by
// SubscribeTradesRequest.Validate if the designated constraints aren't met.
type SubscribeTradesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeTradesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeTradesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeTradesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeTradesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeTradesRequestValidationError) ErrorName() string {
	return "SubscribeTradesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeTradesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeTradesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeTradesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeTradesRequestValidationError{}

// Validate checks the field values on TradeInstrument with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TradeInstrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeInstrumentMultiError, or nil if none found.
func (m *TradeInstrument) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeInstrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for InstrumentId

	if len(errors) > 0 {
		return TradeInstrumentMultiError(errors)
	}

	return nil
}

// TradeInstrumentMultiError is an error wrapping multiple validation errors
// returned by TradeInstrument.ValidateAll() if the designated constraints
// aren't met.
type TradeInstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeInstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeInstrumentMultiError) AllErrors() []error { return m }

// TradeInstrumentValidationError is the validation error returned by
// TradeInstrument.Validate if the designated constraints aren't met.
type TradeInstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeInstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeInstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeInstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeInstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeInstrumentValidationError) ErrorName() string { return "TradeInstrumentValidationError" }

// Error satisfies the builtin error interface
func (e TradeInstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeInstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeInstrumentValidationError{}

// Validate checks the field values on SubscribeTradesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeTradesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeTradesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeTradesResponseMultiError, or nil if none found.
func (m *SubscribeTradesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeTradesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackingId

	for idx, item := range m.GetTradeSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeTradesResponseValidationError{
						field:  fmt.Sprintf("TradeSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeTradesResponseValidationError{
						field:  fmt.Sprintf("TradeSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeTradesResponseValidationError{
					field:  fmt.Sprintf("TradeSubscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TradeSource

	if len(errors) > 0 {
		return SubscribeTradesResponseMultiError(errors)
	}

	return nil
}

// SubscribeTradesResponseMultiError is an error wrapping multiple validation
// errors returned by SubscribeTradesResponse.ValidateAll() if the designated
// constraints aren't met.
type SubscribeTradesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeTradesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeTradesResponseMultiError) AllErrors() []error { return m }

// SubscribeTradesResponseValidationError is the validation error returned by
// SubscribeTradesResponse.Validate if the designated constraints aren't met.
type SubscribeTradesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeTradesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeTradesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeTradesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeTradesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeTradesResponseValidationError) ErrorName() string {
	return "SubscribeTradesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeTradesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeTradesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeTradesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeTradesResponseValidationError{}

// Validate checks the field values on TradeSubscription with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TradeSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradeSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradeSubscriptionMultiError, or nil if none found.
func (m *TradeSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *TradeSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for SubscriptionStatus

	// no validation rules for InstrumentUid

	// no validation rules for StreamId

	// no validation rules for SubscriptionId

	if len(errors) > 0 {
		return TradeSubscriptionMultiError(errors)
	}

	return nil
}

// TradeSubscriptionMultiError is an error wrapping multiple validation errors
// returned by TradeSubscription.ValidateAll() if the designated constraints
// aren't met.
type TradeSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeSubscriptionMultiError) AllErrors() []error { return m }

// TradeSubscriptionValidationError is the validation error returned by
// TradeSubscription.Validate if the designated constraints aren't met.
type TradeSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeSubscriptionValidationError) ErrorName() string {
	return "TradeSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e TradeSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradeSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeSubscriptionValidationError{}

// Validate checks the field values on SubscribeInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeInfoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeInfoRequestMultiError, or nil if none found.
func (m *SubscribeInfoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeInfoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionAction

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeInfoRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeInfoRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeInfoRequestValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribeInfoRequestMultiError(errors)
	}

	return nil
}

// SubscribeInfoRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeInfoRequest.ValidateAll() if the designated
// constraints aren't met.
type SubscribeInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeInfoRequestMultiError) AllErrors() []error { return m }

// SubscribeInfoRequestValidationError is the validation error returned by
// SubscribeInfoRequest.Validate if the designated constraints aren't met.
type SubscribeInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeInfoRequestValidationError) ErrorName() string {
	return "SubscribeInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeInfoRequestValidationError{}

// Validate checks the field values on InfoInstrument with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InfoInstrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InfoInstrument with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InfoInstrumentMultiError,
// or nil if none found.
func (m *InfoInstrument) ValidateAll() error {
	return m.validate(true)
}

func (m *InfoInstrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for InstrumentId

	if len(errors) > 0 {
		return InfoInstrumentMultiError(errors)
	}

	return nil
}

// InfoInstrumentMultiError is an error wrapping multiple validation errors
// returned by InfoInstrument.ValidateAll() if the designated constraints
// aren't met.
type InfoInstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoInstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoInstrumentMultiError) AllErrors() []error { return m }

// InfoInstrumentValidationError is the validation error returned by
// InfoInstrument.Validate if the designated constraints aren't met.
type InfoInstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoInstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoInstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoInstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoInstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoInstrumentValidationError) ErrorName() string { return "InfoInstrumentValidationError" }

// Error satisfies the builtin error interface
func (e InfoInstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfoInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoInstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoInstrumentValidationError{}

// Validate checks the field values on SubscribeInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeInfoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeInfoResponseMultiError, or nil if none found.
func (m *SubscribeInfoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeInfoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackingId

	for idx, item := range m.GetInfoSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeInfoResponseValidationError{
						field:  fmt.Sprintf("InfoSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeInfoResponseValidationError{
						field:  fmt.Sprintf("InfoSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeInfoResponseValidationError{
					field:  fmt.Sprintf("InfoSubscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribeInfoResponseMultiError(errors)
	}

	return nil
}

// SubscribeInfoResponseMultiError is an error wrapping multiple validation
// errors returned by SubscribeInfoResponse.ValidateAll() if the designated
// constraints aren't met.
type SubscribeInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeInfoResponseMultiError) AllErrors() []error { return m }

// SubscribeInfoResponseValidationError is the validation error returned by
// SubscribeInfoResponse.Validate if the designated constraints aren't met.
type SubscribeInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeInfoResponseValidationError) ErrorName() string {
	return "SubscribeInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeInfoResponseValidationError{}

// Validate checks the field values on InfoSubscription with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InfoSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InfoSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InfoSubscriptionMultiError, or nil if none found.
func (m *InfoSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *InfoSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for SubscriptionStatus

	// no validation rules for InstrumentUid

	// no validation rules for StreamId

	// no validation rules for SubscriptionId

	if len(errors) > 0 {
		return InfoSubscriptionMultiError(errors)
	}

	return nil
}

// InfoSubscriptionMultiError is an error wrapping multiple validation errors
// returned by InfoSubscription.ValidateAll() if the designated constraints
// aren't met.
type InfoSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InfoSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InfoSubscriptionMultiError) AllErrors() []error { return m }

// InfoSubscriptionValidationError is the validation error returned by
// InfoSubscription.Validate if the designated constraints aren't met.
type InfoSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InfoSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InfoSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InfoSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InfoSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InfoSubscriptionValidationError) ErrorName() string { return "InfoSubscriptionValidationError" }

// Error satisfies the builtin error interface
func (e InfoSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInfoSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InfoSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InfoSubscriptionValidationError{}

// Validate checks the field values on SubscribeLastPriceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeLastPriceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeLastPriceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeLastPriceRequestMultiError, or nil if none found.
func (m *SubscribeLastPriceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeLastPriceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SubscriptionAction

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeLastPriceRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeLastPriceRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeLastPriceRequestValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribeLastPriceRequestMultiError(errors)
	}

	return nil
}

// SubscribeLastPriceRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeLastPriceRequest.ValidateAll() if the
// designated constraints aren't met.
type SubscribeLastPriceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeLastPriceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeLastPriceRequestMultiError) AllErrors() []error { return m }

// SubscribeLastPriceRequestValidationError is the validation error returned by
// SubscribeLastPriceRequest.Validate if the designated constraints aren't met.
type SubscribeLastPriceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeLastPriceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeLastPriceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeLastPriceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeLastPriceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeLastPriceRequestValidationError) ErrorName() string {
	return "SubscribeLastPriceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeLastPriceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeLastPriceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeLastPriceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeLastPriceRequestValidationError{}

// Validate checks the field values on LastPriceInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LastPriceInstrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LastPriceInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LastPriceInstrumentMultiError, or nil if none found.
func (m *LastPriceInstrument) ValidateAll() error {
	return m.validate(true)
}

func (m *LastPriceInstrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for InstrumentId

	if len(errors) > 0 {
		return LastPriceInstrumentMultiError(errors)
	}

	return nil
}

// LastPriceInstrumentMultiError is an error wrapping multiple validation
// errors returned by LastPriceInstrument.ValidateAll() if the designated
// constraints aren't met.
type LastPriceInstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LastPriceInstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LastPriceInstrumentMultiError) AllErrors() []error { return m }

// LastPriceInstrumentValidationError is the validation error returned by
// LastPriceInstrument.Validate if the designated constraints aren't met.
type LastPriceInstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LastPriceInstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LastPriceInstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LastPriceInstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LastPriceInstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LastPriceInstrumentValidationError) ErrorName() string {
	return "LastPriceInstrumentValidationError"
}

// Error satisfies the builtin error interface
func (e LastPriceInstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLastPriceInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LastPriceInstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LastPriceInstrumentValidationError{}

// Validate checks the field values on SubscribeLastPriceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeLastPriceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeLastPriceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeLastPriceResponseMultiError, or nil if none found.
func (m *SubscribeLastPriceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeLastPriceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TrackingId

	for idx, item := range m.GetLastPriceSubscriptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscribeLastPriceResponseValidationError{
						field:  fmt.Sprintf("LastPriceSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscribeLastPriceResponseValidationError{
						field:  fmt.Sprintf("LastPriceSubscriptions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscribeLastPriceResponseValidationError{
					field:  fmt.Sprintf("LastPriceSubscriptions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscribeLastPriceResponseMultiError(errors)
	}

	return nil
}

// SubscribeLastPriceResponseMultiError is an error wrapping multiple
// validation errors returned by SubscribeLastPriceResponse.ValidateAll() if
// the designated constraints aren't met.
type SubscribeLastPriceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeLastPriceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeLastPriceResponseMultiError) AllErrors() []error { return m }

// SubscribeLastPriceResponseValidationError is the validation error returned
// by SubscribeLastPriceResponse.Validate if the designated constraints aren't met.
type SubscribeLastPriceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeLastPriceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeLastPriceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeLastPriceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeLastPriceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeLastPriceResponseValidationError) ErrorName() string {
	return "SubscribeLastPriceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeLastPriceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeLastPriceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeLastPriceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeLastPriceResponseValidationError{}

// Validate checks the field values on LastPriceSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LastPriceSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LastPriceSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LastPriceSubscriptionMultiError, or nil if none found.
func (m *LastPriceSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *LastPriceSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for SubscriptionStatus

	// no validation rules for InstrumentUid

	// no validation rules for StreamId

	// no validation rules for SubscriptionId

	if len(errors) > 0 {
		return LastPriceSubscriptionMultiError(errors)
	}

	return nil
}

// LastPriceSubscriptionMultiError is an error wrapping multiple validation
// errors returned by LastPriceSubscription.ValidateAll() if the designated
// constraints aren't met.
type LastPriceSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LastPriceSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LastPriceSubscriptionMultiError) AllErrors() []error { return m }

// LastPriceSubscriptionValidationError is the validation error returned by
// LastPriceSubscription.Validate if the designated constraints aren't met.
type LastPriceSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LastPriceSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LastPriceSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LastPriceSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LastPriceSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LastPriceSubscriptionValidationError) ErrorName() string {
	return "LastPriceSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e LastPriceSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLastPriceSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LastPriceSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LastPriceSubscriptionValidationError{}

// Validate checks the field values on Candle with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Candle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Candle with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CandleMultiError, or nil if none found.
func (m *Candle) ValidateAll() error {
	return m.validate(true)
}

func (m *Candle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Interval

	if all {
		switch v := interface{}(m.GetOpen()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "Open",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "Open",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpen()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CandleValidationError{
				field:  "Open",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHigh()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "High",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "High",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHigh()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CandleValidationError{
				field:  "High",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "Low",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "Low",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CandleValidationError{
				field:  "Low",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClose()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "Close",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "Close",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClose()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CandleValidationError{
				field:  "Close",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Volume

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CandleValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastTradeTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "LastTradeTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CandleValidationError{
					field:  "LastTradeTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastTradeTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CandleValidationError{
				field:  "LastTradeTs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstrumentUid

	// no validation rules for CandleSourceType

	if len(errors) > 0 {
		return CandleMultiError(errors)
	}

	return nil
}

// CandleMultiError is an error wrapping multiple validation errors returned by
// Candle.ValidateAll() if the designated constraints aren't met.
type CandleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CandleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CandleMultiError) AllErrors() []error { return m }

// CandleValidationError is the validation error returned by Candle.Validate if
// the designated constraints aren't met.
type CandleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CandleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CandleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CandleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CandleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CandleValidationError) ErrorName() string { return "CandleValidationError" }

// Error satisfies the builtin error interface
func (e CandleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCandle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CandleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CandleValidationError{}

// Validate checks the field values on OrderBook with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OrderBook) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OrderBook with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OrderBookMultiError, or nil
// if none found.
func (m *OrderBook) ValidateAll() error {
	return m.validate(true)
}

func (m *OrderBook) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Depth

	// no validation rules for IsConsistent

	for idx, item := range m.GetBids() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderBookValidationError{
						field:  fmt.Sprintf("Bids[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderBookValidationError{
						field:  fmt.Sprintf("Bids[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderBookValidationError{
					field:  fmt.Sprintf("Bids[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAsks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OrderBookValidationError{
						field:  fmt.Sprintf("Asks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OrderBookValidationError{
						field:  fmt.Sprintf("Asks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OrderBookValidationError{
					field:  fmt.Sprintf("Asks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderBookValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderBookValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderBookValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLimitUp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderBookValidationError{
					field:  "LimitUp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderBookValidationError{
					field:  "LimitUp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimitUp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderBookValidationError{
				field:  "LimitUp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLimitDown()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderBookValidationError{
					field:  "LimitDown",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderBookValidationError{
					field:  "LimitDown",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimitDown()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderBookValidationError{
				field:  "LimitDown",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstrumentUid

	// no validation rules for OrderBookType

	if len(errors) > 0 {
		return OrderBookMultiError(errors)
	}

	return nil
}

// OrderBookMultiError is an error wrapping multiple validation errors returned
// by OrderBook.ValidateAll() if the designated constraints aren't met.
type OrderBookMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderBookMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderBookMultiError) AllErrors() []error { return m }

// OrderBookValidationError is the validation error returned by
// OrderBook.Validate if the designated constraints aren't met.
type OrderBookValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderBookValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderBookValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderBookValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderBookValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderBookValidationError) ErrorName() string { return "OrderBookValidationError" }

// Error satisfies the builtin error interface
func (e OrderBookValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrderBook.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderBookValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderBookValidationError{}

// Validate checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Order) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Order with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OrderMultiError, or nil if none found.
func (m *Order) ValidateAll() error {
	return m.validate(true)
}

func (m *Order) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OrderValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OrderValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	if len(errors) > 0 {
		return OrderMultiError(errors)
	}

	return nil
}

// OrderMultiError is an error wrapping multiple validation errors returned by
// Order.ValidateAll() if the designated constraints aren't met.
type OrderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OrderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OrderMultiError) AllErrors() []error { return m }

// OrderValidationError is the validation error returned by Order.Validate if
// the designated constraints aren't met.
type OrderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OrderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OrderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OrderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OrderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OrderValidationError) ErrorName() string { return "OrderValidationError" }

// Error satisfies the builtin error interface
func (e OrderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOrder.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OrderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OrderValidationError{}

// Validate checks the field values on Trade with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Trade) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trade with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TradeMultiError, or nil if none found.
func (m *Trade) ValidateAll() error {
	return m.validate(true)
}

func (m *Trade) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Direction

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradeValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradeValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradeValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstrumentUid

	// no validation rules for TradeSource

	if len(errors) > 0 {
		return TradeMultiError(errors)
	}

	return nil
}

// TradeMultiError is an error wrapping multiple validation errors returned by
// Trade.ValidateAll() if the designated constraints aren't met.
type TradeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradeMultiError) AllErrors() []error { return m }

// TradeValidationError is the validation error returned by Trade.Validate if
// the designated constraints aren't met.
type TradeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradeValidationError) ErrorName() string { return "TradeValidationError" }

// Error satisfies the builtin error interface
func (e TradeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrade.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradeValidationError{}

// Validate checks the field values on TradingStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TradingStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradingStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TradingStatusMultiError, or
// nil if none found.
func (m *TradingStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TradingStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for TradingStatus

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingStatusValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingStatusValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingStatusValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LimitOrderAvailableFlag

	// no validation rules for MarketOrderAvailableFlag

	// no validation rules for InstrumentUid

	if len(errors) > 0 {
		return TradingStatusMultiError(errors)
	}

	return nil
}

// TradingStatusMultiError is an error wrapping multiple validation errors
// returned by TradingStatus.ValidateAll() if the designated constraints
// aren't met.
type TradingStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradingStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradingStatusMultiError) AllErrors() []error { return m }

// TradingStatusValidationError is the validation error returned by
// TradingStatus.Validate if the designated constraints aren't met.
type TradingStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradingStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradingStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradingStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradingStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradingStatusValidationError) ErrorName() string { return "TradingStatusValidationError" }

// Error satisfies the builtin error interface
func (e TradingStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradingStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradingStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradingStatusValidationError{}

// Validate checks the field values on GetCandlesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCandlesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCandlesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCandlesRequestMultiError, or nil if none found.
func (m *GetCandlesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCandlesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCandlesRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCandlesRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCandlesRequestValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCandlesRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCandlesRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCandlesRequestValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Interval

	if m.Figi != nil {
		// no validation rules for Figi
	}

	if m.InstrumentId != nil {
		// no validation rules for InstrumentId
	}

	if m.CandleSourceType != nil {
		// no validation rules for CandleSourceType
	}

	if m.Limit != nil {
		// no validation rules for Limit
	}

	if len(errors) > 0 {
		return GetCandlesRequestMultiError(errors)
	}

	return nil
}

// GetCandlesRequestMultiError is an error wrapping multiple validation errors
// returned by GetCandlesRequest.ValidateAll() if the designated constraints
// aren't met.
type GetCandlesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCandlesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCandlesRequestMultiError) AllErrors() []error { return m }

// GetCandlesRequestValidationError is the validation error returned by
// GetCandlesRequest.Validate if the designated constraints aren't met.
type GetCandlesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCandlesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCandlesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCandlesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCandlesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCandlesRequestValidationError) ErrorName() string {
	return "GetCandlesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCandlesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCandlesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCandlesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCandlesRequestValidationError{}

// Validate checks the field values on GetCandlesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCandlesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCandlesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCandlesResponseMultiError, or nil if none found.
func (m *GetCandlesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCandlesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCandles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCandlesResponseValidationError{
						field:  fmt.Sprintf("Candles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCandlesResponseValidationError{
						field:  fmt.Sprintf("Candles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCandlesResponseValidationError{
					field:  fmt.Sprintf("Candles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCandlesResponseMultiError(errors)
	}

	return nil
}

// GetCandlesResponseMultiError is an error wrapping multiple validation errors
// returned by GetCandlesResponse.ValidateAll() if the designated constraints
// aren't met.
type GetCandlesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCandlesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCandlesResponseMultiError) AllErrors() []error { return m }

// GetCandlesResponseValidationError is the validation error returned by
// GetCandlesResponse.Validate if the designated constraints aren't met.
type GetCandlesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCandlesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCandlesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCandlesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCandlesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCandlesResponseValidationError) ErrorName() string {
	return "GetCandlesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCandlesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCandlesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCandlesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCandlesResponseValidationError{}

// Validate checks the field values on HistoricCandle with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HistoricCandle) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HistoricCandle with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HistoricCandleMultiError,
// or nil if none found.
func (m *HistoricCandle) ValidateAll() error {
	return m.validate(true)
}

func (m *HistoricCandle) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOpen()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "Open",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "Open",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpen()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoricCandleValidationError{
				field:  "Open",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHigh()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "High",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "High",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHigh()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoricCandleValidationError{
				field:  "High",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "Low",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "Low",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoricCandleValidationError{
				field:  "Low",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClose()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "Close",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "Close",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClose()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoricCandleValidationError{
				field:  "Close",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Volume

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HistoricCandleValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HistoricCandleValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsComplete

	// no validation rules for CandleSourceType

	if len(errors) > 0 {
		return HistoricCandleMultiError(errors)
	}

	return nil
}

// HistoricCandleMultiError is an error wrapping multiple validation errors
// returned by HistoricCandle.ValidateAll() if the designated constraints
// aren't met.
type HistoricCandleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HistoricCandleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HistoricCandleMultiError) AllErrors() []error { return m }

// HistoricCandleValidationError is the validation error returned by
// HistoricCandle.Validate if the designated constraints aren't met.
type HistoricCandleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HistoricCandleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HistoricCandleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HistoricCandleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HistoricCandleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HistoricCandleValidationError) ErrorName() string { return "HistoricCandleValidationError" }

// Error satisfies the builtin error interface
func (e HistoricCandleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHistoricCandle.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HistoricCandleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HistoricCandleValidationError{}

// Validate checks the field values on GetLastPricesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLastPricesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLastPricesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLastPricesRequestMultiError, or nil if none found.
func (m *GetLastPricesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLastPricesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LastPriceType

	if len(errors) > 0 {
		return GetLastPricesRequestMultiError(errors)
	}

	return nil
}

// GetLastPricesRequestMultiError is an error wrapping multiple validation
// errors returned by GetLastPricesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetLastPricesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLastPricesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLastPricesRequestMultiError) AllErrors() []error { return m }

// GetLastPricesRequestValidationError is the validation error returned by
// GetLastPricesRequest.Validate if the designated constraints aren't met.
type GetLastPricesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLastPricesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLastPricesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLastPricesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLastPricesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLastPricesRequestValidationError) ErrorName() string {
	return "GetLastPricesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLastPricesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLastPricesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLastPricesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLastPricesRequestValidationError{}

// Validate checks the field values on GetLastPricesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLastPricesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLastPricesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLastPricesResponseMultiError, or nil if none found.
func (m *GetLastPricesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLastPricesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLastPrices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLastPricesResponseValidationError{
						field:  fmt.Sprintf("LastPrices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLastPricesResponseValidationError{
						field:  fmt.Sprintf("LastPrices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLastPricesResponseValidationError{
					field:  fmt.Sprintf("LastPrices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetLastPricesResponseMultiError(errors)
	}

	return nil
}

// GetLastPricesResponseMultiError is an error wrapping multiple validation
// errors returned by GetLastPricesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetLastPricesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLastPricesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLastPricesResponseMultiError) AllErrors() []error { return m }

// GetLastPricesResponseValidationError is the validation error returned by
// GetLastPricesResponse.Validate if the designated constraints aren't met.
type GetLastPricesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLastPricesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLastPricesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLastPricesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLastPricesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLastPricesResponseValidationError) ErrorName() string {
	return "GetLastPricesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetLastPricesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLastPricesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLastPricesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLastPricesResponseValidationError{}

// Validate checks the field values on LastPrice with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LastPrice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LastPrice with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LastPriceMultiError, or nil
// if none found.
func (m *LastPrice) ValidateAll() error {
	return m.validate(true)
}

func (m *LastPrice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LastPriceValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LastPriceValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LastPriceValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LastPriceValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LastPriceValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LastPriceValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstrumentUid

	// no validation rules for LastPriceType

	if len(errors) > 0 {
		return LastPriceMultiError(errors)
	}

	return nil
}

// LastPriceMultiError is an error wrapping multiple validation errors returned
// by LastPrice.ValidateAll() if the designated constraints aren't met.
type LastPriceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LastPriceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LastPriceMultiError) AllErrors() []error { return m }

// LastPriceValidationError is the validation error returned by
// LastPrice.Validate if the designated constraints aren't met.
type LastPriceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LastPriceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LastPriceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LastPriceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LastPriceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LastPriceValidationError) ErrorName() string { return "LastPriceValidationError" }

// Error satisfies the builtin error interface
func (e LastPriceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLastPrice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LastPriceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LastPriceValidationError{}

// Validate checks the field values on GetOrderBookRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrderBookRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderBookRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrderBookRequestMultiError, or nil if none found.
func (m *GetOrderBookRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderBookRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Depth

	if m.Figi != nil {
		// no validation rules for Figi
	}

	if m.InstrumentId != nil {
		// no validation rules for InstrumentId
	}

	if len(errors) > 0 {
		return GetOrderBookRequestMultiError(errors)
	}

	return nil
}

// GetOrderBookRequestMultiError is an error wrapping multiple validation
// errors returned by GetOrderBookRequest.ValidateAll() if the designated
// constraints aren't met.
type GetOrderBookRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderBookRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderBookRequestMultiError) AllErrors() []error { return m }

// GetOrderBookRequestValidationError is the validation error returned by
// GetOrderBookRequest.Validate if the designated constraints aren't met.
type GetOrderBookRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderBookRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderBookRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderBookRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderBookRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderBookRequestValidationError) ErrorName() string {
	return "GetOrderBookRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrderBookRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderBookRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderBookRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderBookRequestValidationError{}

// Validate checks the field values on GetOrderBookResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOrderBookResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOrderBookResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOrderBookResponseMultiError, or nil if none found.
func (m *GetOrderBookResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOrderBookResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Depth

	for idx, item := range m.GetBids() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOrderBookResponseValidationError{
						field:  fmt.Sprintf("Bids[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOrderBookResponseValidationError{
						field:  fmt.Sprintf("Bids[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOrderBookResponseValidationError{
					field:  fmt.Sprintf("Bids[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetAsks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOrderBookResponseValidationError{
						field:  fmt.Sprintf("Asks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOrderBookResponseValidationError{
						field:  fmt.Sprintf("Asks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOrderBookResponseValidationError{
					field:  fmt.Sprintf("Asks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLastPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "LastPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "LastPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderBookResponseValidationError{
				field:  "LastPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClosePrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "ClosePrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "ClosePrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClosePrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderBookResponseValidationError{
				field:  "ClosePrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLimitUp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "LimitUp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "LimitUp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimitUp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderBookResponseValidationError{
				field:  "LimitUp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLimitDown()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "LimitDown",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "LimitDown",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLimitDown()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderBookResponseValidationError{
				field:  "LimitDown",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastPriceTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "LastPriceTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "LastPriceTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastPriceTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderBookResponseValidationError{
				field:  "LastPriceTs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClosePriceTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "ClosePriceTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "ClosePriceTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClosePriceTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderBookResponseValidationError{
				field:  "ClosePriceTs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOrderbookTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "OrderbookTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetOrderBookResponseValidationError{
					field:  "OrderbookTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderbookTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetOrderBookResponseValidationError{
				field:  "OrderbookTs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstrumentUid

	if len(errors) > 0 {
		return GetOrderBookResponseMultiError(errors)
	}

	return nil
}

// GetOrderBookResponseMultiError is an error wrapping multiple validation
// errors returned by GetOrderBookResponse.ValidateAll() if the designated
// constraints aren't met.
type GetOrderBookResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOrderBookResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOrderBookResponseMultiError) AllErrors() []error { return m }

// GetOrderBookResponseValidationError is the validation error returned by
// GetOrderBookResponse.Validate if the designated constraints aren't met.
type GetOrderBookResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOrderBookResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOrderBookResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOrderBookResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOrderBookResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOrderBookResponseValidationError) ErrorName() string {
	return "GetOrderBookResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOrderBookResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOrderBookResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOrderBookResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOrderBookResponseValidationError{}

// Validate checks the field values on GetTradingStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTradingStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTradingStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTradingStatusRequestMultiError, or nil if none found.
func (m *GetTradingStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTradingStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Figi != nil {
		// no validation rules for Figi
	}

	if m.InstrumentId != nil {
		// no validation rules for InstrumentId
	}

	if len(errors) > 0 {
		return GetTradingStatusRequestMultiError(errors)
	}

	return nil
}

// GetTradingStatusRequestMultiError is an error wrapping multiple validation
// errors returned by GetTradingStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTradingStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTradingStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTradingStatusRequestMultiError) AllErrors() []error { return m }

// GetTradingStatusRequestValidationError is the validation error returned by
// GetTradingStatusRequest.Validate if the designated constraints aren't met.
type GetTradingStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTradingStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTradingStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTradingStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTradingStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTradingStatusRequestValidationError) ErrorName() string {
	return "GetTradingStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTradingStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTradingStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTradingStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTradingStatusRequestValidationError{}

// Validate checks the field values on GetTradingStatusesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTradingStatusesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTradingStatusesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTradingStatusesRequestMultiError, or nil if none found.
func (m *GetTradingStatusesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTradingStatusesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetTradingStatusesRequestMultiError(errors)
	}

	return nil
}

// GetTradingStatusesRequestMultiError is an error wrapping multiple validation
// errors returned by GetTradingStatusesRequest.ValidateAll() if the
// designated constraints aren't met.
type GetTradingStatusesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTradingStatusesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTradingStatusesRequestMultiError) AllErrors() []error { return m }

// GetTradingStatusesRequestValidationError is the validation error returned by
// GetTradingStatusesRequest.Validate if the designated constraints aren't met.
type GetTradingStatusesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTradingStatusesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTradingStatusesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTradingStatusesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTradingStatusesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTradingStatusesRequestValidationError) ErrorName() string {
	return "GetTradingStatusesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTradingStatusesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTradingStatusesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTradingStatusesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTradingStatusesRequestValidationError{}

// Validate checks the field values on GetTradingStatusesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTradingStatusesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTradingStatusesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTradingStatusesResponseMultiError, or nil if none found.
func (m *GetTradingStatusesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTradingStatusesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTradingStatuses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTradingStatusesResponseValidationError{
						field:  fmt.Sprintf("TradingStatuses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTradingStatusesResponseValidationError{
						field:  fmt.Sprintf("TradingStatuses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTradingStatusesResponseValidationError{
					field:  fmt.Sprintf("TradingStatuses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTradingStatusesResponseMultiError(errors)
	}

	return nil
}

// GetTradingStatusesResponseMultiError is an error wrapping multiple
// validation errors returned by GetTradingStatusesResponse.ValidateAll() if
// the designated constraints aren't met.
type GetTradingStatusesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTradingStatusesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTradingStatusesResponseMultiError) AllErrors() []error { return m }

// GetTradingStatusesResponseValidationError is the validation error returned
// by GetTradingStatusesResponse.Validate if the designated constraints aren't met.
type GetTradingStatusesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTradingStatusesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTradingStatusesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTradingStatusesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTradingStatusesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTradingStatusesResponseValidationError) ErrorName() string {
	return "GetTradingStatusesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTradingStatusesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTradingStatusesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTradingStatusesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTradingStatusesResponseValidationError{}

// Validate checks the field values on GetTradingStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTradingStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTradingStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTradingStatusResponseMultiError, or nil if none found.
func (m *GetTradingStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTradingStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for TradingStatus

	// no validation rules for LimitOrderAvailableFlag

	// no validation rules for MarketOrderAvailableFlag

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for InstrumentUid

	// no validation rules for BestpriceOrderAvailableFlag

	// no validation rules for OnlyBestPrice

	if len(errors) > 0 {
		return GetTradingStatusResponseMultiError(errors)
	}

	return nil
}

// GetTradingStatusResponseMultiError is an error wrapping multiple validation
// errors returned by GetTradingStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTradingStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTradingStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTradingStatusResponseMultiError) AllErrors() []error { return m }

// GetTradingStatusResponseValidationError is the validation error returned by
// GetTradingStatusResponse.Validate if the designated constraints aren't met.
type GetTradingStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTradingStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTradingStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTradingStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTradingStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTradingStatusResponseValidationError) ErrorName() string {
	return "GetTradingStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTradingStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTradingStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTradingStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTradingStatusResponseValidationError{}

// Validate checks the field values on GetLastTradesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLastTradesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLastTradesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLastTradesRequestMultiError, or nil if none found.
func (m *GetLastTradesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLastTradesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLastTradesRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLastTradesRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLastTradesRequestValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLastTradesRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLastTradesRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLastTradesRequestValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TradeSource

	if m.Figi != nil {
		// no validation rules for Figi
	}

	if m.InstrumentId != nil {
		// no validation rules for InstrumentId
	}

	if len(errors) > 0 {
		return GetLastTradesRequestMultiError(errors)
	}

	return nil
}

// GetLastTradesRequestMultiError is an error wrapping multiple validation
// errors returned by GetLastTradesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetLastTradesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLastTradesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLastTradesRequestMultiError) AllErrors() []error { return m }

// GetLastTradesRequestValidationError is the validation error returned by
// GetLastTradesRequest.Validate if the designated constraints aren't met.
type GetLastTradesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLastTradesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLastTradesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLastTradesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLastTradesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLastTradesRequestValidationError) ErrorName() string {
	return "GetLastTradesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLastTradesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLastTradesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLastTradesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLastTradesRequestValidationError{}

// Validate checks the field values on GetLastTradesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetLastTradesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLastTradesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLastTradesResponseMultiError, or nil if none found.
func (m *GetLastTradesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLastTradesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTrades() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLastTradesResponseValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLastTradesResponseValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLastTradesResponseValidationError{
					field:  fmt.Sprintf("Trades[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetLastTradesResponseMultiError(errors)
	}

	return nil
}

// GetLastTradesResponseMultiError is an error wrapping multiple validation
// errors returned by GetLastTradesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetLastTradesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLastTradesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLastTradesResponseMultiError) AllErrors() []error { return m }

// GetLastTradesResponseValidationError is the validation error returned by
// GetLastTradesResponse.Validate if the designated constraints aren't met.
type GetLastTradesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLastTradesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLastTradesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLastTradesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLastTradesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLastTradesResponseValidationError) ErrorName() string {
	return "GetLastTradesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetLastTradesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLastTradesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLastTradesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLastTradesResponseValidationError{}

// Validate checks the field values on GetMySubscriptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMySubscriptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMySubscriptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMySubscriptionsMultiError, or nil if none found.
func (m *GetMySubscriptions) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMySubscriptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetMySubscriptionsMultiError(errors)
	}

	return nil
}

// GetMySubscriptionsMultiError is an error wrapping multiple validation errors
// returned by GetMySubscriptions.ValidateAll() if the designated constraints
// aren't met.
type GetMySubscriptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMySubscriptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMySubscriptionsMultiError) AllErrors() []error { return m }

// GetMySubscriptionsValidationError is the validation error returned by
// GetMySubscriptions.Validate if the designated constraints aren't met.
type GetMySubscriptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMySubscriptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMySubscriptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMySubscriptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMySubscriptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMySubscriptionsValidationError) ErrorName() string {
	return "GetMySubscriptionsValidationError"
}

// Error satisfies the builtin error interface
func (e GetMySubscriptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMySubscriptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMySubscriptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMySubscriptionsValidationError{}

// Validate checks the field values on GetClosePricesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClosePricesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClosePricesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClosePricesRequestMultiError, or nil if none found.
func (m *GetClosePricesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClosePricesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClosePricesRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClosePricesRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClosePricesRequestValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetClosePricesRequestMultiError(errors)
	}

	return nil
}

// GetClosePricesRequestMultiError is an error wrapping multiple validation
// errors returned by GetClosePricesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetClosePricesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClosePricesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClosePricesRequestMultiError) AllErrors() []error { return m }

// GetClosePricesRequestValidationError is the validation error returned by
// GetClosePricesRequest.Validate if the designated constraints aren't met.
type GetClosePricesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClosePricesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClosePricesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClosePricesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClosePricesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClosePricesRequestValidationError) ErrorName() string {
	return "GetClosePricesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetClosePricesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClosePricesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClosePricesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClosePricesRequestValidationError{}

// Validate checks the field values on InstrumentClosePriceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentClosePriceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentClosePriceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentClosePriceRequestMultiError, or nil if none found.
func (m *InstrumentClosePriceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentClosePriceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	if len(errors) > 0 {
		return InstrumentClosePriceRequestMultiError(errors)
	}

	return nil
}

// InstrumentClosePriceRequestMultiError is an error wrapping multiple
// validation errors returned by InstrumentClosePriceRequest.ValidateAll() if
// the designated constraints aren't met.
type InstrumentClosePriceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentClosePriceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentClosePriceRequestMultiError) AllErrors() []error { return m }

// InstrumentClosePriceRequestValidationError is the validation error returned
// by InstrumentClosePriceRequest.Validate if the designated constraints
// aren't met.
type InstrumentClosePriceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentClosePriceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentClosePriceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentClosePriceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentClosePriceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentClosePriceRequestValidationError) ErrorName() string {
	return "InstrumentClosePriceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentClosePriceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentClosePriceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentClosePriceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentClosePriceRequestValidationError{}

// Validate checks the field values on GetClosePricesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClosePricesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClosePricesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClosePricesResponseMultiError, or nil if none found.
func (m *GetClosePricesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClosePricesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetClosePrices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClosePricesResponseValidationError{
						field:  fmt.Sprintf("ClosePrices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClosePricesResponseValidationError{
						field:  fmt.Sprintf("ClosePrices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClosePricesResponseValidationError{
					field:  fmt.Sprintf("ClosePrices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetClosePricesResponseMultiError(errors)
	}

	return nil
}

// GetClosePricesResponseMultiError is an error wrapping multiple validation
// errors returned by GetClosePricesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetClosePricesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClosePricesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClosePricesResponseMultiError) AllErrors() []error { return m }

// GetClosePricesResponseValidationError is the validation error returned by
// GetClosePricesResponse.Validate if the designated constraints aren't met.
type GetClosePricesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClosePricesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClosePricesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClosePricesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClosePricesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClosePricesResponseValidationError) ErrorName() string {
	return "GetClosePricesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetClosePricesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClosePricesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClosePricesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClosePricesResponseValidationError{}

// Validate checks the field values on InstrumentClosePriceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentClosePriceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentClosePriceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentClosePriceResponseMultiError, or nil if none found.
func (m *InstrumentClosePriceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentClosePriceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for InstrumentUid

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentClosePriceResponseValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentClosePriceResponseValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentClosePriceResponseValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEveningSessionPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentClosePriceResponseValidationError{
					field:  "EveningSessionPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentClosePriceResponseValidationError{
					field:  "EveningSessionPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEveningSessionPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentClosePriceResponseValidationError{
				field:  "EveningSessionPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentClosePriceResponseValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentClosePriceResponseValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentClosePriceResponseValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstrumentClosePriceResponseMultiError(errors)
	}

	return nil
}

// InstrumentClosePriceResponseMultiError is an error wrapping multiple
// validation errors returned by InstrumentClosePriceResponse.ValidateAll() if
// the designated constraints aren't met.
type InstrumentClosePriceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentClosePriceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentClosePriceResponseMultiError) AllErrors() []error { return m }

// InstrumentClosePriceResponseValidationError is the validation error returned
// by InstrumentClosePriceResponse.Validate if the designated constraints
// aren't met.
type InstrumentClosePriceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentClosePriceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentClosePriceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentClosePriceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentClosePriceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentClosePriceResponseValidationError) ErrorName() string {
	return "InstrumentClosePriceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentClosePriceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentClosePriceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentClosePriceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentClosePriceResponseValidationError{}

// Validate checks the field values on GetTechAnalysisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTechAnalysisRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTechAnalysisRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTechAnalysisRequestMultiError, or nil if none found.
func (m *GetTechAnalysisRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTechAnalysisRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IndicatorType

	// no validation rules for InstrumentUid

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTechAnalysisRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTechAnalysisRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTechAnalysisRequestValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTechAnalysisRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTechAnalysisRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTechAnalysisRequestValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Interval

	// no validation rules for TypeOfPrice

	// no validation rules for Length

	if all {
		switch v := interface{}(m.GetDeviation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTechAnalysisRequestValidationError{
					field:  "Deviation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTechAnalysisRequestValidationError{
					field:  "Deviation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeviation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTechAnalysisRequestValidationError{
				field:  "Deviation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSmoothing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTechAnalysisRequestValidationError{
					field:  "Smoothing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTechAnalysisRequestValidationError{
					field:  "Smoothing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSmoothing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTechAnalysisRequestValidationError{
				field:  "Smoothing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTechAnalysisRequestMultiError(errors)
	}

	return nil
}

// GetTechAnalysisRequestMultiError is an error wrapping multiple validation
// errors returned by GetTechAnalysisRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTechAnalysisRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTechAnalysisRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTechAnalysisRequestMultiError) AllErrors() []error { return m }

// GetTechAnalysisRequestValidationError is the validation error returned by
// GetTechAnalysisRequest.Validate if the designated constraints aren't met.
type GetTechAnalysisRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTechAnalysisRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTechAnalysisRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTechAnalysisRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTechAnalysisRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTechAnalysisRequestValidationError) ErrorName() string {
	return "GetTechAnalysisRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTechAnalysisRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTechAnalysisRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTechAnalysisRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTechAnalysisRequestValidationError{}

// Validate checks the field values on GetTechAnalysisResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTechAnalysisResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTechAnalysisResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTechAnalysisResponseMultiError, or nil if none found.
func (m *GetTechAnalysisResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTechAnalysisResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTechnicalIndicators() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTechAnalysisResponseValidationError{
						field:  fmt.Sprintf("TechnicalIndicators[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTechAnalysisResponseValidationError{
						field:  fmt.Sprintf("TechnicalIndicators[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTechAnalysisResponseValidationError{
					field:  fmt.Sprintf("TechnicalIndicators[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTechAnalysisResponseMultiError(errors)
	}

	return nil
}

// GetTechAnalysisResponseMultiError is an error wrapping multiple validation
// errors returned by GetTechAnalysisResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTechAnalysisResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTechAnalysisResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTechAnalysisResponseMultiError) AllErrors() []error { return m }

// GetTechAnalysisResponseValidationError is the validation error returned by
// GetTechAnalysisResponse.Validate if the designated constraints aren't met.
type GetTechAnalysisResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTechAnalysisResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTechAnalysisResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTechAnalysisResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTechAnalysisResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTechAnalysisResponseValidationError) ErrorName() string {
	return "GetTechAnalysisResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTechAnalysisResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTechAnalysisResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTechAnalysisResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTechAnalysisResponseValidationError{}

// Validate checks the field values on GetTechAnalysisRequest_Smoothing with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetTechAnalysisRequest_Smoothing) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTechAnalysisRequest_Smoothing with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTechAnalysisRequest_SmoothingMultiError, or nil if none found.
func (m *GetTechAnalysisRequest_Smoothing) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTechAnalysisRequest_Smoothing) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FastLength

	// no validation rules for SlowLength

	// no validation rules for SignalSmoothing

	if len(errors) > 0 {
		return GetTechAnalysisRequest_SmoothingMultiError(errors)
	}

	return nil
}

// GetTechAnalysisRequest_SmoothingMultiError is an error wrapping multiple
// validation errors returned by
// GetTechAnalysisRequest_Smoothing.ValidateAll() if the designated
// constraints aren't met.
type GetTechAnalysisRequest_SmoothingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTechAnalysisRequest_SmoothingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTechAnalysisRequest_SmoothingMultiError) AllErrors() []error { return m }

// GetTechAnalysisRequest_SmoothingValidationError is the validation error
// returned by GetTechAnalysisRequest_Smoothing.Validate if the designated
// constraints aren't met.
type GetTechAnalysisRequest_SmoothingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTechAnalysisRequest_SmoothingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTechAnalysisRequest_SmoothingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTechAnalysisRequest_SmoothingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTechAnalysisRequest_SmoothingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTechAnalysisRequest_SmoothingValidationError) ErrorName() string {
	return "GetTechAnalysisRequest_SmoothingValidationError"
}

// Error satisfies the builtin error interface
func (e GetTechAnalysisRequest_SmoothingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTechAnalysisRequest_Smoothing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTechAnalysisRequest_SmoothingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTechAnalysisRequest_SmoothingValidationError{}

// Validate checks the field values on GetTechAnalysisRequest_Deviation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetTechAnalysisRequest_Deviation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTechAnalysisRequest_Deviation with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetTechAnalysisRequest_DeviationMultiError, or nil if none found.
func (m *GetTechAnalysisRequest_Deviation) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTechAnalysisRequest_Deviation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeviationMultiplier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTechAnalysisRequest_DeviationValidationError{
					field:  "DeviationMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTechAnalysisRequest_DeviationValidationError{
					field:  "DeviationMultiplier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeviationMultiplier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTechAnalysisRequest_DeviationValidationError{
				field:  "DeviationMultiplier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetTechAnalysisRequest_DeviationMultiError(errors)
	}

	return nil
}

// GetTechAnalysisRequest_DeviationMultiError is an error wrapping multiple
// validation errors returned by
// GetTechAnalysisRequest_Deviation.ValidateAll() if the designated
// constraints aren't met.
type GetTechAnalysisRequest_DeviationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTechAnalysisRequest_DeviationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTechAnalysisRequest_DeviationMultiError) AllErrors() []error { return m }

// GetTechAnalysisRequest_DeviationValidationError is the validation error
// returned by GetTechAnalysisRequest_Deviation.Validate if the designated
// constraints aren't met.
type GetTechAnalysisRequest_DeviationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTechAnalysisRequest_DeviationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTechAnalysisRequest_DeviationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTechAnalysisRequest_DeviationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTechAnalysisRequest_DeviationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTechAnalysisRequest_DeviationValidationError) ErrorName() string {
	return "GetTechAnalysisRequest_DeviationValidationError"
}

// Error satisfies the builtin error interface
func (e GetTechAnalysisRequest_DeviationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTechAnalysisRequest_Deviation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTechAnalysisRequest_DeviationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTechAnalysisRequest_DeviationValidationError{}

// Validate checks the field values on GetTechAnalysisResponse_TechAnalysisItem
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetTechAnalysisResponse_TechAnalysisItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetTechAnalysisResponse_TechAnalysisItem with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetTechAnalysisResponse_TechAnalysisItemMultiError, or nil if none found.
func (m *GetTechAnalysisResponse_TechAnalysisItem) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTechAnalysisResponse_TechAnalysisItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTechAnalysisResponse_TechAnalysisItemValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.MiddleBand != nil {

		if all {
			switch v := interface{}(m.GetMiddleBand()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "MiddleBand",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "MiddleBand",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMiddleBand()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTechAnalysisResponse_TechAnalysisItemValidationError{
					field:  "MiddleBand",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpperBand != nil {

		if all {
			switch v := interface{}(m.GetUpperBand()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "UpperBand",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "UpperBand",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpperBand()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTechAnalysisResponse_TechAnalysisItemValidationError{
					field:  "UpperBand",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.LowerBand != nil {

		if all {
			switch v := interface{}(m.GetLowerBand()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "LowerBand",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "LowerBand",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLowerBand()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTechAnalysisResponse_TechAnalysisItemValidationError{
					field:  "LowerBand",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Signal != nil {

		if all {
			switch v := interface{}(m.GetSignal()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "Signal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "Signal",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSignal()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTechAnalysisResponse_TechAnalysisItemValidationError{
					field:  "Signal",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Macd != nil {

		if all {
			switch v := interface{}(m.GetMacd()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "Macd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetTechAnalysisResponse_TechAnalysisItemValidationError{
						field:  "Macd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMacd()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetTechAnalysisResponse_TechAnalysisItemValidationError{
					field:  "Macd",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetTechAnalysisResponse_TechAnalysisItemMultiError(errors)
	}

	return nil
}

// GetTechAnalysisResponse_TechAnalysisItemMultiError is an error wrapping
// multiple validation errors returned by
// GetTechAnalysisResponse_TechAnalysisItem.ValidateAll() if the designated
// constraints aren't met.
type GetTechAnalysisResponse_TechAnalysisItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTechAnalysisResponse_TechAnalysisItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTechAnalysisResponse_TechAnalysisItemMultiError) AllErrors() []error { return m }

// GetTechAnalysisResponse_TechAnalysisItemValidationError is the validation
// error returned by GetTechAnalysisResponse_TechAnalysisItem.Validate if the
// designated constraints aren't met.
type GetTechAnalysisResponse_TechAnalysisItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTechAnalysisResponse_TechAnalysisItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTechAnalysisResponse_TechAnalysisItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTechAnalysisResponse_TechAnalysisItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTechAnalysisResponse_TechAnalysisItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTechAnalysisResponse_TechAnalysisItemValidationError) ErrorName() string {
	return "GetTechAnalysisResponse_TechAnalysisItemValidationError"
}

// Error satisfies the builtin error interface
func (e GetTechAnalysisResponse_TechAnalysisItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTechAnalysisResponse_TechAnalysisItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTechAnalysisResponse_TechAnalysisItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTechAnalysisResponse_TechAnalysisItemValidationError{}
