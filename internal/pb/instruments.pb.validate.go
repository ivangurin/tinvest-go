// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: instruments.proto

package contractv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on TradingSchedulesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradingSchedulesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradingSchedulesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradingSchedulesRequestMultiError, or nil if none found.
func (m *TradingSchedulesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TradingSchedulesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Exchange != nil {
		// no validation rules for Exchange
	}

	if m.From != nil {

		if all {
			switch v := interface{}(m.GetFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradingSchedulesRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradingSchedulesRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradingSchedulesRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.To != nil {

		if all {
			switch v := interface{}(m.GetTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradingSchedulesRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradingSchedulesRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradingSchedulesRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TradingSchedulesRequestMultiError(errors)
	}

	return nil
}

// TradingSchedulesRequestMultiError is an error wrapping multiple validation
// errors returned by TradingSchedulesRequest.ValidateAll() if the designated
// constraints aren't met.
type TradingSchedulesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradingSchedulesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradingSchedulesRequestMultiError) AllErrors() []error { return m }

// TradingSchedulesRequestValidationError is the validation error returned by
// TradingSchedulesRequest.Validate if the designated constraints aren't met.
type TradingSchedulesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradingSchedulesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradingSchedulesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradingSchedulesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradingSchedulesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradingSchedulesRequestValidationError) ErrorName() string {
	return "TradingSchedulesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TradingSchedulesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradingSchedulesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradingSchedulesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradingSchedulesRequestValidationError{}

// Validate checks the field values on TradingSchedulesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradingSchedulesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradingSchedulesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradingSchedulesResponseMultiError, or nil if none found.
func (m *TradingSchedulesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TradingSchedulesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetExchanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradingSchedulesResponseValidationError{
						field:  fmt.Sprintf("Exchanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradingSchedulesResponseValidationError{
						field:  fmt.Sprintf("Exchanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradingSchedulesResponseValidationError{
					field:  fmt.Sprintf("Exchanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TradingSchedulesResponseMultiError(errors)
	}

	return nil
}

// TradingSchedulesResponseMultiError is an error wrapping multiple validation
// errors returned by TradingSchedulesResponse.ValidateAll() if the designated
// constraints aren't met.
type TradingSchedulesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradingSchedulesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradingSchedulesResponseMultiError) AllErrors() []error { return m }

// TradingSchedulesResponseValidationError is the validation error returned by
// TradingSchedulesResponse.Validate if the designated constraints aren't met.
type TradingSchedulesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradingSchedulesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradingSchedulesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradingSchedulesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradingSchedulesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradingSchedulesResponseValidationError) ErrorName() string {
	return "TradingSchedulesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TradingSchedulesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradingSchedulesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradingSchedulesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradingSchedulesResponseValidationError{}

// Validate checks the field values on TradingSchedule with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TradingSchedule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradingSchedule with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradingScheduleMultiError, or nil if none found.
func (m *TradingSchedule) ValidateAll() error {
	return m.validate(true)
}

func (m *TradingSchedule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Exchange

	for idx, item := range m.GetDays() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradingScheduleValidationError{
						field:  fmt.Sprintf("Days[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradingScheduleValidationError{
						field:  fmt.Sprintf("Days[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradingScheduleValidationError{
					field:  fmt.Sprintf("Days[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TradingScheduleMultiError(errors)
	}

	return nil
}

// TradingScheduleMultiError is an error wrapping multiple validation errors
// returned by TradingSchedule.ValidateAll() if the designated constraints
// aren't met.
type TradingScheduleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradingScheduleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradingScheduleMultiError) AllErrors() []error { return m }

// TradingScheduleValidationError is the validation error returned by
// TradingSchedule.Validate if the designated constraints aren't met.
type TradingScheduleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradingScheduleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradingScheduleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradingScheduleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradingScheduleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradingScheduleValidationError) ErrorName() string { return "TradingScheduleValidationError" }

// Error satisfies the builtin error interface
func (e TradingScheduleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradingSchedule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradingScheduleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradingScheduleValidationError{}

// Validate checks the field values on TradingDay with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TradingDay) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradingDay with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TradingDayMultiError, or
// nil if none found.
func (m *TradingDay) ValidateAll() error {
	return m.validate(true)
}

func (m *TradingDay) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsTradingDay

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpeningAuctionStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "OpeningAuctionStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "OpeningAuctionStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpeningAuctionStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "OpeningAuctionStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClosingAuctionEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "ClosingAuctionEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "ClosingAuctionEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClosingAuctionEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "ClosingAuctionEndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEveningOpeningAuctionStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "EveningOpeningAuctionStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "EveningOpeningAuctionStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEveningOpeningAuctionStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "EveningOpeningAuctionStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEveningStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "EveningStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "EveningStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEveningStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "EveningStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEveningEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "EveningEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "EveningEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEveningEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "EveningEndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClearingStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "ClearingStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "ClearingStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClearingStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "ClearingStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClearingEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "ClearingEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "ClearingEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClearingEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "ClearingEndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPremarketStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "PremarketStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "PremarketStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPremarketStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "PremarketStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPremarketEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "PremarketEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "PremarketEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPremarketEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "PremarketEndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetClosingAuctionStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "ClosingAuctionStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "ClosingAuctionStartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClosingAuctionStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "ClosingAuctionStartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOpeningAuctionEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "OpeningAuctionEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingDayValidationError{
					field:  "OpeningAuctionEndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOpeningAuctionEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingDayValidationError{
				field:  "OpeningAuctionEndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetIntervals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TradingDayValidationError{
						field:  fmt.Sprintf("Intervals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TradingDayValidationError{
						field:  fmt.Sprintf("Intervals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TradingDayValidationError{
					field:  fmt.Sprintf("Intervals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TradingDayMultiError(errors)
	}

	return nil
}

// TradingDayMultiError is an error wrapping multiple validation errors
// returned by TradingDay.ValidateAll() if the designated constraints aren't met.
type TradingDayMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradingDayMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradingDayMultiError) AllErrors() []error { return m }

// TradingDayValidationError is the validation error returned by
// TradingDay.Validate if the designated constraints aren't met.
type TradingDayValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradingDayValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradingDayValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradingDayValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradingDayValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradingDayValidationError) ErrorName() string { return "TradingDayValidationError" }

// Error satisfies the builtin error interface
func (e TradingDayValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradingDay.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradingDayValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradingDayValidationError{}

// Validate checks the field values on InstrumentRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InstrumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentRequestMultiError, or nil if none found.
func (m *InstrumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdType

	// no validation rules for Id

	if m.ClassCode != nil {
		// no validation rules for ClassCode
	}

	if len(errors) > 0 {
		return InstrumentRequestMultiError(errors)
	}

	return nil
}

// InstrumentRequestMultiError is an error wrapping multiple validation errors
// returned by InstrumentRequest.ValidateAll() if the designated constraints
// aren't met.
type InstrumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentRequestMultiError) AllErrors() []error { return m }

// InstrumentRequestValidationError is the validation error returned by
// InstrumentRequest.Validate if the designated constraints aren't met.
type InstrumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentRequestValidationError) ErrorName() string {
	return "InstrumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentRequestValidationError{}

// Validate checks the field values on InstrumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentsRequestMultiError, or nil if none found.
func (m *InstrumentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.InstrumentStatus != nil {
		// no validation rules for InstrumentStatus
	}

	if m.InstrumentExchange != nil {
		// no validation rules for InstrumentExchange
	}

	if len(errors) > 0 {
		return InstrumentsRequestMultiError(errors)
	}

	return nil
}

// InstrumentsRequestMultiError is an error wrapping multiple validation errors
// returned by InstrumentsRequest.ValidateAll() if the designated constraints
// aren't met.
type InstrumentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentsRequestMultiError) AllErrors() []error { return m }

// InstrumentsRequestValidationError is the validation error returned by
// InstrumentsRequest.Validate if the designated constraints aren't met.
type InstrumentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentsRequestValidationError) ErrorName() string {
	return "InstrumentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentsRequestValidationError{}

// Validate checks the field values on FilterOptionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FilterOptionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FilterOptionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FilterOptionsRequestMultiError, or nil if none found.
func (m *FilterOptionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FilterOptionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.BasicAssetUid != nil {
		// no validation rules for BasicAssetUid
	}

	if m.BasicAssetPositionUid != nil {
		// no validation rules for BasicAssetPositionUid
	}

	if len(errors) > 0 {
		return FilterOptionsRequestMultiError(errors)
	}

	return nil
}

// FilterOptionsRequestMultiError is an error wrapping multiple validation
// errors returned by FilterOptionsRequest.ValidateAll() if the designated
// constraints aren't met.
type FilterOptionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FilterOptionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FilterOptionsRequestMultiError) AllErrors() []error { return m }

// FilterOptionsRequestValidationError is the validation error returned by
// FilterOptionsRequest.Validate if the designated constraints aren't met.
type FilterOptionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FilterOptionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FilterOptionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FilterOptionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FilterOptionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FilterOptionsRequestValidationError) ErrorName() string {
	return "FilterOptionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FilterOptionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFilterOptionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FilterOptionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FilterOptionsRequestValidationError{}

// Validate checks the field values on BondResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BondResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BondResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BondResponseMultiError, or
// nil if none found.
func (m *BondResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BondResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondResponseValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BondResponseMultiError(errors)
	}

	return nil
}

// BondResponseMultiError is an error wrapping multiple validation errors
// returned by BondResponse.ValidateAll() if the designated constraints aren't met.
type BondResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BondResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BondResponseMultiError) AllErrors() []error { return m }

// BondResponseValidationError is the validation error returned by
// BondResponse.Validate if the designated constraints aren't met.
type BondResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BondResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BondResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BondResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BondResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BondResponseValidationError) ErrorName() string { return "BondResponseValidationError" }

// Error satisfies the builtin error interface
func (e BondResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBondResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BondResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BondResponseValidationError{}

// Validate checks the field values on BondsResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BondsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BondsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BondsResponseMultiError, or
// nil if none found.
func (m *BondsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BondsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BondsResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BondsResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BondsResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BondsResponseMultiError(errors)
	}

	return nil
}

// BondsResponseMultiError is an error wrapping multiple validation errors
// returned by BondsResponse.ValidateAll() if the designated constraints
// aren't met.
type BondsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BondsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BondsResponseMultiError) AllErrors() []error { return m }

// BondsResponseValidationError is the validation error returned by
// BondsResponse.Validate if the designated constraints aren't met.
type BondsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BondsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BondsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BondsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BondsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BondsResponseValidationError) ErrorName() string { return "BondsResponseValidationError" }

// Error satisfies the builtin error interface
func (e BondsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBondsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BondsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BondsResponseValidationError{}

// Validate checks the field values on GetBondCouponsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBondCouponsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBondCouponsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBondCouponsRequestMultiError, or nil if none found.
func (m *GetBondCouponsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBondCouponsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for InstrumentId

	if m.From != nil {

		if all {
			switch v := interface{}(m.GetFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBondCouponsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBondCouponsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBondCouponsRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.To != nil {

		if all {
			switch v := interface{}(m.GetTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBondCouponsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBondCouponsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBondCouponsRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBondCouponsRequestMultiError(errors)
	}

	return nil
}

// GetBondCouponsRequestMultiError is an error wrapping multiple validation
// errors returned by GetBondCouponsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetBondCouponsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBondCouponsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBondCouponsRequestMultiError) AllErrors() []error { return m }

// GetBondCouponsRequestValidationError is the validation error returned by
// GetBondCouponsRequest.Validate if the designated constraints aren't met.
type GetBondCouponsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBondCouponsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBondCouponsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBondCouponsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBondCouponsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBondCouponsRequestValidationError) ErrorName() string {
	return "GetBondCouponsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBondCouponsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBondCouponsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBondCouponsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBondCouponsRequestValidationError{}

// Validate checks the field values on GetBondCouponsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBondCouponsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBondCouponsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBondCouponsResponseMultiError, or nil if none found.
func (m *GetBondCouponsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBondCouponsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBondCouponsResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBondCouponsResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBondCouponsResponseValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBondCouponsResponseMultiError(errors)
	}

	return nil
}

// GetBondCouponsResponseMultiError is an error wrapping multiple validation
// errors returned by GetBondCouponsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetBondCouponsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBondCouponsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBondCouponsResponseMultiError) AllErrors() []error { return m }

// GetBondCouponsResponseValidationError is the validation error returned by
// GetBondCouponsResponse.Validate if the designated constraints aren't met.
type GetBondCouponsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBondCouponsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBondCouponsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBondCouponsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBondCouponsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBondCouponsResponseValidationError) ErrorName() string {
	return "GetBondCouponsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBondCouponsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBondCouponsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBondCouponsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBondCouponsResponseValidationError{}

// Validate checks the field values on GetBondEventsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBondEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBondEventsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBondEventsRequestMultiError, or nil if none found.
func (m *GetBondEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBondEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for Type

	if m.From != nil {

		if all {
			switch v := interface{}(m.GetFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBondEventsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBondEventsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBondEventsRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.To != nil {

		if all {
			switch v := interface{}(m.GetTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBondEventsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBondEventsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBondEventsRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBondEventsRequestMultiError(errors)
	}

	return nil
}

// GetBondEventsRequestMultiError is an error wrapping multiple validation
// errors returned by GetBondEventsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetBondEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBondEventsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBondEventsRequestMultiError) AllErrors() []error { return m }

// GetBondEventsRequestValidationError is the validation error returned by
// GetBondEventsRequest.Validate if the designated constraints aren't met.
type GetBondEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBondEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBondEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBondEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBondEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBondEventsRequestValidationError) ErrorName() string {
	return "GetBondEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBondEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBondEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBondEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBondEventsRequestValidationError{}

// Validate checks the field values on GetBondEventsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBondEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBondEventsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBondEventsResponseMultiError, or nil if none found.
func (m *GetBondEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBondEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBondEventsResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBondEventsResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBondEventsResponseValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetBondEventsResponseMultiError(errors)
	}

	return nil
}

// GetBondEventsResponseMultiError is an error wrapping multiple validation
// errors returned by GetBondEventsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetBondEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBondEventsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBondEventsResponseMultiError) AllErrors() []error { return m }

// GetBondEventsResponseValidationError is the validation error returned by
// GetBondEventsResponse.Validate if the designated constraints aren't met.
type GetBondEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBondEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBondEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBondEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBondEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBondEventsResponseValidationError) ErrorName() string {
	return "GetBondEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBondEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBondEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBondEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBondEventsResponseValidationError{}

// Validate checks the field values on Coupon with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Coupon) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Coupon with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CouponMultiError, or nil if none found.
func (m *Coupon) ValidateAll() error {
	return m.validate(true)
}

func (m *Coupon) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	if all {
		switch v := interface{}(m.GetCouponDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "CouponDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "CouponDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCouponDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CouponValidationError{
				field:  "CouponDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CouponNumber

	if all {
		switch v := interface{}(m.GetFixDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "FixDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "FixDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFixDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CouponValidationError{
				field:  "FixDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayOneBond()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "PayOneBond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "PayOneBond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayOneBond()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CouponValidationError{
				field:  "PayOneBond",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CouponType

	if all {
		switch v := interface{}(m.GetCouponStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "CouponStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "CouponStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCouponStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CouponValidationError{
				field:  "CouponStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCouponEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "CouponEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CouponValidationError{
					field:  "CouponEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCouponEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CouponValidationError{
				field:  "CouponEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CouponPeriod

	if len(errors) > 0 {
		return CouponMultiError(errors)
	}

	return nil
}

// CouponMultiError is an error wrapping multiple validation errors returned by
// Coupon.ValidateAll() if the designated constraints aren't met.
type CouponMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CouponMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CouponMultiError) AllErrors() []error { return m }

// CouponValidationError is the validation error returned by Coupon.Validate if
// the designated constraints aren't met.
type CouponValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CouponValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CouponValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CouponValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CouponValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CouponValidationError) ErrorName() string { return "CouponValidationError" }

// Error satisfies the builtin error interface
func (e CouponValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCoupon.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CouponValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CouponValidationError{}

// Validate checks the field values on CurrencyResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CurrencyResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CurrencyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CurrencyResponseMultiError, or nil if none found.
func (m *CurrencyResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CurrencyResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyResponseValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CurrencyResponseMultiError(errors)
	}

	return nil
}

// CurrencyResponseMultiError is an error wrapping multiple validation errors
// returned by CurrencyResponse.ValidateAll() if the designated constraints
// aren't met.
type CurrencyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CurrencyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CurrencyResponseMultiError) AllErrors() []error { return m }

// CurrencyResponseValidationError is the validation error returned by
// CurrencyResponse.Validate if the designated constraints aren't met.
type CurrencyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CurrencyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CurrencyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CurrencyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CurrencyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CurrencyResponseValidationError) ErrorName() string { return "CurrencyResponseValidationError" }

// Error satisfies the builtin error interface
func (e CurrencyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurrencyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CurrencyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CurrencyResponseValidationError{}

// Validate checks the field values on CurrenciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CurrenciesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CurrenciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CurrenciesResponseMultiError, or nil if none found.
func (m *CurrenciesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CurrenciesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CurrenciesResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CurrenciesResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CurrenciesResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CurrenciesResponseMultiError(errors)
	}

	return nil
}

// CurrenciesResponseMultiError is an error wrapping multiple validation errors
// returned by CurrenciesResponse.ValidateAll() if the designated constraints
// aren't met.
type CurrenciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CurrenciesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CurrenciesResponseMultiError) AllErrors() []error { return m }

// CurrenciesResponseValidationError is the validation error returned by
// CurrenciesResponse.Validate if the designated constraints aren't met.
type CurrenciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CurrenciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CurrenciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CurrenciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CurrenciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CurrenciesResponseValidationError) ErrorName() string {
	return "CurrenciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CurrenciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurrenciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CurrenciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CurrenciesResponseValidationError{}

// Validate checks the field values on EtfResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EtfResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EtfResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EtfResponseMultiError, or
// nil if none found.
func (m *EtfResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EtfResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfResponseValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EtfResponseMultiError(errors)
	}

	return nil
}

// EtfResponseMultiError is an error wrapping multiple validation errors
// returned by EtfResponse.ValidateAll() if the designated constraints aren't met.
type EtfResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EtfResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EtfResponseMultiError) AllErrors() []error { return m }

// EtfResponseValidationError is the validation error returned by
// EtfResponse.Validate if the designated constraints aren't met.
type EtfResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EtfResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EtfResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EtfResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EtfResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EtfResponseValidationError) ErrorName() string { return "EtfResponseValidationError" }

// Error satisfies the builtin error interface
func (e EtfResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEtfResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EtfResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EtfResponseValidationError{}

// Validate checks the field values on EtfsResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EtfsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EtfsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EtfsResponseMultiError, or
// nil if none found.
func (m *EtfsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EtfsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EtfsResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EtfsResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EtfsResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EtfsResponseMultiError(errors)
	}

	return nil
}

// EtfsResponseMultiError is an error wrapping multiple validation errors
// returned by EtfsResponse.ValidateAll() if the designated constraints aren't met.
type EtfsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EtfsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EtfsResponseMultiError) AllErrors() []error { return m }

// EtfsResponseValidationError is the validation error returned by
// EtfsResponse.Validate if the designated constraints aren't met.
type EtfsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EtfsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EtfsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EtfsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EtfsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EtfsResponseValidationError) ErrorName() string { return "EtfsResponseValidationError" }

// Error satisfies the builtin error interface
func (e EtfsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEtfsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EtfsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EtfsResponseValidationError{}

// Validate checks the field values on FutureResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FutureResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FutureResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FutureResponseMultiError,
// or nil if none found.
func (m *FutureResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FutureResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureResponseValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FutureResponseMultiError(errors)
	}

	return nil
}

// FutureResponseMultiError is an error wrapping multiple validation errors
// returned by FutureResponse.ValidateAll() if the designated constraints
// aren't met.
type FutureResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FutureResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FutureResponseMultiError) AllErrors() []error { return m }

// FutureResponseValidationError is the validation error returned by
// FutureResponse.Validate if the designated constraints aren't met.
type FutureResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FutureResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FutureResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FutureResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FutureResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FutureResponseValidationError) ErrorName() string { return "FutureResponseValidationError" }

// Error satisfies the builtin error interface
func (e FutureResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFutureResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FutureResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FutureResponseValidationError{}

// Validate checks the field values on FuturesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FuturesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FuturesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FuturesResponseMultiError, or nil if none found.
func (m *FuturesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FuturesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FuturesResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FuturesResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FuturesResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FuturesResponseMultiError(errors)
	}

	return nil
}

// FuturesResponseMultiError is an error wrapping multiple validation errors
// returned by FuturesResponse.ValidateAll() if the designated constraints
// aren't met.
type FuturesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FuturesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FuturesResponseMultiError) AllErrors() []error { return m }

// FuturesResponseValidationError is the validation error returned by
// FuturesResponse.Validate if the designated constraints aren't met.
type FuturesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FuturesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FuturesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FuturesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FuturesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FuturesResponseValidationError) ErrorName() string { return "FuturesResponseValidationError" }

// Error satisfies the builtin error interface
func (e FuturesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFuturesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FuturesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FuturesResponseValidationError{}

// Validate checks the field values on OptionResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OptionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OptionResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OptionResponseMultiError,
// or nil if none found.
func (m *OptionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OptionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionResponseValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OptionResponseMultiError(errors)
	}

	return nil
}

// OptionResponseMultiError is an error wrapping multiple validation errors
// returned by OptionResponse.ValidateAll() if the designated constraints
// aren't met.
type OptionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OptionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OptionResponseMultiError) AllErrors() []error { return m }

// OptionResponseValidationError is the validation error returned by
// OptionResponse.Validate if the designated constraints aren't met.
type OptionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OptionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OptionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OptionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OptionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OptionResponseValidationError) ErrorName() string { return "OptionResponseValidationError" }

// Error satisfies the builtin error interface
func (e OptionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOptionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OptionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OptionResponseValidationError{}

// Validate checks the field values on OptionsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OptionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OptionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OptionsResponseMultiError, or nil if none found.
func (m *OptionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OptionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OptionsResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OptionsResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OptionsResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OptionsResponseMultiError(errors)
	}

	return nil
}

// OptionsResponseMultiError is an error wrapping multiple validation errors
// returned by OptionsResponse.ValidateAll() if the designated constraints
// aren't met.
type OptionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OptionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OptionsResponseMultiError) AllErrors() []error { return m }

// OptionsResponseValidationError is the validation error returned by
// OptionsResponse.Validate if the designated constraints aren't met.
type OptionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OptionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OptionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OptionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OptionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OptionsResponseValidationError) ErrorName() string { return "OptionsResponseValidationError" }

// Error satisfies the builtin error interface
func (e OptionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOptionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OptionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OptionsResponseValidationError{}

// Validate checks the field values on Option with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Option) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Option with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OptionMultiError, or nil if none found.
func (m *Option) ValidateAll() error {
	return m.validate(true)
}

func (m *Option) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for PositionUid

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for BasicAssetPositionUid

	// no validation rules for TradingStatus

	// no validation rules for RealExchange

	// no validation rules for Direction

	// no validation rules for PaymentType

	// no validation rules for Style

	// no validation rules for SettlementType

	// no validation rules for Name

	// no validation rules for Currency

	// no validation rules for SettlementCurrency

	// no validation rules for AssetType

	// no validation rules for BasicAsset

	// no validation rules for Exchange

	// no validation rules for CountryOfRisk

	// no validation rules for CountryOfRiskName

	// no validation rules for Sector

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Lot

	if all {
		switch v := interface{}(m.GetBasicAssetSize()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "BasicAssetSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "BasicAssetSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBasicAssetSize()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "BasicAssetSize",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "Klong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "Kshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "Dlong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "Dshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "DlongMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "DshortMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMinPriceIncrement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "MinPriceIncrement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStrikePrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "StrikePrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "StrikePrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStrikePrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "StrikePrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "DlongClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "DshortClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpirationDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "ExpirationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "ExpirationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpirationDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "ExpirationDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirstTradeDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "FirstTradeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "FirstTradeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstTradeDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "FirstTradeDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastTradeDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "LastTradeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "LastTradeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastTradeDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "LastTradeDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1MinCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1MinCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "First_1MinCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1DayCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OptionValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1DayCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OptionValidationError{
				field:  "First_1DayCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShortEnabledFlag

	// no validation rules for ForIisFlag

	// no validation rules for OtcFlag

	// no validation rules for BuyAvailableFlag

	// no validation rules for SellAvailableFlag

	// no validation rules for ForQualInvestorFlag

	// no validation rules for WeekendFlag

	// no validation rules for BlockedTcaFlag

	// no validation rules for ApiTradeAvailableFlag

	if len(errors) > 0 {
		return OptionMultiError(errors)
	}

	return nil
}

// OptionMultiError is an error wrapping multiple validation errors returned by
// Option.ValidateAll() if the designated constraints aren't met.
type OptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OptionMultiError) AllErrors() []error { return m }

// OptionValidationError is the validation error returned by Option.Validate if
// the designated constraints aren't met.
type OptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OptionValidationError) ErrorName() string { return "OptionValidationError" }

// Error satisfies the builtin error interface
func (e OptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OptionValidationError{}

// Validate checks the field values on ShareResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ShareResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShareResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ShareResponseMultiError, or
// nil if none found.
func (m *ShareResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ShareResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareResponseValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ShareResponseMultiError(errors)
	}

	return nil
}

// ShareResponseMultiError is an error wrapping multiple validation errors
// returned by ShareResponse.ValidateAll() if the designated constraints
// aren't met.
type ShareResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShareResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShareResponseMultiError) AllErrors() []error { return m }

// ShareResponseValidationError is the validation error returned by
// ShareResponse.Validate if the designated constraints aren't met.
type ShareResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShareResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShareResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShareResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShareResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShareResponseValidationError) ErrorName() string { return "ShareResponseValidationError" }

// Error satisfies the builtin error interface
func (e ShareResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShareResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShareResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShareResponseValidationError{}

// Validate checks the field values on SharesResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SharesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SharesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SharesResponseMultiError,
// or nil if none found.
func (m *SharesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SharesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SharesResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SharesResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SharesResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SharesResponseMultiError(errors)
	}

	return nil
}

// SharesResponseMultiError is an error wrapping multiple validation errors
// returned by SharesResponse.ValidateAll() if the designated constraints
// aren't met.
type SharesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SharesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SharesResponseMultiError) AllErrors() []error { return m }

// SharesResponseValidationError is the validation error returned by
// SharesResponse.Validate if the designated constraints aren't met.
type SharesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SharesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SharesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SharesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SharesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SharesResponseValidationError) ErrorName() string { return "SharesResponseValidationError" }

// Error satisfies the builtin error interface
func (e SharesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSharesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SharesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SharesResponseValidationError{}

// Validate checks the field values on Bond with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Bond) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Bond with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BondMultiError, or nil if none found.
func (m *Bond) ValidateAll() error {
	return m.validate(true)
}

func (m *Bond) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for Isin

	// no validation rules for Lot

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetKlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "Klong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "Kshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "Dlong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "Dshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "DlongMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "DshortMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShortEnabledFlag

	// no validation rules for Name

	// no validation rules for Exchange

	// no validation rules for CouponQuantityPerYear

	if all {
		switch v := interface{}(m.GetMaturityDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "MaturityDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "MaturityDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaturityDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "MaturityDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInitialNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "InitialNominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "InitialNominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "InitialNominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStateRegDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "StateRegDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "StateRegDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStateRegDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "StateRegDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlacementDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "PlacementDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "PlacementDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlacementDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "PlacementDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlacementPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "PlacementPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "PlacementPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlacementPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "PlacementPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAciValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "AciValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "AciValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAciValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "AciValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CountryOfRisk

	// no validation rules for CountryOfRiskName

	// no validation rules for Sector

	// no validation rules for IssueKind

	// no validation rules for IssueSize

	// no validation rules for IssueSizePlan

	// no validation rules for TradingStatus

	// no validation rules for OtcFlag

	// no validation rules for BuyAvailableFlag

	// no validation rules for SellAvailableFlag

	// no validation rules for FloatingCouponFlag

	// no validation rules for PerpetualFlag

	// no validation rules for AmortizationFlag

	if all {
		switch v := interface{}(m.GetMinPriceIncrement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "MinPriceIncrement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for Uid

	// no validation rules for RealExchange

	// no validation rules for PositionUid

	// no validation rules for AssetUid

	// no validation rules for ForIisFlag

	// no validation rules for ForQualInvestorFlag

	// no validation rules for WeekendFlag

	// no validation rules for BlockedTcaFlag

	// no validation rules for SubordinatedFlag

	// no validation rules for LiquidityFlag

	if all {
		switch v := interface{}(m.GetFirst_1MinCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1MinCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "First_1MinCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1DayCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1DayCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "First_1DayCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RiskLevel

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BondType

	if all {
		switch v := interface{}(m.GetCallDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "CallDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "CallDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCallDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "CallDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "DlongClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BondValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BondValidationError{
				field:  "DshortClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BondMultiError(errors)
	}

	return nil
}

// BondMultiError is an error wrapping multiple validation errors returned by
// Bond.ValidateAll() if the designated constraints aren't met.
type BondMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BondMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BondMultiError) AllErrors() []error { return m }

// BondValidationError is the validation error returned by Bond.Validate if the
// designated constraints aren't met.
type BondValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BondValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BondValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BondValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BondValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BondValidationError) ErrorName() string { return "BondValidationError" }

// Error satisfies the builtin error interface
func (e BondValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBond.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BondValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BondValidationError{}

// Validate checks the field values on Currency with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Currency) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Currency with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CurrencyMultiError, or nil
// if none found.
func (m *Currency) ValidateAll() error {
	return m.validate(true)
}

func (m *Currency) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for Isin

	// no validation rules for Lot

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetKlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "Klong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "Kshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "Dlong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "Dshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "DlongMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "DshortMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShortEnabledFlag

	// no validation rules for Name

	// no validation rules for Exchange

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CountryOfRisk

	// no validation rules for CountryOfRiskName

	// no validation rules for TradingStatus

	// no validation rules for OtcFlag

	// no validation rules for BuyAvailableFlag

	// no validation rules for SellAvailableFlag

	// no validation rules for IsoCurrencyName

	if all {
		switch v := interface{}(m.GetMinPriceIncrement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "MinPriceIncrement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for Uid

	// no validation rules for RealExchange

	// no validation rules for PositionUid

	// no validation rules for ForIisFlag

	// no validation rules for ForQualInvestorFlag

	// no validation rules for WeekendFlag

	// no validation rules for BlockedTcaFlag

	if all {
		switch v := interface{}(m.GetFirst_1MinCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1MinCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "First_1MinCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1DayCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1DayCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "First_1DayCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "DlongClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CurrencyValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CurrencyValidationError{
				field:  "DshortClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CurrencyMultiError(errors)
	}

	return nil
}

// CurrencyMultiError is an error wrapping multiple validation errors returned
// by Currency.ValidateAll() if the designated constraints aren't met.
type CurrencyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CurrencyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CurrencyMultiError) AllErrors() []error { return m }

// CurrencyValidationError is the validation error returned by
// Currency.Validate if the designated constraints aren't met.
type CurrencyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CurrencyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CurrencyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CurrencyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CurrencyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CurrencyValidationError) ErrorName() string { return "CurrencyValidationError" }

// Error satisfies the builtin error interface
func (e CurrencyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurrency.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CurrencyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CurrencyValidationError{}

// Validate checks the field values on Etf with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Etf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Etf with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EtfMultiError, or nil if none found.
func (m *Etf) ValidateAll() error {
	return m.validate(true)
}

func (m *Etf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for Isin

	// no validation rules for Lot

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetKlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "Klong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "Kshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "Dlong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "Dshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "DlongMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "DshortMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShortEnabledFlag

	// no validation rules for Name

	// no validation rules for Exchange

	if all {
		switch v := interface{}(m.GetFixedCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "FixedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "FixedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFixedCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "FixedCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FocusType

	if all {
		switch v := interface{}(m.GetReleasedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "ReleasedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "ReleasedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleasedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "ReleasedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNumShares()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "NumShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "NumShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNumShares()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "NumShares",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CountryOfRisk

	// no validation rules for CountryOfRiskName

	// no validation rules for Sector

	// no validation rules for RebalancingFreq

	// no validation rules for TradingStatus

	// no validation rules for OtcFlag

	// no validation rules for BuyAvailableFlag

	// no validation rules for SellAvailableFlag

	if all {
		switch v := interface{}(m.GetMinPriceIncrement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "MinPriceIncrement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for Uid

	// no validation rules for RealExchange

	// no validation rules for PositionUid

	// no validation rules for AssetUid

	// no validation rules for InstrumentExchange

	// no validation rules for ForIisFlag

	// no validation rules for ForQualInvestorFlag

	// no validation rules for WeekendFlag

	// no validation rules for BlockedTcaFlag

	// no validation rules for LiquidityFlag

	if all {
		switch v := interface{}(m.GetFirst_1MinCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1MinCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "First_1MinCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1DayCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1DayCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "First_1DayCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "DlongClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EtfValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EtfValidationError{
				field:  "DshortClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EtfMultiError(errors)
	}

	return nil
}

// EtfMultiError is an error wrapping multiple validation errors returned by
// Etf.ValidateAll() if the designated constraints aren't met.
type EtfMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EtfMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EtfMultiError) AllErrors() []error { return m }

// EtfValidationError is the validation error returned by Etf.Validate if the
// designated constraints aren't met.
type EtfValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EtfValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EtfValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EtfValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EtfValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EtfValidationError) ErrorName() string { return "EtfValidationError" }

// Error satisfies the builtin error interface
func (e EtfValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEtf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EtfValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EtfValidationError{}

// Validate checks the field values on Future with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Future) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Future with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FutureMultiError, or nil if none found.
func (m *Future) ValidateAll() error {
	return m.validate(true)
}

func (m *Future) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for Lot

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetKlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "Klong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "Kshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "Dlong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "Dshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "DlongMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "DshortMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShortEnabledFlag

	// no validation rules for Name

	// no validation rules for Exchange

	if all {
		switch v := interface{}(m.GetFirstTradeDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "FirstTradeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "FirstTradeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstTradeDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "FirstTradeDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastTradeDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "LastTradeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "LastTradeDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastTradeDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "LastTradeDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FuturesType

	// no validation rules for AssetType

	// no validation rules for BasicAsset

	if all {
		switch v := interface{}(m.GetBasicAssetSize()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "BasicAssetSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "BasicAssetSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBasicAssetSize()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "BasicAssetSize",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CountryOfRisk

	// no validation rules for CountryOfRiskName

	// no validation rules for Sector

	if all {
		switch v := interface{}(m.GetExpirationDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "ExpirationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "ExpirationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpirationDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "ExpirationDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TradingStatus

	// no validation rules for OtcFlag

	// no validation rules for BuyAvailableFlag

	// no validation rules for SellAvailableFlag

	if all {
		switch v := interface{}(m.GetMinPriceIncrement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "MinPriceIncrement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for Uid

	// no validation rules for RealExchange

	// no validation rules for PositionUid

	// no validation rules for BasicAssetPositionUid

	// no validation rules for ForIisFlag

	// no validation rules for ForQualInvestorFlag

	// no validation rules for WeekendFlag

	// no validation rules for BlockedTcaFlag

	if all {
		switch v := interface{}(m.GetFirst_1MinCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1MinCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "First_1MinCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1DayCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1DayCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "First_1DayCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInitialMarginOnBuy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "InitialMarginOnBuy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "InitialMarginOnBuy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialMarginOnBuy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "InitialMarginOnBuy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInitialMarginOnSell()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "InitialMarginOnSell",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "InitialMarginOnSell",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialMarginOnSell()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "InitialMarginOnSell",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMinPriceIncrementAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "MinPriceIncrementAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "MinPriceIncrementAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrementAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "MinPriceIncrementAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "DlongClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FutureValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FutureValidationError{
				field:  "DshortClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FutureMultiError(errors)
	}

	return nil
}

// FutureMultiError is an error wrapping multiple validation errors returned by
// Future.ValidateAll() if the designated constraints aren't met.
type FutureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FutureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FutureMultiError) AllErrors() []error { return m }

// FutureValidationError is the validation error returned by Future.Validate if
// the designated constraints aren't met.
type FutureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FutureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FutureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FutureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FutureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FutureValidationError) ErrorName() string { return "FutureValidationError" }

// Error satisfies the builtin error interface
func (e FutureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFuture.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FutureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FutureValidationError{}

// Validate checks the field values on Share with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Share) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Share with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ShareMultiError, or nil if none found.
func (m *Share) ValidateAll() error {
	return m.validate(true)
}

func (m *Share) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for Isin

	// no validation rules for Lot

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetKlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "Klong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "Kshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "Dlong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "Dshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "DlongMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "DshortMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShortEnabledFlag

	// no validation rules for Name

	// no validation rules for Exchange

	if all {
		switch v := interface{}(m.GetIpoDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "IpoDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "IpoDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpoDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "IpoDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IssueSize

	// no validation rules for CountryOfRisk

	// no validation rules for CountryOfRiskName

	// no validation rules for Sector

	// no validation rules for IssueSizePlan

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TradingStatus

	// no validation rules for OtcFlag

	// no validation rules for BuyAvailableFlag

	// no validation rules for SellAvailableFlag

	// no validation rules for DivYieldFlag

	// no validation rules for ShareType

	if all {
		switch v := interface{}(m.GetMinPriceIncrement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "MinPriceIncrement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for Uid

	// no validation rules for RealExchange

	// no validation rules for PositionUid

	// no validation rules for AssetUid

	// no validation rules for InstrumentExchange

	// no validation rules for ForIisFlag

	// no validation rules for ForQualInvestorFlag

	// no validation rules for WeekendFlag

	// no validation rules for BlockedTcaFlag

	// no validation rules for LiquidityFlag

	if all {
		switch v := interface{}(m.GetFirst_1MinCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1MinCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "First_1MinCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1DayCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1DayCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "First_1DayCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "DlongClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShareValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShareValidationError{
				field:  "DshortClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ShareMultiError(errors)
	}

	return nil
}

// ShareMultiError is an error wrapping multiple validation errors returned by
// Share.ValidateAll() if the designated constraints aren't met.
type ShareMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShareMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShareMultiError) AllErrors() []error { return m }

// ShareValidationError is the validation error returned by Share.Validate if
// the designated constraints aren't met.
type ShareValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShareValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShareValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShareValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShareValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShareValidationError) ErrorName() string { return "ShareValidationError" }

// Error satisfies the builtin error interface
func (e ShareValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShare.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShareValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShareValidationError{}

// Validate checks the field values on GetAccruedInterestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccruedInterestsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccruedInterestsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccruedInterestsRequestMultiError, or nil if none found.
func (m *GetAccruedInterestsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccruedInterestsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAccruedInterestsRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAccruedInterestsRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAccruedInterestsRequestValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAccruedInterestsRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAccruedInterestsRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAccruedInterestsRequestValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InstrumentId

	if len(errors) > 0 {
		return GetAccruedInterestsRequestMultiError(errors)
	}

	return nil
}

// GetAccruedInterestsRequestMultiError is an error wrapping multiple
// validation errors returned by GetAccruedInterestsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetAccruedInterestsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccruedInterestsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccruedInterestsRequestMultiError) AllErrors() []error { return m }

// GetAccruedInterestsRequestValidationError is the validation error returned
// by GetAccruedInterestsRequest.Validate if the designated constraints aren't met.
type GetAccruedInterestsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccruedInterestsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccruedInterestsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccruedInterestsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccruedInterestsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccruedInterestsRequestValidationError) ErrorName() string {
	return "GetAccruedInterestsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccruedInterestsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccruedInterestsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccruedInterestsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccruedInterestsRequestValidationError{}

// Validate checks the field values on GetAccruedInterestsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAccruedInterestsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAccruedInterestsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAccruedInterestsResponseMultiError, or nil if none found.
func (m *GetAccruedInterestsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAccruedInterestsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccruedInterests() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAccruedInterestsResponseValidationError{
						field:  fmt.Sprintf("AccruedInterests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAccruedInterestsResponseValidationError{
						field:  fmt.Sprintf("AccruedInterests[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAccruedInterestsResponseValidationError{
					field:  fmt.Sprintf("AccruedInterests[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAccruedInterestsResponseMultiError(errors)
	}

	return nil
}

// GetAccruedInterestsResponseMultiError is an error wrapping multiple
// validation errors returned by GetAccruedInterestsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAccruedInterestsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAccruedInterestsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAccruedInterestsResponseMultiError) AllErrors() []error { return m }

// GetAccruedInterestsResponseValidationError is the validation error returned
// by GetAccruedInterestsResponse.Validate if the designated constraints
// aren't met.
type GetAccruedInterestsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAccruedInterestsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAccruedInterestsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAccruedInterestsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAccruedInterestsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAccruedInterestsResponseValidationError) ErrorName() string {
	return "GetAccruedInterestsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAccruedInterestsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAccruedInterestsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAccruedInterestsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAccruedInterestsResponseValidationError{}

// Validate checks the field values on AccruedInterest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AccruedInterest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccruedInterest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccruedInterestMultiError, or nil if none found.
func (m *AccruedInterest) ValidateAll() error {
	return m.validate(true)
}

func (m *AccruedInterest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccruedInterestValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccruedInterestValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccruedInterestValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccruedInterestValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccruedInterestValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccruedInterestValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetValuePercent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccruedInterestValidationError{
					field:  "ValuePercent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccruedInterestValidationError{
					field:  "ValuePercent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValuePercent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccruedInterestValidationError{
				field:  "ValuePercent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AccruedInterestValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AccruedInterestValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AccruedInterestValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AccruedInterestMultiError(errors)
	}

	return nil
}

// AccruedInterestMultiError is an error wrapping multiple validation errors
// returned by AccruedInterest.ValidateAll() if the designated constraints
// aren't met.
type AccruedInterestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccruedInterestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccruedInterestMultiError) AllErrors() []error { return m }

// AccruedInterestValidationError is the validation error returned by
// AccruedInterest.Validate if the designated constraints aren't met.
type AccruedInterestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccruedInterestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccruedInterestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccruedInterestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccruedInterestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccruedInterestValidationError) ErrorName() string { return "AccruedInterestValidationError" }

// Error satisfies the builtin error interface
func (e AccruedInterestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccruedInterest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccruedInterestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccruedInterestValidationError{}

// Validate checks the field values on GetFuturesMarginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFuturesMarginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFuturesMarginRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFuturesMarginRequestMultiError, or nil if none found.
func (m *GetFuturesMarginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFuturesMarginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for InstrumentId

	if len(errors) > 0 {
		return GetFuturesMarginRequestMultiError(errors)
	}

	return nil
}

// GetFuturesMarginRequestMultiError is an error wrapping multiple validation
// errors returned by GetFuturesMarginRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFuturesMarginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFuturesMarginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFuturesMarginRequestMultiError) AllErrors() []error { return m }

// GetFuturesMarginRequestValidationError is the validation error returned by
// GetFuturesMarginRequest.Validate if the designated constraints aren't met.
type GetFuturesMarginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFuturesMarginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFuturesMarginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFuturesMarginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFuturesMarginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFuturesMarginRequestValidationError) ErrorName() string {
	return "GetFuturesMarginRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFuturesMarginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFuturesMarginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFuturesMarginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFuturesMarginRequestValidationError{}

// Validate checks the field values on GetFuturesMarginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFuturesMarginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFuturesMarginResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFuturesMarginResponseMultiError, or nil if none found.
func (m *GetFuturesMarginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFuturesMarginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInitialMarginOnBuy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFuturesMarginResponseValidationError{
					field:  "InitialMarginOnBuy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFuturesMarginResponseValidationError{
					field:  "InitialMarginOnBuy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialMarginOnBuy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFuturesMarginResponseValidationError{
				field:  "InitialMarginOnBuy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInitialMarginOnSell()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFuturesMarginResponseValidationError{
					field:  "InitialMarginOnSell",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFuturesMarginResponseValidationError{
					field:  "InitialMarginOnSell",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInitialMarginOnSell()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFuturesMarginResponseValidationError{
				field:  "InitialMarginOnSell",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMinPriceIncrement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFuturesMarginResponseValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFuturesMarginResponseValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFuturesMarginResponseValidationError{
				field:  "MinPriceIncrement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMinPriceIncrementAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFuturesMarginResponseValidationError{
					field:  "MinPriceIncrementAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFuturesMarginResponseValidationError{
					field:  "MinPriceIncrementAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrementAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFuturesMarginResponseValidationError{
				field:  "MinPriceIncrementAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetFuturesMarginResponseMultiError(errors)
	}

	return nil
}

// GetFuturesMarginResponseMultiError is an error wrapping multiple validation
// errors returned by GetFuturesMarginResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFuturesMarginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFuturesMarginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFuturesMarginResponseMultiError) AllErrors() []error { return m }

// GetFuturesMarginResponseValidationError is the validation error returned by
// GetFuturesMarginResponse.Validate if the designated constraints aren't met.
type GetFuturesMarginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFuturesMarginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFuturesMarginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFuturesMarginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFuturesMarginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFuturesMarginResponseValidationError) ErrorName() string {
	return "GetFuturesMarginResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFuturesMarginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFuturesMarginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFuturesMarginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFuturesMarginResponseValidationError{}

// Validate checks the field values on InstrumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstrumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentResponseMultiError, or nil if none found.
func (m *InstrumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInstrument()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentResponseValidationError{
					field:  "Instrument",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInstrument()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentResponseValidationError{
				field:  "Instrument",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstrumentResponseMultiError(errors)
	}

	return nil
}

// InstrumentResponseMultiError is an error wrapping multiple validation errors
// returned by InstrumentResponse.ValidateAll() if the designated constraints
// aren't met.
type InstrumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentResponseMultiError) AllErrors() []error { return m }

// InstrumentResponseValidationError is the validation error returned by
// InstrumentResponse.Validate if the designated constraints aren't met.
type InstrumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentResponseValidationError) ErrorName() string {
	return "InstrumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstrumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentResponseValidationError{}

// Validate checks the field values on Instrument with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Instrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Instrument with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstrumentMultiError, or
// nil if none found.
func (m *Instrument) ValidateAll() error {
	return m.validate(true)
}

func (m *Instrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for Isin

	// no validation rules for Lot

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetKlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Klong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "Klong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Kshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "Kshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlong()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Dlong",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlong()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "Dlong",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshort()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Dshort",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshort()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "Dshort",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "DlongMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "DlongMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortMin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "DshortMin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortMin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "DshortMin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShortEnabledFlag

	// no validation rules for Name

	// no validation rules for Exchange

	// no validation rules for CountryOfRisk

	// no validation rules for CountryOfRiskName

	// no validation rules for InstrumentType

	// no validation rules for TradingStatus

	// no validation rules for OtcFlag

	// no validation rules for BuyAvailableFlag

	// no validation rules for SellAvailableFlag

	if all {
		switch v := interface{}(m.GetMinPriceIncrement()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "MinPriceIncrement",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinPriceIncrement()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "MinPriceIncrement",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for Uid

	// no validation rules for RealExchange

	// no validation rules for PositionUid

	// no validation rules for AssetUid

	// no validation rules for ForIisFlag

	// no validation rules for ForQualInvestorFlag

	// no validation rules for WeekendFlag

	// no validation rules for BlockedTcaFlag

	// no validation rules for InstrumentKind

	if all {
		switch v := interface{}(m.GetFirst_1MinCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1MinCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "First_1MinCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1DayCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1DayCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "First_1DayCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDlongClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "DlongClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDlongClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "DlongClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDshortClient()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentValidationError{
					field:  "DshortClient",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDshortClient()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentValidationError{
				field:  "DshortClient",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InstrumentMultiError(errors)
	}

	return nil
}

// InstrumentMultiError is an error wrapping multiple validation errors
// returned by Instrument.ValidateAll() if the designated constraints aren't met.
type InstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentMultiError) AllErrors() []error { return m }

// InstrumentValidationError is the validation error returned by
// Instrument.Validate if the designated constraints aren't met.
type InstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentValidationError) ErrorName() string { return "InstrumentValidationError" }

// Error satisfies the builtin error interface
func (e InstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentValidationError{}

// Validate checks the field values on GetDividendsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDividendsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDividendsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDividendsRequestMultiError, or nil if none found.
func (m *GetDividendsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDividendsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for InstrumentId

	if m.From != nil {

		if all {
			switch v := interface{}(m.GetFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDividendsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDividendsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDividendsRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.To != nil {

		if all {
			switch v := interface{}(m.GetTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDividendsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDividendsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDividendsRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetDividendsRequestMultiError(errors)
	}

	return nil
}

// GetDividendsRequestMultiError is an error wrapping multiple validation
// errors returned by GetDividendsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDividendsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDividendsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDividendsRequestMultiError) AllErrors() []error { return m }

// GetDividendsRequestValidationError is the validation error returned by
// GetDividendsRequest.Validate if the designated constraints aren't met.
type GetDividendsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDividendsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDividendsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDividendsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDividendsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDividendsRequestValidationError) ErrorName() string {
	return "GetDividendsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDividendsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDividendsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDividendsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDividendsRequestValidationError{}

// Validate checks the field values on GetDividendsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDividendsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDividendsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDividendsResponseMultiError, or nil if none found.
func (m *GetDividendsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDividendsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDividends() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDividendsResponseValidationError{
						field:  fmt.Sprintf("Dividends[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDividendsResponseValidationError{
						field:  fmt.Sprintf("Dividends[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDividendsResponseValidationError{
					field:  fmt.Sprintf("Dividends[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetDividendsResponseMultiError(errors)
	}

	return nil
}

// GetDividendsResponseMultiError is an error wrapping multiple validation
// errors returned by GetDividendsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDividendsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDividendsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDividendsResponseMultiError) AllErrors() []error { return m }

// GetDividendsResponseValidationError is the validation error returned by
// GetDividendsResponse.Validate if the designated constraints aren't met.
type GetDividendsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDividendsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDividendsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDividendsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDividendsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDividendsResponseValidationError) ErrorName() string {
	return "GetDividendsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDividendsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDividendsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDividendsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDividendsResponseValidationError{}

// Validate checks the field values on Dividend with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Dividend) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Dividend with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DividendMultiError, or nil
// if none found.
func (m *Dividend) ValidateAll() error {
	return m.validate(true)
}

func (m *Dividend) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDividendNet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "DividendNet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "DividendNet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDividendNet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendValidationError{
				field:  "DividendNet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaymentDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "PaymentDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "PaymentDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendValidationError{
				field:  "PaymentDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeclaredDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "DeclaredDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "DeclaredDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeclaredDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendValidationError{
				field:  "DeclaredDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastBuyDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "LastBuyDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "LastBuyDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastBuyDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendValidationError{
				field:  "LastBuyDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DividendType

	if all {
		switch v := interface{}(m.GetRecordDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "RecordDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "RecordDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecordDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendValidationError{
				field:  "RecordDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Regularity

	if all {
		switch v := interface{}(m.GetClosePrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "ClosePrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "ClosePrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClosePrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendValidationError{
				field:  "ClosePrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetYieldValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "YieldValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "YieldValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetYieldValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendValidationError{
				field:  "YieldValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DividendMultiError(errors)
	}

	return nil
}

// DividendMultiError is an error wrapping multiple validation errors returned
// by Dividend.ValidateAll() if the designated constraints aren't met.
type DividendMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DividendMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DividendMultiError) AllErrors() []error { return m }

// DividendValidationError is the validation error returned by
// Dividend.Validate if the designated constraints aren't met.
type DividendValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DividendValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DividendValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DividendValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DividendValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DividendValidationError) ErrorName() string { return "DividendValidationError" }

// Error satisfies the builtin error interface
func (e DividendValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDividend.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DividendValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DividendValidationError{}

// Validate checks the field values on AssetRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetRequestMultiError, or
// nil if none found.
func (m *AssetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return AssetRequestMultiError(errors)
	}

	return nil
}

// AssetRequestMultiError is an error wrapping multiple validation errors
// returned by AssetRequest.ValidateAll() if the designated constraints aren't met.
type AssetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetRequestMultiError) AllErrors() []error { return m }

// AssetRequestValidationError is the validation error returned by
// AssetRequest.Validate if the designated constraints aren't met.
type AssetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetRequestValidationError) ErrorName() string { return "AssetRequestValidationError" }

// Error satisfies the builtin error interface
func (e AssetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetRequestValidationError{}

// Validate checks the field values on AssetResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetResponseMultiError, or
// nil if none found.
func (m *AssetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAsset()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetResponseValidationError{
					field:  "Asset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetResponseValidationError{
					field:  "Asset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAsset()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetResponseValidationError{
				field:  "Asset",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AssetResponseMultiError(errors)
	}

	return nil
}

// AssetResponseMultiError is an error wrapping multiple validation errors
// returned by AssetResponse.ValidateAll() if the designated constraints
// aren't met.
type AssetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetResponseMultiError) AllErrors() []error { return m }

// AssetResponseValidationError is the validation error returned by
// AssetResponse.Validate if the designated constraints aren't met.
type AssetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetResponseValidationError) ErrorName() string { return "AssetResponseValidationError" }

// Error satisfies the builtin error interface
func (e AssetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetResponseValidationError{}

// Validate checks the field values on AssetsRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetsRequestMultiError, or
// nil if none found.
func (m *AssetsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.InstrumentType != nil {
		// no validation rules for InstrumentType
	}

	if m.InstrumentStatus != nil {
		// no validation rules for InstrumentStatus
	}

	if len(errors) > 0 {
		return AssetsRequestMultiError(errors)
	}

	return nil
}

// AssetsRequestMultiError is an error wrapping multiple validation errors
// returned by AssetsRequest.ValidateAll() if the designated constraints
// aren't met.
type AssetsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetsRequestMultiError) AllErrors() []error { return m }

// AssetsRequestValidationError is the validation error returned by
// AssetsRequest.Validate if the designated constraints aren't met.
type AssetsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetsRequestValidationError) ErrorName() string { return "AssetsRequestValidationError" }

// Error satisfies the builtin error interface
func (e AssetsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetsRequestValidationError{}

// Validate checks the field values on AssetsResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetsResponseMultiError,
// or nil if none found.
func (m *AssetsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAssets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetsResponseValidationError{
						field:  fmt.Sprintf("Assets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetsResponseValidationError{
						field:  fmt.Sprintf("Assets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetsResponseValidationError{
					field:  fmt.Sprintf("Assets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AssetsResponseMultiError(errors)
	}

	return nil
}

// AssetsResponseMultiError is an error wrapping multiple validation errors
// returned by AssetsResponse.ValidateAll() if the designated constraints
// aren't met.
type AssetsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetsResponseMultiError) AllErrors() []error { return m }

// AssetsResponseValidationError is the validation error returned by
// AssetsResponse.Validate if the designated constraints aren't met.
type AssetsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetsResponseValidationError) ErrorName() string { return "AssetsResponseValidationError" }

// Error satisfies the builtin error interface
func (e AssetsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetsResponseValidationError{}

// Validate checks the field values on AssetFull with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetFull) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetFull with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetFullMultiError, or nil
// if none found.
func (m *AssetFull) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetFull) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Type

	// no validation rules for Name

	// no validation rules for NameBrief

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetDeletedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetFullValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetFullValidationError{
					field:  "DeletedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeletedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetFullValidationError{
				field:  "DeletedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GosRegCode

	// no validation rules for Cfi

	// no validation rules for CodeNsd

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetBrand()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetFullValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetFullValidationError{
					field:  "Brand",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrand()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetFullValidationError{
				field:  "Brand",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetFullValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetFullValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetFullValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BrCode

	// no validation rules for BrCodeName

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetFullValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetFullValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetFullValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Ext.(type) {
	case *AssetFull_Currency:
		if v == nil {
			err := AssetFullValidationError{
				field:  "Ext",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCurrency()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetFullValidationError{
						field:  "Currency",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetFullValidationError{
						field:  "Currency",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCurrency()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetFullValidationError{
					field:  "Currency",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AssetFull_Security:
		if v == nil {
			err := AssetFullValidationError{
				field:  "Ext",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSecurity()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetFullValidationError{
						field:  "Security",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetFullValidationError{
						field:  "Security",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSecurity()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetFullValidationError{
					field:  "Security",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AssetFullMultiError(errors)
	}

	return nil
}

// AssetFullMultiError is an error wrapping multiple validation errors returned
// by AssetFull.ValidateAll() if the designated constraints aren't met.
type AssetFullMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetFullMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetFullMultiError) AllErrors() []error { return m }

// AssetFullValidationError is the validation error returned by
// AssetFull.Validate if the designated constraints aren't met.
type AssetFullValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetFullValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetFullValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetFullValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetFullValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetFullValidationError) ErrorName() string { return "AssetFullValidationError" }

// Error satisfies the builtin error interface
func (e AssetFullValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetFull.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetFullValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetFullValidationError{}

// Validate checks the field values on Asset with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Asset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Asset with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AssetMultiError, or nil if none found.
func (m *Asset) ValidateAll() error {
	return m.validate(true)
}

func (m *Asset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Type

	// no validation rules for Name

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AssetMultiError(errors)
	}

	return nil
}

// AssetMultiError is an error wrapping multiple validation errors returned by
// Asset.ValidateAll() if the designated constraints aren't met.
type AssetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetMultiError) AllErrors() []error { return m }

// AssetValidationError is the validation error returned by Asset.Validate if
// the designated constraints aren't met.
type AssetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetValidationError) ErrorName() string { return "AssetValidationError" }

// Error satisfies the builtin error interface
func (e AssetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetValidationError{}

// Validate checks the field values on AssetCurrency with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetCurrency) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetCurrency with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetCurrencyMultiError, or
// nil if none found.
func (m *AssetCurrency) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetCurrency) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BaseCurrency

	if len(errors) > 0 {
		return AssetCurrencyMultiError(errors)
	}

	return nil
}

// AssetCurrencyMultiError is an error wrapping multiple validation errors
// returned by AssetCurrency.ValidateAll() if the designated constraints
// aren't met.
type AssetCurrencyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetCurrencyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetCurrencyMultiError) AllErrors() []error { return m }

// AssetCurrencyValidationError is the validation error returned by
// AssetCurrency.Validate if the designated constraints aren't met.
type AssetCurrencyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetCurrencyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetCurrencyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetCurrencyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetCurrencyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetCurrencyValidationError) ErrorName() string { return "AssetCurrencyValidationError" }

// Error satisfies the builtin error interface
func (e AssetCurrencyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetCurrency.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetCurrencyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetCurrencyValidationError{}

// Validate checks the field values on AssetSecurity with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetSecurity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetSecurity with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetSecurityMultiError, or
// nil if none found.
func (m *AssetSecurity) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetSecurity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Isin

	// no validation rules for Type

	// no validation rules for InstrumentKind

	switch v := m.Ext.(type) {
	case *AssetSecurity_Share:
		if v == nil {
			err := AssetSecurityValidationError{
				field:  "Ext",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetShare()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "Share",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "Share",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetShare()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSecurityValidationError{
					field:  "Share",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AssetSecurity_Bond:
		if v == nil {
			err := AssetSecurityValidationError{
				field:  "Ext",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBond()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "Bond",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "Bond",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBond()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSecurityValidationError{
					field:  "Bond",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AssetSecurity_Sp:
		if v == nil {
			err := AssetSecurityValidationError{
				field:  "Ext",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "Sp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "Sp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSecurityValidationError{
					field:  "Sp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AssetSecurity_Etf:
		if v == nil {
			err := AssetSecurityValidationError{
				field:  "Ext",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEtf()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "Etf",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "Etf",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEtf()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSecurityValidationError{
					field:  "Etf",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AssetSecurity_ClearingCertificate:
		if v == nil {
			err := AssetSecurityValidationError{
				field:  "Ext",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetClearingCertificate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "ClearingCertificate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetSecurityValidationError{
						field:  "ClearingCertificate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetClearingCertificate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetSecurityValidationError{
					field:  "ClearingCertificate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AssetSecurityMultiError(errors)
	}

	return nil
}

// AssetSecurityMultiError is an error wrapping multiple validation errors
// returned by AssetSecurity.ValidateAll() if the designated constraints
// aren't met.
type AssetSecurityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetSecurityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetSecurityMultiError) AllErrors() []error { return m }

// AssetSecurityValidationError is the validation error returned by
// AssetSecurity.Validate if the designated constraints aren't met.
type AssetSecurityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetSecurityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetSecurityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetSecurityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetSecurityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetSecurityValidationError) ErrorName() string { return "AssetSecurityValidationError" }

// Error satisfies the builtin error interface
func (e AssetSecurityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetSecurity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetSecurityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetSecurityValidationError{}

// Validate checks the field values on AssetShare with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetShare) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetShare with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetShareMultiError, or
// nil if none found.
func (m *AssetShare) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetShare) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetIssueSize()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "IssueSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "IssueSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueSize()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetShareValidationError{
				field:  "IssueSize",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetShareValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NominalCurrency

	// no validation rules for PrimaryIndex

	if all {
		switch v := interface{}(m.GetDividendRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "DividendRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "DividendRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDividendRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetShareValidationError{
				field:  "DividendRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PreferredShareType

	if all {
		switch v := interface{}(m.GetIpoDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "IpoDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "IpoDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpoDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetShareValidationError{
				field:  "IpoDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRegistryDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "RegistryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "RegistryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRegistryDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetShareValidationError{
				field:  "RegistryDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DivYieldFlag

	// no validation rules for IssueKind

	if all {
		switch v := interface{}(m.GetPlacementDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "PlacementDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "PlacementDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlacementDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetShareValidationError{
				field:  "PlacementDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RepresIsin

	if all {
		switch v := interface{}(m.GetIssueSizePlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "IssueSizePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "IssueSizePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueSizePlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetShareValidationError{
				field:  "IssueSizePlan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalFloat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "TotalFloat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetShareValidationError{
					field:  "TotalFloat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalFloat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetShareValidationError{
				field:  "TotalFloat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AssetShareMultiError(errors)
	}

	return nil
}

// AssetShareMultiError is an error wrapping multiple validation errors
// returned by AssetShare.ValidateAll() if the designated constraints aren't met.
type AssetShareMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetShareMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetShareMultiError) AllErrors() []error { return m }

// AssetShareValidationError is the validation error returned by
// AssetShare.Validate if the designated constraints aren't met.
type AssetShareValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetShareValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetShareValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetShareValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetShareValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetShareValidationError) ErrorName() string { return "AssetShareValidationError" }

// Error satisfies the builtin error interface
func (e AssetShareValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetShare.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetShareValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetShareValidationError{}

// Validate checks the field values on AssetBond with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetBond) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetBond with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetBondMultiError, or nil
// if none found.
func (m *AssetBond) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetBond) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCurrentNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "CurrentNominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "CurrentNominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetBondValidationError{
				field:  "CurrentNominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BorrowName

	if all {
		switch v := interface{}(m.GetIssueSize()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "IssueSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "IssueSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueSize()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetBondValidationError{
				field:  "IssueSize",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetBondValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NominalCurrency

	// no validation rules for IssueKind

	// no validation rules for InterestKind

	// no validation rules for CouponQuantityPerYear

	// no validation rules for IndexedNominalFlag

	// no validation rules for SubordinatedFlag

	// no validation rules for CollateralFlag

	// no validation rules for TaxFreeFlag

	// no validation rules for AmortizationFlag

	// no validation rules for FloatingCouponFlag

	// no validation rules for PerpetualFlag

	if all {
		switch v := interface{}(m.GetMaturityDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "MaturityDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "MaturityDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaturityDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetBondValidationError{
				field:  "MaturityDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReturnCondition

	if all {
		switch v := interface{}(m.GetStateRegDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "StateRegDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "StateRegDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStateRegDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetBondValidationError{
				field:  "StateRegDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlacementDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "PlacementDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "PlacementDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlacementDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetBondValidationError{
				field:  "PlacementDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlacementPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "PlacementPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "PlacementPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlacementPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetBondValidationError{
				field:  "PlacementPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIssueSizePlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "IssueSizePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetBondValidationError{
					field:  "IssueSizePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueSizePlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetBondValidationError{
				field:  "IssueSizePlan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AssetBondMultiError(errors)
	}

	return nil
}

// AssetBondMultiError is an error wrapping multiple validation errors returned
// by AssetBond.ValidateAll() if the designated constraints aren't met.
type AssetBondMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetBondMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetBondMultiError) AllErrors() []error { return m }

// AssetBondValidationError is the validation error returned by
// AssetBond.Validate if the designated constraints aren't met.
type AssetBondValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetBondValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetBondValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetBondValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetBondValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetBondValidationError) ErrorName() string { return "AssetBondValidationError" }

// Error satisfies the builtin error interface
func (e AssetBondValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetBond.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetBondValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetBondValidationError{}

// Validate checks the field values on AssetStructuredProduct with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssetStructuredProduct) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetStructuredProduct with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssetStructuredProductMultiError, or nil if none found.
func (m *AssetStructuredProduct) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetStructuredProduct) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BorrowName

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetStructuredProductValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NominalCurrency

	// no validation rules for Type

	// no validation rules for LogicPortfolio

	// no validation rules for AssetType

	// no validation rules for BasicAsset

	if all {
		switch v := interface{}(m.GetSafetyBarrier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "SafetyBarrier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "SafetyBarrier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSafetyBarrier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetStructuredProductValidationError{
				field:  "SafetyBarrier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaturityDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "MaturityDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "MaturityDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaturityDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetStructuredProductValidationError{
				field:  "MaturityDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIssueSizePlan()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "IssueSizePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "IssueSizePlan",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueSizePlan()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetStructuredProductValidationError{
				field:  "IssueSizePlan",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIssueSize()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "IssueSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "IssueSize",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueSize()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetStructuredProductValidationError{
				field:  "IssueSize",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlacementDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "PlacementDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetStructuredProductValidationError{
					field:  "PlacementDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlacementDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetStructuredProductValidationError{
				field:  "PlacementDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IssueKind

	if len(errors) > 0 {
		return AssetStructuredProductMultiError(errors)
	}

	return nil
}

// AssetStructuredProductMultiError is an error wrapping multiple validation
// errors returned by AssetStructuredProduct.ValidateAll() if the designated
// constraints aren't met.
type AssetStructuredProductMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetStructuredProductMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetStructuredProductMultiError) AllErrors() []error { return m }

// AssetStructuredProductValidationError is the validation error returned by
// AssetStructuredProduct.Validate if the designated constraints aren't met.
type AssetStructuredProductValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetStructuredProductValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetStructuredProductValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetStructuredProductValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetStructuredProductValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetStructuredProductValidationError) ErrorName() string {
	return "AssetStructuredProductValidationError"
}

// Error satisfies the builtin error interface
func (e AssetStructuredProductValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetStructuredProduct.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetStructuredProductValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetStructuredProductValidationError{}

// Validate checks the field values on AssetEtf with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AssetEtf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetEtf with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AssetEtfMultiError, or nil
// if none found.
func (m *AssetEtf) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetEtf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTotalExpense()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "TotalExpense",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "TotalExpense",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalExpense()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "TotalExpense",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHurdleRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "HurdleRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "HurdleRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHurdleRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "HurdleRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPerformanceFee()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "PerformanceFee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "PerformanceFee",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerformanceFee()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "PerformanceFee",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFixedCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "FixedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "FixedCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFixedCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "FixedCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PaymentType

	// no validation rules for WatermarkFlag

	if all {
		switch v := interface{}(m.GetBuyPremium()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "BuyPremium",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "BuyPremium",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBuyPremium()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "BuyPremium",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSellDiscount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "SellDiscount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "SellDiscount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSellDiscount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "SellDiscount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RebalancingFlag

	// no validation rules for RebalancingFreq

	// no validation rules for ManagementType

	// no validation rules for PrimaryIndex

	// no validation rules for FocusType

	// no validation rules for LeveragedFlag

	if all {
		switch v := interface{}(m.GetNumShare()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "NumShare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "NumShare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNumShare()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "NumShare",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UcitsFlag

	if all {
		switch v := interface{}(m.GetReleasedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "ReleasedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "ReleasedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReleasedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "ReleasedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for PrimaryIndexDescription

	// no validation rules for PrimaryIndexCompany

	if all {
		switch v := interface{}(m.GetIndexRecoveryPeriod()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "IndexRecoveryPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "IndexRecoveryPeriod",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIndexRecoveryPeriod()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "IndexRecoveryPeriod",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InavCode

	// no validation rules for DivYieldFlag

	if all {
		switch v := interface{}(m.GetExpenseCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "ExpenseCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "ExpenseCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpenseCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "ExpenseCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrimaryIndexTrackingError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "PrimaryIndexTrackingError",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "PrimaryIndexTrackingError",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrimaryIndexTrackingError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "PrimaryIndexTrackingError",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RebalancingPlan

	// no validation rules for TaxRate

	for idx, item := range m.GetRebalancingDates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetEtfValidationError{
						field:  fmt.Sprintf("RebalancingDates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetEtfValidationError{
						field:  fmt.Sprintf("RebalancingDates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetEtfValidationError{
					field:  fmt.Sprintf("RebalancingDates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IssueKind

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetEtfValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetEtfValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NominalCurrency

	if len(errors) > 0 {
		return AssetEtfMultiError(errors)
	}

	return nil
}

// AssetEtfMultiError is an error wrapping multiple validation errors returned
// by AssetEtf.ValidateAll() if the designated constraints aren't met.
type AssetEtfMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetEtfMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetEtfMultiError) AllErrors() []error { return m }

// AssetEtfValidationError is the validation error returned by
// AssetEtf.Validate if the designated constraints aren't met.
type AssetEtfValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetEtfValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetEtfValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetEtfValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetEtfValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetEtfValidationError) ErrorName() string { return "AssetEtfValidationError" }

// Error satisfies the builtin error interface
func (e AssetEtfValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetEtf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetEtfValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetEtfValidationError{}

// Validate checks the field values on AssetClearingCertificate with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AssetClearingCertificate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetClearingCertificate with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssetClearingCertificateMultiError, or nil if none found.
func (m *AssetClearingCertificate) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetClearingCertificate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNominal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AssetClearingCertificateValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AssetClearingCertificateValidationError{
					field:  "Nominal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNominal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AssetClearingCertificateValidationError{
				field:  "Nominal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NominalCurrency

	if len(errors) > 0 {
		return AssetClearingCertificateMultiError(errors)
	}

	return nil
}

// AssetClearingCertificateMultiError is an error wrapping multiple validation
// errors returned by AssetClearingCertificate.ValidateAll() if the designated
// constraints aren't met.
type AssetClearingCertificateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetClearingCertificateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetClearingCertificateMultiError) AllErrors() []error { return m }

// AssetClearingCertificateValidationError is the validation error returned by
// AssetClearingCertificate.Validate if the designated constraints aren't met.
type AssetClearingCertificateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetClearingCertificateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetClearingCertificateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetClearingCertificateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetClearingCertificateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetClearingCertificateValidationError) ErrorName() string {
	return "AssetClearingCertificateValidationError"
}

// Error satisfies the builtin error interface
func (e AssetClearingCertificateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetClearingCertificate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetClearingCertificateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetClearingCertificateValidationError{}

// Validate checks the field values on Brand with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Brand) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Brand with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BrandMultiError, or nil if none found.
func (m *Brand) ValidateAll() error {
	return m.validate(true)
}

func (m *Brand) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Name

	// no validation rules for Description

	// no validation rules for Info

	// no validation rules for Company

	// no validation rules for Sector

	// no validation rules for CountryOfRisk

	// no validation rules for CountryOfRiskName

	if len(errors) > 0 {
		return BrandMultiError(errors)
	}

	return nil
}

// BrandMultiError is an error wrapping multiple validation errors returned by
// Brand.ValidateAll() if the designated constraints aren't met.
type BrandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BrandMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BrandMultiError) AllErrors() []error { return m }

// BrandValidationError is the validation error returned by Brand.Validate if
// the designated constraints aren't met.
type BrandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BrandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BrandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BrandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BrandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BrandValidationError) ErrorName() string { return "BrandValidationError" }

// Error satisfies the builtin error interface
func (e BrandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBrand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BrandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BrandValidationError{}

// Validate checks the field values on AssetInstrument with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AssetInstrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AssetInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AssetInstrumentMultiError, or nil if none found.
func (m *AssetInstrument) ValidateAll() error {
	return m.validate(true)
}

func (m *AssetInstrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Figi

	// no validation rules for InstrumentType

	// no validation rules for Ticker

	// no validation rules for ClassCode

	for idx, item := range m.GetLinks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AssetInstrumentValidationError{
						field:  fmt.Sprintf("Links[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AssetInstrumentValidationError{
						field:  fmt.Sprintf("Links[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AssetInstrumentValidationError{
					field:  fmt.Sprintf("Links[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for InstrumentKind

	// no validation rules for PositionUid

	if len(errors) > 0 {
		return AssetInstrumentMultiError(errors)
	}

	return nil
}

// AssetInstrumentMultiError is an error wrapping multiple validation errors
// returned by AssetInstrument.ValidateAll() if the designated constraints
// aren't met.
type AssetInstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AssetInstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AssetInstrumentMultiError) AllErrors() []error { return m }

// AssetInstrumentValidationError is the validation error returned by
// AssetInstrument.Validate if the designated constraints aren't met.
type AssetInstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AssetInstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AssetInstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AssetInstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AssetInstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AssetInstrumentValidationError) ErrorName() string { return "AssetInstrumentValidationError" }

// Error satisfies the builtin error interface
func (e AssetInstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAssetInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AssetInstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AssetInstrumentValidationError{}

// Validate checks the field values on InstrumentLink with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InstrumentLink) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentLink with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InstrumentLinkMultiError,
// or nil if none found.
func (m *InstrumentLink) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentLink) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for InstrumentUid

	if len(errors) > 0 {
		return InstrumentLinkMultiError(errors)
	}

	return nil
}

// InstrumentLinkMultiError is an error wrapping multiple validation errors
// returned by InstrumentLink.ValidateAll() if the designated constraints
// aren't met.
type InstrumentLinkMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentLinkMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentLinkMultiError) AllErrors() []error { return m }

// InstrumentLinkValidationError is the validation error returned by
// InstrumentLink.Validate if the designated constraints aren't met.
type InstrumentLinkValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentLinkValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentLinkValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentLinkValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentLinkValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentLinkValidationError) ErrorName() string { return "InstrumentLinkValidationError" }

// Error satisfies the builtin error interface
func (e InstrumentLinkValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentLink.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentLinkValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentLinkValidationError{}

// Validate checks the field values on GetFavoritesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFavoritesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFavoritesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFavoritesRequestMultiError, or nil if none found.
func (m *GetFavoritesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFavoritesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetFavoritesRequestMultiError(errors)
	}

	return nil
}

// GetFavoritesRequestMultiError is an error wrapping multiple validation
// errors returned by GetFavoritesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFavoritesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFavoritesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFavoritesRequestMultiError) AllErrors() []error { return m }

// GetFavoritesRequestValidationError is the validation error returned by
// GetFavoritesRequest.Validate if the designated constraints aren't met.
type GetFavoritesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFavoritesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFavoritesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFavoritesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFavoritesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFavoritesRequestValidationError) ErrorName() string {
	return "GetFavoritesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFavoritesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFavoritesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFavoritesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFavoritesRequestValidationError{}

// Validate checks the field values on GetFavoritesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFavoritesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFavoritesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFavoritesResponseMultiError, or nil if none found.
func (m *GetFavoritesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFavoritesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFavoriteInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetFavoritesResponseValidationError{
						field:  fmt.Sprintf("FavoriteInstruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetFavoritesResponseValidationError{
						field:  fmt.Sprintf("FavoriteInstruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetFavoritesResponseValidationError{
					field:  fmt.Sprintf("FavoriteInstruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetFavoritesResponseMultiError(errors)
	}

	return nil
}

// GetFavoritesResponseMultiError is an error wrapping multiple validation
// errors returned by GetFavoritesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFavoritesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFavoritesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFavoritesResponseMultiError) AllErrors() []error { return m }

// GetFavoritesResponseValidationError is the validation error returned by
// GetFavoritesResponse.Validate if the designated constraints aren't met.
type GetFavoritesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFavoritesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFavoritesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFavoritesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFavoritesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFavoritesResponseValidationError) ErrorName() string {
	return "GetFavoritesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFavoritesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFavoritesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFavoritesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFavoritesResponseValidationError{}

// Validate checks the field values on FavoriteInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FavoriteInstrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FavoriteInstrument with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FavoriteInstrumentMultiError, or nil if none found.
func (m *FavoriteInstrument) ValidateAll() error {
	return m.validate(true)
}

func (m *FavoriteInstrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for Isin

	// no validation rules for InstrumentType

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for OtcFlag

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for InstrumentKind

	if len(errors) > 0 {
		return FavoriteInstrumentMultiError(errors)
	}

	return nil
}

// FavoriteInstrumentMultiError is an error wrapping multiple validation errors
// returned by FavoriteInstrument.ValidateAll() if the designated constraints
// aren't met.
type FavoriteInstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FavoriteInstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FavoriteInstrumentMultiError) AllErrors() []error { return m }

// FavoriteInstrumentValidationError is the validation error returned by
// FavoriteInstrument.Validate if the designated constraints aren't met.
type FavoriteInstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FavoriteInstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FavoriteInstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FavoriteInstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FavoriteInstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FavoriteInstrumentValidationError) ErrorName() string {
	return "FavoriteInstrumentValidationError"
}

// Error satisfies the builtin error interface
func (e FavoriteInstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFavoriteInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FavoriteInstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FavoriteInstrumentValidationError{}

// Validate checks the field values on EditFavoritesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditFavoritesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditFavoritesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditFavoritesRequestMultiError, or nil if none found.
func (m *EditFavoritesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EditFavoritesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EditFavoritesRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EditFavoritesRequestValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EditFavoritesRequestValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ActionType

	if len(errors) > 0 {
		return EditFavoritesRequestMultiError(errors)
	}

	return nil
}

// EditFavoritesRequestMultiError is an error wrapping multiple validation
// errors returned by EditFavoritesRequest.ValidateAll() if the designated
// constraints aren't met.
type EditFavoritesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditFavoritesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditFavoritesRequestMultiError) AllErrors() []error { return m }

// EditFavoritesRequestValidationError is the validation error returned by
// EditFavoritesRequest.Validate if the designated constraints aren't met.
type EditFavoritesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditFavoritesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditFavoritesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditFavoritesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditFavoritesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditFavoritesRequestValidationError) ErrorName() string {
	return "EditFavoritesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e EditFavoritesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditFavoritesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditFavoritesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditFavoritesRequestValidationError{}

// Validate checks the field values on EditFavoritesRequestInstrument with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditFavoritesRequestInstrument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditFavoritesRequestInstrument with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EditFavoritesRequestInstrumentMultiError, or nil if none found.
func (m *EditFavoritesRequestInstrument) ValidateAll() error {
	return m.validate(true)
}

func (m *EditFavoritesRequestInstrument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	if m.Figi != nil {
		// no validation rules for Figi
	}

	if len(errors) > 0 {
		return EditFavoritesRequestInstrumentMultiError(errors)
	}

	return nil
}

// EditFavoritesRequestInstrumentMultiError is an error wrapping multiple
// validation errors returned by EditFavoritesRequestInstrument.ValidateAll()
// if the designated constraints aren't met.
type EditFavoritesRequestInstrumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditFavoritesRequestInstrumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditFavoritesRequestInstrumentMultiError) AllErrors() []error { return m }

// EditFavoritesRequestInstrumentValidationError is the validation error
// returned by EditFavoritesRequestInstrument.Validate if the designated
// constraints aren't met.
type EditFavoritesRequestInstrumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditFavoritesRequestInstrumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditFavoritesRequestInstrumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditFavoritesRequestInstrumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditFavoritesRequestInstrumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditFavoritesRequestInstrumentValidationError) ErrorName() string {
	return "EditFavoritesRequestInstrumentValidationError"
}

// Error satisfies the builtin error interface
func (e EditFavoritesRequestInstrumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditFavoritesRequestInstrument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditFavoritesRequestInstrumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditFavoritesRequestInstrumentValidationError{}

// Validate checks the field values on EditFavoritesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EditFavoritesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EditFavoritesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EditFavoritesResponseMultiError, or nil if none found.
func (m *EditFavoritesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EditFavoritesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFavoriteInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EditFavoritesResponseValidationError{
						field:  fmt.Sprintf("FavoriteInstruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EditFavoritesResponseValidationError{
						field:  fmt.Sprintf("FavoriteInstruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EditFavoritesResponseValidationError{
					field:  fmt.Sprintf("FavoriteInstruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EditFavoritesResponseMultiError(errors)
	}

	return nil
}

// EditFavoritesResponseMultiError is an error wrapping multiple validation
// errors returned by EditFavoritesResponse.ValidateAll() if the designated
// constraints aren't met.
type EditFavoritesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EditFavoritesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EditFavoritesResponseMultiError) AllErrors() []error { return m }

// EditFavoritesResponseValidationError is the validation error returned by
// EditFavoritesResponse.Validate if the designated constraints aren't met.
type EditFavoritesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EditFavoritesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EditFavoritesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EditFavoritesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EditFavoritesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EditFavoritesResponseValidationError) ErrorName() string {
	return "EditFavoritesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e EditFavoritesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEditFavoritesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EditFavoritesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EditFavoritesResponseValidationError{}

// Validate checks the field values on GetCountriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCountriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCountriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCountriesRequestMultiError, or nil if none found.
func (m *GetCountriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCountriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetCountriesRequestMultiError(errors)
	}

	return nil
}

// GetCountriesRequestMultiError is an error wrapping multiple validation
// errors returned by GetCountriesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCountriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCountriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCountriesRequestMultiError) AllErrors() []error { return m }

// GetCountriesRequestValidationError is the validation error returned by
// GetCountriesRequest.Validate if the designated constraints aren't met.
type GetCountriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCountriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCountriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCountriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCountriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCountriesRequestValidationError) ErrorName() string {
	return "GetCountriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCountriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCountriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCountriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCountriesRequestValidationError{}

// Validate checks the field values on GetCountriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCountriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCountriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCountriesResponseMultiError, or nil if none found.
func (m *GetCountriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCountriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCountries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetCountriesResponseValidationError{
						field:  fmt.Sprintf("Countries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetCountriesResponseValidationError{
						field:  fmt.Sprintf("Countries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetCountriesResponseValidationError{
					field:  fmt.Sprintf("Countries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetCountriesResponseMultiError(errors)
	}

	return nil
}

// GetCountriesResponseMultiError is an error wrapping multiple validation
// errors returned by GetCountriesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCountriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCountriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCountriesResponseMultiError) AllErrors() []error { return m }

// GetCountriesResponseValidationError is the validation error returned by
// GetCountriesResponse.Validate if the designated constraints aren't met.
type GetCountriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCountriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCountriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCountriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCountriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCountriesResponseValidationError) ErrorName() string {
	return "GetCountriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCountriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCountriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCountriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCountriesResponseValidationError{}

// Validate checks the field values on IndicativesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IndicativesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndicativesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IndicativesRequestMultiError, or nil if none found.
func (m *IndicativesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicativesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return IndicativesRequestMultiError(errors)
	}

	return nil
}

// IndicativesRequestMultiError is an error wrapping multiple validation errors
// returned by IndicativesRequest.ValidateAll() if the designated constraints
// aren't met.
type IndicativesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicativesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicativesRequestMultiError) AllErrors() []error { return m }

// IndicativesRequestValidationError is the validation error returned by
// IndicativesRequest.Validate if the designated constraints aren't met.
type IndicativesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicativesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndicativesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndicativesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndicativesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicativesRequestValidationError) ErrorName() string {
	return "IndicativesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IndicativesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicativesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicativesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicativesRequestValidationError{}

// Validate checks the field values on IndicativesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IndicativesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndicativesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IndicativesResponseMultiError, or nil if none found.
func (m *IndicativesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicativesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, IndicativesResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, IndicativesResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return IndicativesResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return IndicativesResponseMultiError(errors)
	}

	return nil
}

// IndicativesResponseMultiError is an error wrapping multiple validation
// errors returned by IndicativesResponse.ValidateAll() if the designated
// constraints aren't met.
type IndicativesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicativesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicativesResponseMultiError) AllErrors() []error { return m }

// IndicativesResponseValidationError is the validation error returned by
// IndicativesResponse.Validate if the designated constraints aren't met.
type IndicativesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicativesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndicativesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndicativesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndicativesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicativesResponseValidationError) ErrorName() string {
	return "IndicativesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IndicativesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicativesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicativesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicativesResponseValidationError{}

// Validate checks the field values on IndicativeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IndicativeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IndicativeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IndicativeResponseMultiError, or nil if none found.
func (m *IndicativeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *IndicativeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for Currency

	// no validation rules for InstrumentKind

	// no validation rules for Name

	// no validation rules for Exchange

	// no validation rules for Uid

	// no validation rules for BuyAvailableFlag

	// no validation rules for SellAvailableFlag

	if len(errors) > 0 {
		return IndicativeResponseMultiError(errors)
	}

	return nil
}

// IndicativeResponseMultiError is an error wrapping multiple validation errors
// returned by IndicativeResponse.ValidateAll() if the designated constraints
// aren't met.
type IndicativeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IndicativeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IndicativeResponseMultiError) AllErrors() []error { return m }

// IndicativeResponseValidationError is the validation error returned by
// IndicativeResponse.Validate if the designated constraints aren't met.
type IndicativeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IndicativeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IndicativeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IndicativeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IndicativeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IndicativeResponseValidationError) ErrorName() string {
	return "IndicativeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IndicativeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIndicativeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IndicativeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IndicativeResponseValidationError{}

// Validate checks the field values on CountryResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CountryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CountryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CountryResponseMultiError, or nil if none found.
func (m *CountryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CountryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AlfaTwo

	// no validation rules for AlfaThree

	// no validation rules for Name

	// no validation rules for NameBrief

	if len(errors) > 0 {
		return CountryResponseMultiError(errors)
	}

	return nil
}

// CountryResponseMultiError is an error wrapping multiple validation errors
// returned by CountryResponse.ValidateAll() if the designated constraints
// aren't met.
type CountryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CountryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CountryResponseMultiError) AllErrors() []error { return m }

// CountryResponseValidationError is the validation error returned by
// CountryResponse.Validate if the designated constraints aren't met.
type CountryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CountryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CountryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CountryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CountryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CountryResponseValidationError) ErrorName() string { return "CountryResponseValidationError" }

// Error satisfies the builtin error interface
func (e CountryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCountryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CountryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CountryResponseValidationError{}

// Validate checks the field values on FindInstrumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FindInstrumentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FindInstrumentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FindInstrumentRequestMultiError, or nil if none found.
func (m *FindInstrumentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FindInstrumentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Query

	if m.InstrumentKind != nil {
		// no validation rules for InstrumentKind
	}

	if m.ApiTradeAvailableFlag != nil {
		// no validation rules for ApiTradeAvailableFlag
	}

	if len(errors) > 0 {
		return FindInstrumentRequestMultiError(errors)
	}

	return nil
}

// FindInstrumentRequestMultiError is an error wrapping multiple validation
// errors returned by FindInstrumentRequest.ValidateAll() if the designated
// constraints aren't met.
type FindInstrumentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FindInstrumentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FindInstrumentRequestMultiError) AllErrors() []error { return m }

// FindInstrumentRequestValidationError is the validation error returned by
// FindInstrumentRequest.Validate if the designated constraints aren't met.
type FindInstrumentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FindInstrumentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FindInstrumentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FindInstrumentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FindInstrumentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FindInstrumentRequestValidationError) ErrorName() string {
	return "FindInstrumentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FindInstrumentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFindInstrumentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FindInstrumentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FindInstrumentRequestValidationError{}

// Validate checks the field values on FindInstrumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FindInstrumentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FindInstrumentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FindInstrumentResponseMultiError, or nil if none found.
func (m *FindInstrumentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FindInstrumentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInstruments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FindInstrumentResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FindInstrumentResponseValidationError{
						field:  fmt.Sprintf("Instruments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FindInstrumentResponseValidationError{
					field:  fmt.Sprintf("Instruments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FindInstrumentResponseMultiError(errors)
	}

	return nil
}

// FindInstrumentResponseMultiError is an error wrapping multiple validation
// errors returned by FindInstrumentResponse.ValidateAll() if the designated
// constraints aren't met.
type FindInstrumentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FindInstrumentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FindInstrumentResponseMultiError) AllErrors() []error { return m }

// FindInstrumentResponseValidationError is the validation error returned by
// FindInstrumentResponse.Validate if the designated constraints aren't met.
type FindInstrumentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FindInstrumentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FindInstrumentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FindInstrumentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FindInstrumentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FindInstrumentResponseValidationError) ErrorName() string {
	return "FindInstrumentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FindInstrumentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFindInstrumentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FindInstrumentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FindInstrumentResponseValidationError{}

// Validate checks the field values on InstrumentShort with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InstrumentShort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstrumentShort with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstrumentShortMultiError, or nil if none found.
func (m *InstrumentShort) ValidateAll() error {
	return m.validate(true)
}

func (m *InstrumentShort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Isin

	// no validation rules for Figi

	// no validation rules for Ticker

	// no validation rules for ClassCode

	// no validation rules for InstrumentType

	// no validation rules for Name

	// no validation rules for Uid

	// no validation rules for PositionUid

	// no validation rules for InstrumentKind

	// no validation rules for ApiTradeAvailableFlag

	// no validation rules for ForIisFlag

	if all {
		switch v := interface{}(m.GetFirst_1MinCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentShortValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentShortValidationError{
					field:  "First_1MinCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1MinCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentShortValidationError{
				field:  "First_1MinCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirst_1DayCandleDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstrumentShortValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstrumentShortValidationError{
					field:  "First_1DayCandleDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirst_1DayCandleDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstrumentShortValidationError{
				field:  "First_1DayCandleDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ForQualInvestorFlag

	// no validation rules for WeekendFlag

	// no validation rules for BlockedTcaFlag

	// no validation rules for Lot

	if len(errors) > 0 {
		return InstrumentShortMultiError(errors)
	}

	return nil
}

// InstrumentShortMultiError is an error wrapping multiple validation errors
// returned by InstrumentShort.ValidateAll() if the designated constraints
// aren't met.
type InstrumentShortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstrumentShortMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstrumentShortMultiError) AllErrors() []error { return m }

// InstrumentShortValidationError is the validation error returned by
// InstrumentShort.Validate if the designated constraints aren't met.
type InstrumentShortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstrumentShortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstrumentShortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstrumentShortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstrumentShortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstrumentShortValidationError) ErrorName() string { return "InstrumentShortValidationError" }

// Error satisfies the builtin error interface
func (e InstrumentShortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstrumentShort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstrumentShortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstrumentShortValidationError{}

// Validate checks the field values on GetBrandsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBrandsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBrandsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBrandsRequestMultiError, or nil if none found.
func (m *GetBrandsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBrandsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPaging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBrandsRequestValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBrandsRequestValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBrandsRequestValidationError{
				field:  "Paging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBrandsRequestMultiError(errors)
	}

	return nil
}

// GetBrandsRequestMultiError is an error wrapping multiple validation errors
// returned by GetBrandsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetBrandsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBrandsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBrandsRequestMultiError) AllErrors() []error { return m }

// GetBrandsRequestValidationError is the validation error returned by
// GetBrandsRequest.Validate if the designated constraints aren't met.
type GetBrandsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBrandsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBrandsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBrandsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBrandsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBrandsRequestValidationError) ErrorName() string { return "GetBrandsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetBrandsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBrandsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBrandsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBrandsRequestValidationError{}

// Validate checks the field values on GetBrandRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBrandRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBrandRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBrandRequestMultiError, or nil if none found.
func (m *GetBrandRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBrandRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return GetBrandRequestMultiError(errors)
	}

	return nil
}

// GetBrandRequestMultiError is an error wrapping multiple validation errors
// returned by GetBrandRequest.ValidateAll() if the designated constraints
// aren't met.
type GetBrandRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBrandRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBrandRequestMultiError) AllErrors() []error { return m }

// GetBrandRequestValidationError is the validation error returned by
// GetBrandRequest.Validate if the designated constraints aren't met.
type GetBrandRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBrandRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBrandRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBrandRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBrandRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBrandRequestValidationError) ErrorName() string { return "GetBrandRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetBrandRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBrandRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBrandRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBrandRequestValidationError{}

// Validate checks the field values on GetBrandsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBrandsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBrandsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBrandsResponseMultiError, or nil if none found.
func (m *GetBrandsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBrandsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBrands() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBrandsResponseValidationError{
						field:  fmt.Sprintf("Brands[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBrandsResponseValidationError{
						field:  fmt.Sprintf("Brands[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBrandsResponseValidationError{
					field:  fmt.Sprintf("Brands[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPaging()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBrandsResponseValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBrandsResponseValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaging()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBrandsResponseValidationError{
				field:  "Paging",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBrandsResponseMultiError(errors)
	}

	return nil
}

// GetBrandsResponseMultiError is an error wrapping multiple validation errors
// returned by GetBrandsResponse.ValidateAll() if the designated constraints
// aren't met.
type GetBrandsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBrandsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBrandsResponseMultiError) AllErrors() []error { return m }

// GetBrandsResponseValidationError is the validation error returned by
// GetBrandsResponse.Validate if the designated constraints aren't met.
type GetBrandsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBrandsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBrandsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBrandsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBrandsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBrandsResponseValidationError) ErrorName() string {
	return "GetBrandsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBrandsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBrandsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBrandsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBrandsResponseValidationError{}

// Validate checks the field values on GetAssetFundamentalsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssetFundamentalsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssetFundamentalsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssetFundamentalsRequestMultiError, or nil if none found.
func (m *GetAssetFundamentalsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssetFundamentalsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetAssetFundamentalsRequestMultiError(errors)
	}

	return nil
}

// GetAssetFundamentalsRequestMultiError is an error wrapping multiple
// validation errors returned by GetAssetFundamentalsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetAssetFundamentalsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssetFundamentalsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssetFundamentalsRequestMultiError) AllErrors() []error { return m }

// GetAssetFundamentalsRequestValidationError is the validation error returned
// by GetAssetFundamentalsRequest.Validate if the designated constraints
// aren't met.
type GetAssetFundamentalsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssetFundamentalsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssetFundamentalsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssetFundamentalsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssetFundamentalsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssetFundamentalsRequestValidationError) ErrorName() string {
	return "GetAssetFundamentalsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssetFundamentalsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssetFundamentalsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssetFundamentalsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssetFundamentalsRequestValidationError{}

// Validate checks the field values on GetAssetFundamentalsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssetFundamentalsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssetFundamentalsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssetFundamentalsResponseMultiError, or nil if none found.
func (m *GetAssetFundamentalsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssetFundamentalsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFundamentals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAssetFundamentalsResponseValidationError{
						field:  fmt.Sprintf("Fundamentals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAssetFundamentalsResponseValidationError{
						field:  fmt.Sprintf("Fundamentals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAssetFundamentalsResponseValidationError{
					field:  fmt.Sprintf("Fundamentals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAssetFundamentalsResponseMultiError(errors)
	}

	return nil
}

// GetAssetFundamentalsResponseMultiError is an error wrapping multiple
// validation errors returned by GetAssetFundamentalsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetAssetFundamentalsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssetFundamentalsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssetFundamentalsResponseMultiError) AllErrors() []error { return m }

// GetAssetFundamentalsResponseValidationError is the validation error returned
// by GetAssetFundamentalsResponse.Validate if the designated constraints
// aren't met.
type GetAssetFundamentalsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssetFundamentalsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssetFundamentalsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssetFundamentalsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssetFundamentalsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssetFundamentalsResponseValidationError) ErrorName() string {
	return "GetAssetFundamentalsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssetFundamentalsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssetFundamentalsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssetFundamentalsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssetFundamentalsResponseValidationError{}

// Validate checks the field values on GetAssetReportsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssetReportsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssetReportsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssetReportsRequestMultiError, or nil if none found.
func (m *GetAssetReportsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssetReportsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	if m.From != nil {

		if all {
			switch v := interface{}(m.GetFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAssetReportsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAssetReportsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAssetReportsRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.To != nil {

		if all {
			switch v := interface{}(m.GetTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAssetReportsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAssetReportsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAssetReportsRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAssetReportsRequestMultiError(errors)
	}

	return nil
}

// GetAssetReportsRequestMultiError is an error wrapping multiple validation
// errors returned by GetAssetReportsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetAssetReportsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssetReportsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssetReportsRequestMultiError) AllErrors() []error { return m }

// GetAssetReportsRequestValidationError is the validation error returned by
// GetAssetReportsRequest.Validate if the designated constraints aren't met.
type GetAssetReportsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssetReportsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssetReportsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssetReportsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssetReportsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssetReportsRequestValidationError) ErrorName() string {
	return "GetAssetReportsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssetReportsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssetReportsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssetReportsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssetReportsRequestValidationError{}

// Validate checks the field values on GetAssetReportsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetAssetReportsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetAssetReportsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetAssetReportsResponseMultiError, or nil if none found.
func (m *GetAssetReportsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssetReportsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetAssetReportsResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetAssetReportsResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetAssetReportsResponseValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetAssetReportsResponseMultiError(errors)
	}

	return nil
}

// GetAssetReportsResponseMultiError is an error wrapping multiple validation
// errors returned by GetAssetReportsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetAssetReportsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssetReportsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssetReportsResponseMultiError) AllErrors() []error { return m }

// GetAssetReportsResponseValidationError is the validation error returned by
// GetAssetReportsResponse.Validate if the designated constraints aren't met.
type GetAssetReportsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssetReportsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssetReportsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssetReportsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssetReportsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssetReportsResponseValidationError) ErrorName() string {
	return "GetAssetReportsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssetReportsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssetReportsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssetReportsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssetReportsResponseValidationError{}

// Validate checks the field values on GetConsensusForecastsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConsensusForecastsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConsensusForecastsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetConsensusForecastsRequestMultiError, or nil if none found.
func (m *GetConsensusForecastsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConsensusForecastsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Paging != nil {

		if all {
			switch v := interface{}(m.GetPaging()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetConsensusForecastsRequestValidationError{
						field:  "Paging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetConsensusForecastsRequestValidationError{
						field:  "Paging",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPaging()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetConsensusForecastsRequestValidationError{
					field:  "Paging",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetConsensusForecastsRequestMultiError(errors)
	}

	return nil
}

// GetConsensusForecastsRequestMultiError is an error wrapping multiple
// validation errors returned by GetConsensusForecastsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetConsensusForecastsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConsensusForecastsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConsensusForecastsRequestMultiError) AllErrors() []error { return m }

// GetConsensusForecastsRequestValidationError is the validation error returned
// by GetConsensusForecastsRequest.Validate if the designated constraints
// aren't met.
type GetConsensusForecastsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConsensusForecastsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConsensusForecastsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConsensusForecastsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConsensusForecastsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConsensusForecastsRequestValidationError) ErrorName() string {
	return "GetConsensusForecastsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetConsensusForecastsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConsensusForecastsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConsensusForecastsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConsensusForecastsRequestValidationError{}

// Validate checks the field values on GetConsensusForecastsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetConsensusForecastsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetConsensusForecastsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetConsensusForecastsResponseMultiError, or nil if none found.
func (m *GetConsensusForecastsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConsensusForecastsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetConsensusForecastsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetConsensusForecastsResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetConsensusForecastsResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConsensusForecastsResponseValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConsensusForecastsResponseValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConsensusForecastsResponseValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetConsensusForecastsResponseMultiError(errors)
	}

	return nil
}

// GetConsensusForecastsResponseMultiError is an error wrapping multiple
// validation errors returned by GetConsensusForecastsResponse.ValidateAll()
// if the designated constraints aren't met.
type GetConsensusForecastsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConsensusForecastsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConsensusForecastsResponseMultiError) AllErrors() []error { return m }

// GetConsensusForecastsResponseValidationError is the validation error
// returned by GetConsensusForecastsResponse.Validate if the designated
// constraints aren't met.
type GetConsensusForecastsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConsensusForecastsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetConsensusForecastsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetConsensusForecastsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetConsensusForecastsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConsensusForecastsResponseValidationError) ErrorName() string {
	return "GetConsensusForecastsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetConsensusForecastsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConsensusForecastsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConsensusForecastsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConsensusForecastsResponseValidationError{}

// Validate checks the field values on GetForecastRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetForecastRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetForecastRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetForecastRequestMultiError, or nil if none found.
func (m *GetForecastRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetForecastRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	if len(errors) > 0 {
		return GetForecastRequestMultiError(errors)
	}

	return nil
}

// GetForecastRequestMultiError is an error wrapping multiple validation errors
// returned by GetForecastRequest.ValidateAll() if the designated constraints
// aren't met.
type GetForecastRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetForecastRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetForecastRequestMultiError) AllErrors() []error { return m }

// GetForecastRequestValidationError is the validation error returned by
// GetForecastRequest.Validate if the designated constraints aren't met.
type GetForecastRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetForecastRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetForecastRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetForecastRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetForecastRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetForecastRequestValidationError) ErrorName() string {
	return "GetForecastRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetForecastRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetForecastRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetForecastRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetForecastRequestValidationError{}

// Validate checks the field values on GetForecastResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetForecastResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetForecastResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetForecastResponseMultiError, or nil if none found.
func (m *GetForecastResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetForecastResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTargets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetForecastResponseValidationError{
						field:  fmt.Sprintf("Targets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetForecastResponseValidationError{
						field:  fmt.Sprintf("Targets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetForecastResponseValidationError{
					field:  fmt.Sprintf("Targets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetConsensus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponseValidationError{
					field:  "Consensus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponseValidationError{
					field:  "Consensus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsensus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponseValidationError{
				field:  "Consensus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetForecastResponseMultiError(errors)
	}

	return nil
}

// GetForecastResponseMultiError is an error wrapping multiple validation
// errors returned by GetForecastResponse.ValidateAll() if the designated
// constraints aren't met.
type GetForecastResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetForecastResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetForecastResponseMultiError) AllErrors() []error { return m }

// GetForecastResponseValidationError is the validation error returned by
// GetForecastResponse.Validate if the designated constraints aren't met.
type GetForecastResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetForecastResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetForecastResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetForecastResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetForecastResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetForecastResponseValidationError) ErrorName() string {
	return "GetForecastResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetForecastResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetForecastResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetForecastResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetForecastResponseValidationError{}

// Validate checks the field values on TradingInterval with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TradingInterval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradingInterval with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradingIntervalMultiError, or nil if none found.
func (m *TradingInterval) ValidateAll() error {
	return m.validate(true)
}

func (m *TradingInterval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetInterval()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingIntervalValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingIntervalValidationError{
					field:  "Interval",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterval()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingIntervalValidationError{
				field:  "Interval",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TradingIntervalMultiError(errors)
	}

	return nil
}

// TradingIntervalMultiError is an error wrapping multiple validation errors
// returned by TradingInterval.ValidateAll() if the designated constraints
// aren't met.
type TradingIntervalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradingIntervalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradingIntervalMultiError) AllErrors() []error { return m }

// TradingIntervalValidationError is the validation error returned by
// TradingInterval.Validate if the designated constraints aren't met.
type TradingIntervalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradingIntervalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradingIntervalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradingIntervalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradingIntervalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradingIntervalValidationError) ErrorName() string { return "TradingIntervalValidationError" }

// Error satisfies the builtin error interface
func (e TradingIntervalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradingInterval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradingIntervalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradingIntervalValidationError{}

// Validate checks the field values on GetBondEventsResponse_BondEvent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBondEventsResponse_BondEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBondEventsResponse_BondEvent with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetBondEventsResponse_BondEventMultiError, or nil if none found.
func (m *GetBondEventsResponse_BondEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBondEventsResponse_BondEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	// no validation rules for EventNumber

	if all {
		switch v := interface{}(m.GetEventDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "EventDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "EventDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "EventDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for EventType

	if all {
		switch v := interface{}(m.GetEventTotalVol()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "EventTotalVol",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "EventTotalVol",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEventTotalVol()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "EventTotalVol",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFixDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "FixDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "FixDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFixDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "FixDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRateDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "RateDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "RateDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRateDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "RateDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDefaultDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "DefaultDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "DefaultDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "DefaultDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRealPayDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "RealPayDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "RealPayDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRealPayDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "RealPayDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "PayDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "PayDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "PayDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPayOneBond()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "PayOneBond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "PayOneBond",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayOneBond()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "PayOneBond",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMoneyFlowVal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "MoneyFlowVal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "MoneyFlowVal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMoneyFlowVal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "MoneyFlowVal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Execution

	// no validation rules for OperationType

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Note

	// no validation rules for ConvertToFinToolId

	if all {
		switch v := interface{}(m.GetCouponStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "CouponStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "CouponStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCouponStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "CouponStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCouponEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "CouponEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "CouponEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCouponEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "CouponEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CouponPeriod

	if all {
		switch v := interface{}(m.GetCouponInterestRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "CouponInterestRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetBondEventsResponse_BondEventValidationError{
					field:  "CouponInterestRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCouponInterestRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetBondEventsResponse_BondEventValidationError{
				field:  "CouponInterestRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetBondEventsResponse_BondEventMultiError(errors)
	}

	return nil
}

// GetBondEventsResponse_BondEventMultiError is an error wrapping multiple
// validation errors returned by GetBondEventsResponse_BondEvent.ValidateAll()
// if the designated constraints aren't met.
type GetBondEventsResponse_BondEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBondEventsResponse_BondEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBondEventsResponse_BondEventMultiError) AllErrors() []error { return m }

// GetBondEventsResponse_BondEventValidationError is the validation error
// returned by GetBondEventsResponse_BondEvent.Validate if the designated
// constraints aren't met.
type GetBondEventsResponse_BondEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBondEventsResponse_BondEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBondEventsResponse_BondEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBondEventsResponse_BondEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBondEventsResponse_BondEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBondEventsResponse_BondEventValidationError) ErrorName() string {
	return "GetBondEventsResponse_BondEventValidationError"
}

// Error satisfies the builtin error interface
func (e GetBondEventsResponse_BondEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBondEventsResponse_BondEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBondEventsResponse_BondEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBondEventsResponse_BondEventValidationError{}

// Validate checks the field values on
// GetAssetFundamentalsResponse_StatisticResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetAssetFundamentalsResponse_StatisticResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetAssetFundamentalsResponse_StatisticResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// GetAssetFundamentalsResponse_StatisticResponseMultiError, or nil if none found.
func (m *GetAssetFundamentalsResponse_StatisticResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssetFundamentalsResponse_StatisticResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AssetUid

	// no validation rules for Currency

	// no validation rules for MarketCapitalization

	// no validation rules for HighPriceLast_52Weeks

	// no validation rules for LowPriceLast_52Weeks

	// no validation rules for AverageDailyVolumeLast_10Days

	// no validation rules for AverageDailyVolumeLast_4Weeks

	// no validation rules for Beta

	// no validation rules for FreeFloat

	// no validation rules for ForwardAnnualDividendYield

	// no validation rules for SharesOutstanding

	// no validation rules for RevenueTtm

	// no validation rules for EbitdaTtm

	// no validation rules for NetIncomeTtm

	// no validation rules for EpsTtm

	// no validation rules for DilutedEpsTtm

	// no validation rules for FreeCashFlowTtm

	// no validation rules for FiveYearAnnualRevenueGrowthRate

	// no validation rules for ThreeYearAnnualRevenueGrowthRate

	// no validation rules for PeRatioTtm

	// no validation rules for PriceToSalesTtm

	// no validation rules for PriceToBookTtm

	// no validation rules for PriceToFreeCashFlowTtm

	// no validation rules for TotalEnterpriseValueMrq

	// no validation rules for EvToEbitdaMrq

	// no validation rules for NetMarginMrq

	// no validation rules for NetInterestMarginMrq

	// no validation rules for Roe

	// no validation rules for Roa

	// no validation rules for Roic

	// no validation rules for TotalDebtMrq

	// no validation rules for TotalDebtToEquityMrq

	// no validation rules for TotalDebtToEbitdaMrq

	// no validation rules for FreeCashFlowToPrice

	// no validation rules for NetDebtToEbitda

	// no validation rules for CurrentRatioMrq

	// no validation rules for FixedChargeCoverageRatioFy

	// no validation rules for DividendYieldDailyTtm

	// no validation rules for DividendRateTtm

	// no validation rules for DividendsPerShare

	// no validation rules for FiveYearsAverageDividendYield

	// no validation rules for FiveYearAnnualDividendGrowthRate

	// no validation rules for DividendPayoutRatioFy

	// no validation rules for BuyBackTtm

	// no validation rules for OneYearAnnualRevenueGrowthRate

	// no validation rules for DomicileIndicatorCode

	// no validation rules for AdrToCommonShareRatio

	// no validation rules for NumberOfEmployees

	if all {
		switch v := interface{}(m.GetExDividendDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAssetFundamentalsResponse_StatisticResponseValidationError{
					field:  "ExDividendDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAssetFundamentalsResponse_StatisticResponseValidationError{
					field:  "ExDividendDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExDividendDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAssetFundamentalsResponse_StatisticResponseValidationError{
				field:  "ExDividendDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFiscalPeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAssetFundamentalsResponse_StatisticResponseValidationError{
					field:  "FiscalPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAssetFundamentalsResponse_StatisticResponseValidationError{
					field:  "FiscalPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFiscalPeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAssetFundamentalsResponse_StatisticResponseValidationError{
				field:  "FiscalPeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFiscalPeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAssetFundamentalsResponse_StatisticResponseValidationError{
					field:  "FiscalPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAssetFundamentalsResponse_StatisticResponseValidationError{
					field:  "FiscalPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFiscalPeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAssetFundamentalsResponse_StatisticResponseValidationError{
				field:  "FiscalPeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RevenueChangeFiveYears

	// no validation rules for EpsChangeFiveYears

	// no validation rules for EbitdaChangeFiveYears

	// no validation rules for TotalDebtChangeFiveYears

	// no validation rules for EvToSales

	if len(errors) > 0 {
		return GetAssetFundamentalsResponse_StatisticResponseMultiError(errors)
	}

	return nil
}

// GetAssetFundamentalsResponse_StatisticResponseMultiError is an error
// wrapping multiple validation errors returned by
// GetAssetFundamentalsResponse_StatisticResponse.ValidateAll() if the
// designated constraints aren't met.
type GetAssetFundamentalsResponse_StatisticResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssetFundamentalsResponse_StatisticResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssetFundamentalsResponse_StatisticResponseMultiError) AllErrors() []error { return m }

// GetAssetFundamentalsResponse_StatisticResponseValidationError is the
// validation error returned by
// GetAssetFundamentalsResponse_StatisticResponse.Validate if the designated
// constraints aren't met.
type GetAssetFundamentalsResponse_StatisticResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssetFundamentalsResponse_StatisticResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssetFundamentalsResponse_StatisticResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetAssetFundamentalsResponse_StatisticResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssetFundamentalsResponse_StatisticResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssetFundamentalsResponse_StatisticResponseValidationError) ErrorName() string {
	return "GetAssetFundamentalsResponse_StatisticResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssetFundamentalsResponse_StatisticResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssetFundamentalsResponse_StatisticResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssetFundamentalsResponse_StatisticResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssetFundamentalsResponse_StatisticResponseValidationError{}

// Validate checks the field values on
// GetAssetReportsResponse_GetAssetReportsEvent with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetAssetReportsResponse_GetAssetReportsEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetAssetReportsResponse_GetAssetReportsEvent with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetAssetReportsResponse_GetAssetReportsEventMultiError, or nil if none found.
func (m *GetAssetReportsResponse_GetAssetReportsEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *GetAssetReportsResponse_GetAssetReportsEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentId

	if all {
		switch v := interface{}(m.GetReportDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAssetReportsResponse_GetAssetReportsEventValidationError{
					field:  "ReportDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAssetReportsResponse_GetAssetReportsEventValidationError{
					field:  "ReportDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAssetReportsResponse_GetAssetReportsEventValidationError{
				field:  "ReportDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PeriodYear

	// no validation rules for PeriodNum

	// no validation rules for PeriodType

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetAssetReportsResponse_GetAssetReportsEventValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetAssetReportsResponse_GetAssetReportsEventValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetAssetReportsResponse_GetAssetReportsEventValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetAssetReportsResponse_GetAssetReportsEventMultiError(errors)
	}

	return nil
}

// GetAssetReportsResponse_GetAssetReportsEventMultiError is an error wrapping
// multiple validation errors returned by
// GetAssetReportsResponse_GetAssetReportsEvent.ValidateAll() if the
// designated constraints aren't met.
type GetAssetReportsResponse_GetAssetReportsEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAssetReportsResponse_GetAssetReportsEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAssetReportsResponse_GetAssetReportsEventMultiError) AllErrors() []error { return m }

// GetAssetReportsResponse_GetAssetReportsEventValidationError is the
// validation error returned by
// GetAssetReportsResponse_GetAssetReportsEvent.Validate if the designated
// constraints aren't met.
type GetAssetReportsResponse_GetAssetReportsEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAssetReportsResponse_GetAssetReportsEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAssetReportsResponse_GetAssetReportsEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAssetReportsResponse_GetAssetReportsEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAssetReportsResponse_GetAssetReportsEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAssetReportsResponse_GetAssetReportsEventValidationError) ErrorName() string {
	return "GetAssetReportsResponse_GetAssetReportsEventValidationError"
}

// Error satisfies the builtin error interface
func (e GetAssetReportsResponse_GetAssetReportsEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAssetReportsResponse_GetAssetReportsEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAssetReportsResponse_GetAssetReportsEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAssetReportsResponse_GetAssetReportsEventValidationError{}

// Validate checks the field values on
// GetConsensusForecastsResponse_ConsensusForecastsItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetConsensusForecastsResponse_ConsensusForecastsItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetConsensusForecastsResponse_ConsensusForecastsItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// GetConsensusForecastsResponse_ConsensusForecastsItemMultiError, or nil if
// none found.
func (m *GetConsensusForecastsResponse_ConsensusForecastsItem) ValidateAll() error {
	return m.validate(true)
}

func (m *GetConsensusForecastsResponse_ConsensusForecastsItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for AssetUid

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBestTargetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "BestTargetPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "BestTargetPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBestTargetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
				field:  "BestTargetPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBestTargetLow()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "BestTargetLow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "BestTargetLow",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBestTargetLow()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
				field:  "BestTargetLow",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBestTargetHigh()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "BestTargetHigh",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "BestTargetHigh",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBestTargetHigh()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
				field:  "BestTargetHigh",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TotalBuyRecommend

	// no validation rules for TotalHoldRecommend

	// no validation rules for TotalSellRecommend

	// no validation rules for Currency

	// no validation rules for Consensus

	if all {
		switch v := interface{}(m.GetPrognosisDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "PrognosisDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
					field:  "PrognosisDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrognosisDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{
				field:  "PrognosisDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetConsensusForecastsResponse_ConsensusForecastsItemMultiError(errors)
	}

	return nil
}

// GetConsensusForecastsResponse_ConsensusForecastsItemMultiError is an error
// wrapping multiple validation errors returned by
// GetConsensusForecastsResponse_ConsensusForecastsItem.ValidateAll() if the
// designated constraints aren't met.
type GetConsensusForecastsResponse_ConsensusForecastsItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetConsensusForecastsResponse_ConsensusForecastsItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetConsensusForecastsResponse_ConsensusForecastsItemMultiError) AllErrors() []error { return m }

// GetConsensusForecastsResponse_ConsensusForecastsItemValidationError is the
// validation error returned by
// GetConsensusForecastsResponse_ConsensusForecastsItem.Validate if the
// designated constraints aren't met.
type GetConsensusForecastsResponse_ConsensusForecastsItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetConsensusForecastsResponse_ConsensusForecastsItemValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e GetConsensusForecastsResponse_ConsensusForecastsItemValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetConsensusForecastsResponse_ConsensusForecastsItemValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e GetConsensusForecastsResponse_ConsensusForecastsItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetConsensusForecastsResponse_ConsensusForecastsItemValidationError) ErrorName() string {
	return "GetConsensusForecastsResponse_ConsensusForecastsItemValidationError"
}

// Error satisfies the builtin error interface
func (e GetConsensusForecastsResponse_ConsensusForecastsItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetConsensusForecastsResponse_ConsensusForecastsItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetConsensusForecastsResponse_ConsensusForecastsItemValidationError{}

// Validate checks the field values on GetForecastResponse_TargetItem with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetForecastResponse_TargetItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetForecastResponse_TargetItem with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetForecastResponse_TargetItemMultiError, or nil if none found.
func (m *GetForecastResponse_TargetItem) ValidateAll() error {
	return m.validate(true)
}

func (m *GetForecastResponse_TargetItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Ticker

	// no validation rules for Company

	// no validation rules for Recommendation

	if all {
		switch v := interface{}(m.GetRecommendationDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "RecommendationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "RecommendationDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecommendationDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_TargetItemValidationError{
				field:  "RecommendationDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetCurrentPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "CurrentPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "CurrentPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_TargetItemValidationError{
				field:  "CurrentPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTargetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "TargetPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "TargetPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_TargetItemValidationError{
				field:  "TargetPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPriceChange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "PriceChange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "PriceChange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceChange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_TargetItemValidationError{
				field:  "PriceChange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPriceChangeRel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "PriceChangeRel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_TargetItemValidationError{
					field:  "PriceChangeRel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceChangeRel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_TargetItemValidationError{
				field:  "PriceChangeRel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ShowName

	if len(errors) > 0 {
		return GetForecastResponse_TargetItemMultiError(errors)
	}

	return nil
}

// GetForecastResponse_TargetItemMultiError is an error wrapping multiple
// validation errors returned by GetForecastResponse_TargetItem.ValidateAll()
// if the designated constraints aren't met.
type GetForecastResponse_TargetItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetForecastResponse_TargetItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetForecastResponse_TargetItemMultiError) AllErrors() []error { return m }

// GetForecastResponse_TargetItemValidationError is the validation error
// returned by GetForecastResponse_TargetItem.Validate if the designated
// constraints aren't met.
type GetForecastResponse_TargetItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetForecastResponse_TargetItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetForecastResponse_TargetItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetForecastResponse_TargetItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetForecastResponse_TargetItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetForecastResponse_TargetItemValidationError) ErrorName() string {
	return "GetForecastResponse_TargetItemValidationError"
}

// Error satisfies the builtin error interface
func (e GetForecastResponse_TargetItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetForecastResponse_TargetItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetForecastResponse_TargetItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetForecastResponse_TargetItemValidationError{}

// Validate checks the field values on GetForecastResponse_ConsensusItem with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetForecastResponse_ConsensusItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetForecastResponse_ConsensusItem
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetForecastResponse_ConsensusItemMultiError, or nil if none found.
func (m *GetForecastResponse_ConsensusItem) ValidateAll() error {
	return m.validate(true)
}

func (m *GetForecastResponse_ConsensusItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Uid

	// no validation rules for Ticker

	// no validation rules for Recommendation

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetCurrentPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "CurrentPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "CurrentPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_ConsensusItemValidationError{
				field:  "CurrentPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetConsensus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "Consensus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "Consensus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConsensus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_ConsensusItemValidationError{
				field:  "Consensus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMinTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "MinTarget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "MinTarget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMinTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_ConsensusItemValidationError{
				field:  "MinTarget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMaxTarget()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "MaxTarget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "MaxTarget",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMaxTarget()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_ConsensusItemValidationError{
				field:  "MaxTarget",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPriceChange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "PriceChange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "PriceChange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceChange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_ConsensusItemValidationError{
				field:  "PriceChange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPriceChangeRel()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "PriceChangeRel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetForecastResponse_ConsensusItemValidationError{
					field:  "PriceChangeRel",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceChangeRel()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetForecastResponse_ConsensusItemValidationError{
				field:  "PriceChangeRel",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetForecastResponse_ConsensusItemMultiError(errors)
	}

	return nil
}

// GetForecastResponse_ConsensusItemMultiError is an error wrapping multiple
// validation errors returned by
// GetForecastResponse_ConsensusItem.ValidateAll() if the designated
// constraints aren't met.
type GetForecastResponse_ConsensusItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetForecastResponse_ConsensusItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetForecastResponse_ConsensusItemMultiError) AllErrors() []error { return m }

// GetForecastResponse_ConsensusItemValidationError is the validation error
// returned by GetForecastResponse_ConsensusItem.Validate if the designated
// constraints aren't met.
type GetForecastResponse_ConsensusItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetForecastResponse_ConsensusItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetForecastResponse_ConsensusItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetForecastResponse_ConsensusItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetForecastResponse_ConsensusItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetForecastResponse_ConsensusItemValidationError) ErrorName() string {
	return "GetForecastResponse_ConsensusItemValidationError"
}

// Error satisfies the builtin error interface
func (e GetForecastResponse_ConsensusItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetForecastResponse_ConsensusItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetForecastResponse_ConsensusItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetForecastResponse_ConsensusItemValidationError{}

// Validate checks the field values on TradingInterval_TimeInterval with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TradingInterval_TimeInterval) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TradingInterval_TimeInterval with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TradingInterval_TimeIntervalMultiError, or nil if none found.
func (m *TradingInterval_TimeInterval) ValidateAll() error {
	return m.validate(true)
}

func (m *TradingInterval_TimeInterval) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStartTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingInterval_TimeIntervalValidationError{
					field:  "StartTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingInterval_TimeIntervalValidationError{
					field:  "StartTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingInterval_TimeIntervalValidationError{
				field:  "StartTs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TradingInterval_TimeIntervalValidationError{
					field:  "EndTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TradingInterval_TimeIntervalValidationError{
					field:  "EndTs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TradingInterval_TimeIntervalValidationError{
				field:  "EndTs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TradingInterval_TimeIntervalMultiError(errors)
	}

	return nil
}

// TradingInterval_TimeIntervalMultiError is an error wrapping multiple
// validation errors returned by TradingInterval_TimeInterval.ValidateAll() if
// the designated constraints aren't met.
type TradingInterval_TimeIntervalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TradingInterval_TimeIntervalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TradingInterval_TimeIntervalMultiError) AllErrors() []error { return m }

// TradingInterval_TimeIntervalValidationError is the validation error returned
// by TradingInterval_TimeInterval.Validate if the designated constraints
// aren't met.
type TradingInterval_TimeIntervalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TradingInterval_TimeIntervalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TradingInterval_TimeIntervalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TradingInterval_TimeIntervalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TradingInterval_TimeIntervalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TradingInterval_TimeIntervalValidationError) ErrorName() string {
	return "TradingInterval_TimeIntervalValidationError"
}

// Error satisfies the builtin error interface
func (e TradingInterval_TimeIntervalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTradingInterval_TimeInterval.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TradingInterval_TimeIntervalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TradingInterval_TimeIntervalValidationError{}
