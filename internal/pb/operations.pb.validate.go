// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: operations.proto

package contractv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on OperationsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OperationsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationsRequestMultiError, or nil if none found.
func (m *OperationsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if m.From != nil {

		if all {
			switch v := interface{}(m.GetFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationsRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationsRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.To != nil {

		if all {
			switch v := interface{}(m.GetTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationsRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationsRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.State != nil {
		// no validation rules for State
	}

	if m.Figi != nil {
		// no validation rules for Figi
	}

	if len(errors) > 0 {
		return OperationsRequestMultiError(errors)
	}

	return nil
}

// OperationsRequestMultiError is an error wrapping multiple validation errors
// returned by OperationsRequest.ValidateAll() if the designated constraints
// aren't met.
type OperationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationsRequestMultiError) AllErrors() []error { return m }

// OperationsRequestValidationError is the validation error returned by
// OperationsRequest.Validate if the designated constraints aren't met.
type OperationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationsRequestValidationError) ErrorName() string {
	return "OperationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e OperationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationsRequestValidationError{}

// Validate checks the field values on OperationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationsResponseMultiError, or nil if none found.
func (m *OperationsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOperations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationsResponseValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationsResponseValidationError{
						field:  fmt.Sprintf("Operations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationsResponseValidationError{
					field:  fmt.Sprintf("Operations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OperationsResponseMultiError(errors)
	}

	return nil
}

// OperationsResponseMultiError is an error wrapping multiple validation errors
// returned by OperationsResponse.ValidateAll() if the designated constraints
// aren't met.
type OperationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationsResponseMultiError) AllErrors() []error { return m }

// OperationsResponseValidationError is the validation error returned by
// OperationsResponse.Validate if the designated constraints aren't met.
type OperationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationsResponseValidationError) ErrorName() string {
	return "OperationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e OperationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationsResponseValidationError{}

// Validate checks the field values on Operation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Operation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Operation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationMultiError, or nil
// if none found.
func (m *Operation) ValidateAll() error {
	return m.validate(true)
}

func (m *Operation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for ParentOperationId

	// no validation rules for Currency

	if all {
		switch v := interface{}(m.GetPayment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Payment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Payment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationValidationError{
				field:  "Payment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for Quantity

	// no validation rules for QuantityRest

	// no validation rules for Figi

	// no validation rules for InstrumentType

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for OperationType

	for idx, item := range m.GetTrades() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  fmt.Sprintf("Trades[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AssetUid

	// no validation rules for PositionUid

	// no validation rules for InstrumentUid

	for idx, item := range m.GetChildOperations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("ChildOperations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationValidationError{
						field:  fmt.Sprintf("ChildOperations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationValidationError{
					field:  fmt.Sprintf("ChildOperations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OperationMultiError(errors)
	}

	return nil
}

// OperationMultiError is an error wrapping multiple validation errors returned
// by Operation.ValidateAll() if the designated constraints aren't met.
type OperationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationMultiError) AllErrors() []error { return m }

// OperationValidationError is the validation error returned by
// Operation.Validate if the designated constraints aren't met.
type OperationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationValidationError) ErrorName() string { return "OperationValidationError" }

// Error satisfies the builtin error interface
func (e OperationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationValidationError{}

// Validate checks the field values on OperationTrade with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperationTrade) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationTrade with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationTradeMultiError,
// or nil if none found.
func (m *OperationTrade) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationTrade) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeId

	if all {
		switch v := interface{}(m.GetDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationTradeValidationError{
					field:  "DateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationTradeValidationError{
					field:  "DateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationTradeValidationError{
				field:  "DateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationTradeValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationTradeValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationTradeValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationTradeMultiError(errors)
	}

	return nil
}

// OperationTradeMultiError is an error wrapping multiple validation errors
// returned by OperationTrade.ValidateAll() if the designated constraints
// aren't met.
type OperationTradeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationTradeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationTradeMultiError) AllErrors() []error { return m }

// OperationTradeValidationError is the validation error returned by
// OperationTrade.Validate if the designated constraints aren't met.
type OperationTradeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationTradeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationTradeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationTradeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationTradeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationTradeValidationError) ErrorName() string { return "OperationTradeValidationError" }

// Error satisfies the builtin error interface
func (e OperationTradeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationTrade.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationTradeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationTradeValidationError{}

// Validate checks the field values on PortfolioRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PortfolioRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PortfolioRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PortfolioRequestMultiError, or nil if none found.
func (m *PortfolioRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PortfolioRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if m.Currency != nil {
		// no validation rules for Currency
	}

	if len(errors) > 0 {
		return PortfolioRequestMultiError(errors)
	}

	return nil
}

// PortfolioRequestMultiError is an error wrapping multiple validation errors
// returned by PortfolioRequest.ValidateAll() if the designated constraints
// aren't met.
type PortfolioRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PortfolioRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PortfolioRequestMultiError) AllErrors() []error { return m }

// PortfolioRequestValidationError is the validation error returned by
// PortfolioRequest.Validate if the designated constraints aren't met.
type PortfolioRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PortfolioRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PortfolioRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PortfolioRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PortfolioRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PortfolioRequestValidationError) ErrorName() string { return "PortfolioRequestValidationError" }

// Error satisfies the builtin error interface
func (e PortfolioRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPortfolioRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PortfolioRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PortfolioRequestValidationError{}

// Validate checks the field values on PortfolioResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PortfolioResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PortfolioResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PortfolioResponseMultiError, or nil if none found.
func (m *PortfolioResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PortfolioResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTotalAmountShares()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmountShares()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "TotalAmountShares",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalAmountBonds()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountBonds",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountBonds",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmountBonds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "TotalAmountBonds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalAmountEtf()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountEtf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountEtf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmountEtf()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "TotalAmountEtf",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalAmountCurrencies()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountCurrencies",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountCurrencies",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmountCurrencies()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "TotalAmountCurrencies",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalAmountFutures()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountFutures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountFutures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmountFutures()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "TotalAmountFutures",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpectedYield()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "ExpectedYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "ExpectedYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpectedYield()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "ExpectedYield",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetPositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PortfolioResponseValidationError{
						field:  fmt.Sprintf("Positions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PortfolioResponseValidationError{
						field:  fmt.Sprintf("Positions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PortfolioResponseValidationError{
					field:  fmt.Sprintf("Positions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AccountId

	if all {
		switch v := interface{}(m.GetTotalAmountOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountOptions",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmountOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "TotalAmountOptions",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalAmountSp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountSp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountSp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmountSp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "TotalAmountSp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalAmountPortfolio()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountPortfolio",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "TotalAmountPortfolio",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalAmountPortfolio()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "TotalAmountPortfolio",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetVirtualPositions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PortfolioResponseValidationError{
						field:  fmt.Sprintf("VirtualPositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PortfolioResponseValidationError{
						field:  fmt.Sprintf("VirtualPositions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PortfolioResponseValidationError{
					field:  fmt.Sprintf("VirtualPositions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDailyYield()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "DailyYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "DailyYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDailyYield()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "DailyYield",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDailyYieldRelative()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "DailyYieldRelative",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioResponseValidationError{
					field:  "DailyYieldRelative",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDailyYieldRelative()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioResponseValidationError{
				field:  "DailyYieldRelative",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PortfolioResponseMultiError(errors)
	}

	return nil
}

// PortfolioResponseMultiError is an error wrapping multiple validation errors
// returned by PortfolioResponse.ValidateAll() if the designated constraints
// aren't met.
type PortfolioResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PortfolioResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PortfolioResponseMultiError) AllErrors() []error { return m }

// PortfolioResponseValidationError is the validation error returned by
// PortfolioResponse.Validate if the designated constraints aren't met.
type PortfolioResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PortfolioResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PortfolioResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PortfolioResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PortfolioResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PortfolioResponseValidationError) ErrorName() string {
	return "PortfolioResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PortfolioResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPortfolioResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PortfolioResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PortfolioResponseValidationError{}

// Validate checks the field values on PositionsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PositionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsRequestMultiError, or nil if none found.
func (m *PositionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return PositionsRequestMultiError(errors)
	}

	return nil
}

// PositionsRequestMultiError is an error wrapping multiple validation errors
// returned by PositionsRequest.ValidateAll() if the designated constraints
// aren't met.
type PositionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsRequestMultiError) AllErrors() []error { return m }

// PositionsRequestValidationError is the validation error returned by
// PositionsRequest.Validate if the designated constraints aren't met.
type PositionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsRequestValidationError) ErrorName() string { return "PositionsRequestValidationError" }

// Error satisfies the builtin error interface
func (e PositionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsRequestValidationError{}

// Validate checks the field values on PositionsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PositionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsResponseMultiError, or nil if none found.
func (m *PositionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMoney() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Money[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Money[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsResponseValidationError{
					field:  fmt.Sprintf("Money[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBlocked() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Blocked[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Blocked[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsResponseValidationError{
					field:  fmt.Sprintf("Blocked[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSecurities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Securities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Securities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsResponseValidationError{
					field:  fmt.Sprintf("Securities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for LimitsLoadingInProgress

	for idx, item := range m.GetFutures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Futures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Futures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsResponseValidationError{
					field:  fmt.Sprintf("Futures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsResponseValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsResponseValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for AccountId

	if len(errors) > 0 {
		return PositionsResponseMultiError(errors)
	}

	return nil
}

// PositionsResponseMultiError is an error wrapping multiple validation errors
// returned by PositionsResponse.ValidateAll() if the designated constraints
// aren't met.
type PositionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsResponseMultiError) AllErrors() []error { return m }

// PositionsResponseValidationError is the validation error returned by
// PositionsResponse.Validate if the designated constraints aren't met.
type PositionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsResponseValidationError) ErrorName() string {
	return "PositionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PositionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsResponseValidationError{}

// Validate checks the field values on WithdrawLimitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WithdrawLimitsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WithdrawLimitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WithdrawLimitsRequestMultiError, or nil if none found.
func (m *WithdrawLimitsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WithdrawLimitsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if len(errors) > 0 {
		return WithdrawLimitsRequestMultiError(errors)
	}

	return nil
}

// WithdrawLimitsRequestMultiError is an error wrapping multiple validation
// errors returned by WithdrawLimitsRequest.ValidateAll() if the designated
// constraints aren't met.
type WithdrawLimitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WithdrawLimitsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WithdrawLimitsRequestMultiError) AllErrors() []error { return m }

// WithdrawLimitsRequestValidationError is the validation error returned by
// WithdrawLimitsRequest.Validate if the designated constraints aren't met.
type WithdrawLimitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WithdrawLimitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WithdrawLimitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WithdrawLimitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WithdrawLimitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WithdrawLimitsRequestValidationError) ErrorName() string {
	return "WithdrawLimitsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WithdrawLimitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWithdrawLimitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WithdrawLimitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WithdrawLimitsRequestValidationError{}

// Validate checks the field values on WithdrawLimitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WithdrawLimitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WithdrawLimitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WithdrawLimitsResponseMultiError, or nil if none found.
func (m *WithdrawLimitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WithdrawLimitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetMoney() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WithdrawLimitsResponseValidationError{
						field:  fmt.Sprintf("Money[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WithdrawLimitsResponseValidationError{
						field:  fmt.Sprintf("Money[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WithdrawLimitsResponseValidationError{
					field:  fmt.Sprintf("Money[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBlocked() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WithdrawLimitsResponseValidationError{
						field:  fmt.Sprintf("Blocked[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WithdrawLimitsResponseValidationError{
						field:  fmt.Sprintf("Blocked[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WithdrawLimitsResponseValidationError{
					field:  fmt.Sprintf("Blocked[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBlockedGuarantee() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WithdrawLimitsResponseValidationError{
						field:  fmt.Sprintf("BlockedGuarantee[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WithdrawLimitsResponseValidationError{
						field:  fmt.Sprintf("BlockedGuarantee[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WithdrawLimitsResponseValidationError{
					field:  fmt.Sprintf("BlockedGuarantee[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return WithdrawLimitsResponseMultiError(errors)
	}

	return nil
}

// WithdrawLimitsResponseMultiError is an error wrapping multiple validation
// errors returned by WithdrawLimitsResponse.ValidateAll() if the designated
// constraints aren't met.
type WithdrawLimitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WithdrawLimitsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WithdrawLimitsResponseMultiError) AllErrors() []error { return m }

// WithdrawLimitsResponseValidationError is the validation error returned by
// WithdrawLimitsResponse.Validate if the designated constraints aren't met.
type WithdrawLimitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WithdrawLimitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WithdrawLimitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WithdrawLimitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WithdrawLimitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WithdrawLimitsResponseValidationError) ErrorName() string {
	return "WithdrawLimitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e WithdrawLimitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWithdrawLimitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WithdrawLimitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WithdrawLimitsResponseValidationError{}

// Validate checks the field values on PortfolioPosition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PortfolioPosition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PortfolioPosition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PortfolioPositionMultiError, or nil if none found.
func (m *PortfolioPosition) ValidateAll() error {
	return m.validate(true)
}

func (m *PortfolioPosition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for InstrumentType

	if all {
		switch v := interface{}(m.GetQuantity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "Quantity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "Quantity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuantity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "Quantity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAveragePositionPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "AveragePositionPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "AveragePositionPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAveragePositionPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "AveragePositionPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpectedYield()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "ExpectedYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "ExpectedYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpectedYield()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "ExpectedYield",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentNkd()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "CurrentNkd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "CurrentNkd",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentNkd()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "CurrentNkd",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAveragePositionPricePt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "AveragePositionPricePt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "AveragePositionPricePt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAveragePositionPricePt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "AveragePositionPricePt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "CurrentPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "CurrentPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "CurrentPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAveragePositionPriceFifo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "AveragePositionPriceFifo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "AveragePositionPriceFifo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAveragePositionPriceFifo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "AveragePositionPriceFifo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQuantityLots()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "QuantityLots",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "QuantityLots",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuantityLots()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "QuantityLots",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Blocked

	if all {
		switch v := interface{}(m.GetBlockedLots()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "BlockedLots",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "BlockedLots",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockedLots()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "BlockedLots",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PositionUid

	// no validation rules for InstrumentUid

	if all {
		switch v := interface{}(m.GetVarMargin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "VarMargin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "VarMargin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVarMargin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "VarMargin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpectedYieldFifo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "ExpectedYieldFifo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "ExpectedYieldFifo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpectedYieldFifo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "ExpectedYieldFifo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDailyYield()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "DailyYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioPositionValidationError{
					field:  "DailyYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDailyYield()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioPositionValidationError{
				field:  "DailyYield",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PortfolioPositionMultiError(errors)
	}

	return nil
}

// PortfolioPositionMultiError is an error wrapping multiple validation errors
// returned by PortfolioPosition.ValidateAll() if the designated constraints
// aren't met.
type PortfolioPositionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PortfolioPositionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PortfolioPositionMultiError) AllErrors() []error { return m }

// PortfolioPositionValidationError is the validation error returned by
// PortfolioPosition.Validate if the designated constraints aren't met.
type PortfolioPositionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PortfolioPositionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PortfolioPositionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PortfolioPositionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PortfolioPositionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PortfolioPositionValidationError) ErrorName() string {
	return "PortfolioPositionValidationError"
}

// Error satisfies the builtin error interface
func (e PortfolioPositionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPortfolioPosition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PortfolioPositionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PortfolioPositionValidationError{}

// Validate checks the field values on VirtualPortfolioPosition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VirtualPortfolioPosition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VirtualPortfolioPosition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VirtualPortfolioPositionMultiError, or nil if none found.
func (m *VirtualPortfolioPosition) ValidateAll() error {
	return m.validate(true)
}

func (m *VirtualPortfolioPosition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PositionUid

	// no validation rules for InstrumentUid

	// no validation rules for Figi

	// no validation rules for InstrumentType

	if all {
		switch v := interface{}(m.GetQuantity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "Quantity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "Quantity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuantity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualPortfolioPositionValidationError{
				field:  "Quantity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAveragePositionPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "AveragePositionPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "AveragePositionPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAveragePositionPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualPortfolioPositionValidationError{
				field:  "AveragePositionPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpectedYield()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "ExpectedYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "ExpectedYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpectedYield()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualPortfolioPositionValidationError{
				field:  "ExpectedYield",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpectedYieldFifo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "ExpectedYieldFifo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "ExpectedYieldFifo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpectedYieldFifo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualPortfolioPositionValidationError{
				field:  "ExpectedYieldFifo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExpireDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "ExpireDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "ExpireDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpireDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualPortfolioPositionValidationError{
				field:  "ExpireDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCurrentPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "CurrentPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "CurrentPrice",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurrentPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualPortfolioPositionValidationError{
				field:  "CurrentPrice",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAveragePositionPriceFifo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "AveragePositionPriceFifo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "AveragePositionPriceFifo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAveragePositionPriceFifo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualPortfolioPositionValidationError{
				field:  "AveragePositionPriceFifo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDailyYield()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "DailyYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VirtualPortfolioPositionValidationError{
					field:  "DailyYield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDailyYield()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VirtualPortfolioPositionValidationError{
				field:  "DailyYield",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VirtualPortfolioPositionMultiError(errors)
	}

	return nil
}

// VirtualPortfolioPositionMultiError is an error wrapping multiple validation
// errors returned by VirtualPortfolioPosition.ValidateAll() if the designated
// constraints aren't met.
type VirtualPortfolioPositionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VirtualPortfolioPositionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VirtualPortfolioPositionMultiError) AllErrors() []error { return m }

// VirtualPortfolioPositionValidationError is the validation error returned by
// VirtualPortfolioPosition.Validate if the designated constraints aren't met.
type VirtualPortfolioPositionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VirtualPortfolioPositionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VirtualPortfolioPositionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VirtualPortfolioPositionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VirtualPortfolioPositionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VirtualPortfolioPositionValidationError) ErrorName() string {
	return "VirtualPortfolioPositionValidationError"
}

// Error satisfies the builtin error interface
func (e VirtualPortfolioPositionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVirtualPortfolioPosition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VirtualPortfolioPositionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VirtualPortfolioPositionValidationError{}

// Validate checks the field values on PositionsSecurities with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PositionsSecurities) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsSecurities with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsSecuritiesMultiError, or nil if none found.
func (m *PositionsSecurities) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsSecurities) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Blocked

	// no validation rules for Balance

	// no validation rules for PositionUid

	// no validation rules for InstrumentUid

	// no validation rules for ExchangeBlocked

	// no validation rules for InstrumentType

	if len(errors) > 0 {
		return PositionsSecuritiesMultiError(errors)
	}

	return nil
}

// PositionsSecuritiesMultiError is an error wrapping multiple validation
// errors returned by PositionsSecurities.ValidateAll() if the designated
// constraints aren't met.
type PositionsSecuritiesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsSecuritiesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsSecuritiesMultiError) AllErrors() []error { return m }

// PositionsSecuritiesValidationError is the validation error returned by
// PositionsSecurities.Validate if the designated constraints aren't met.
type PositionsSecuritiesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsSecuritiesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsSecuritiesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsSecuritiesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsSecuritiesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsSecuritiesValidationError) ErrorName() string {
	return "PositionsSecuritiesValidationError"
}

// Error satisfies the builtin error interface
func (e PositionsSecuritiesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsSecurities.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsSecuritiesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsSecuritiesValidationError{}

// Validate checks the field values on PositionsFutures with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PositionsFutures) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsFutures with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsFuturesMultiError, or nil if none found.
func (m *PositionsFutures) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsFutures) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Figi

	// no validation rules for Blocked

	// no validation rules for Balance

	// no validation rules for PositionUid

	// no validation rules for InstrumentUid

	if len(errors) > 0 {
		return PositionsFuturesMultiError(errors)
	}

	return nil
}

// PositionsFuturesMultiError is an error wrapping multiple validation errors
// returned by PositionsFutures.ValidateAll() if the designated constraints
// aren't met.
type PositionsFuturesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsFuturesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsFuturesMultiError) AllErrors() []error { return m }

// PositionsFuturesValidationError is the validation error returned by
// PositionsFutures.Validate if the designated constraints aren't met.
type PositionsFuturesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsFuturesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsFuturesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsFuturesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsFuturesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsFuturesValidationError) ErrorName() string { return "PositionsFuturesValidationError" }

// Error satisfies the builtin error interface
func (e PositionsFuturesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsFutures.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsFuturesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsFuturesValidationError{}

// Validate checks the field values on PositionsOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PositionsOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsOptionsMultiError, or nil if none found.
func (m *PositionsOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PositionUid

	// no validation rules for InstrumentUid

	// no validation rules for Blocked

	// no validation rules for Balance

	if len(errors) > 0 {
		return PositionsOptionsMultiError(errors)
	}

	return nil
}

// PositionsOptionsMultiError is an error wrapping multiple validation errors
// returned by PositionsOptions.ValidateAll() if the designated constraints
// aren't met.
type PositionsOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsOptionsMultiError) AllErrors() []error { return m }

// PositionsOptionsValidationError is the validation error returned by
// PositionsOptions.Validate if the designated constraints aren't met.
type PositionsOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsOptionsValidationError) ErrorName() string { return "PositionsOptionsValidationError" }

// Error satisfies the builtin error interface
func (e PositionsOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsOptionsValidationError{}

// Validate checks the field values on BrokerReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BrokerReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BrokerReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BrokerReportRequestMultiError, or nil if none found.
func (m *BrokerReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *BrokerReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *BrokerReportRequest_GenerateBrokerReportRequest:
		if v == nil {
			err := BrokerReportRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenerateBrokerReportRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BrokerReportRequestValidationError{
						field:  "GenerateBrokerReportRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BrokerReportRequestValidationError{
						field:  "GenerateBrokerReportRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenerateBrokerReportRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BrokerReportRequestValidationError{
					field:  "GenerateBrokerReportRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BrokerReportRequest_GetBrokerReportRequest:
		if v == nil {
			err := BrokerReportRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetBrokerReportRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BrokerReportRequestValidationError{
						field:  "GetBrokerReportRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BrokerReportRequestValidationError{
						field:  "GetBrokerReportRequest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetBrokerReportRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BrokerReportRequestValidationError{
					field:  "GetBrokerReportRequest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return BrokerReportRequestMultiError(errors)
	}

	return nil
}

// BrokerReportRequestMultiError is an error wrapping multiple validation
// errors returned by BrokerReportRequest.ValidateAll() if the designated
// constraints aren't met.
type BrokerReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BrokerReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BrokerReportRequestMultiError) AllErrors() []error { return m }

// BrokerReportRequestValidationError is the validation error returned by
// BrokerReportRequest.Validate if the designated constraints aren't met.
type BrokerReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BrokerReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BrokerReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BrokerReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BrokerReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BrokerReportRequestValidationError) ErrorName() string {
	return "BrokerReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BrokerReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBrokerReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BrokerReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BrokerReportRequestValidationError{}

// Validate checks the field values on BrokerReportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BrokerReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BrokerReportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BrokerReportResponseMultiError, or nil if none found.
func (m *BrokerReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BrokerReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *BrokerReportResponse_GenerateBrokerReportResponse:
		if v == nil {
			err := BrokerReportResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenerateBrokerReportResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BrokerReportResponseValidationError{
						field:  "GenerateBrokerReportResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BrokerReportResponseValidationError{
						field:  "GenerateBrokerReportResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenerateBrokerReportResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BrokerReportResponseValidationError{
					field:  "GenerateBrokerReportResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *BrokerReportResponse_GetBrokerReportResponse:
		if v == nil {
			err := BrokerReportResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetBrokerReportResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BrokerReportResponseValidationError{
						field:  "GetBrokerReportResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BrokerReportResponseValidationError{
						field:  "GetBrokerReportResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetBrokerReportResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BrokerReportResponseValidationError{
					field:  "GetBrokerReportResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return BrokerReportResponseMultiError(errors)
	}

	return nil
}

// BrokerReportResponseMultiError is an error wrapping multiple validation
// errors returned by BrokerReportResponse.ValidateAll() if the designated
// constraints aren't met.
type BrokerReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BrokerReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BrokerReportResponseMultiError) AllErrors() []error { return m }

// BrokerReportResponseValidationError is the validation error returned by
// BrokerReportResponse.Validate if the designated constraints aren't met.
type BrokerReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BrokerReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BrokerReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BrokerReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BrokerReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BrokerReportResponseValidationError) ErrorName() string {
	return "BrokerReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BrokerReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBrokerReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BrokerReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BrokerReportResponseValidationError{}

// Validate checks the field values on GenerateBrokerReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateBrokerReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateBrokerReportRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateBrokerReportRequestMultiError, or nil if none found.
func (m *GenerateBrokerReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateBrokerReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateBrokerReportRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateBrokerReportRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateBrokerReportRequestValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateBrokerReportRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateBrokerReportRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateBrokerReportRequestValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateBrokerReportRequestMultiError(errors)
	}

	return nil
}

// GenerateBrokerReportRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateBrokerReportRequest.ValidateAll() if
// the designated constraints aren't met.
type GenerateBrokerReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateBrokerReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateBrokerReportRequestMultiError) AllErrors() []error { return m }

// GenerateBrokerReportRequestValidationError is the validation error returned
// by GenerateBrokerReportRequest.Validate if the designated constraints
// aren't met.
type GenerateBrokerReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateBrokerReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateBrokerReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateBrokerReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateBrokerReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateBrokerReportRequestValidationError) ErrorName() string {
	return "GenerateBrokerReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateBrokerReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateBrokerReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateBrokerReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateBrokerReportRequestValidationError{}

// Validate checks the field values on GenerateBrokerReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateBrokerReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateBrokerReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GenerateBrokerReportResponseMultiError, or nil if none found.
func (m *GenerateBrokerReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateBrokerReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	if len(errors) > 0 {
		return GenerateBrokerReportResponseMultiError(errors)
	}

	return nil
}

// GenerateBrokerReportResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateBrokerReportResponse.ValidateAll() if
// the designated constraints aren't met.
type GenerateBrokerReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateBrokerReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateBrokerReportResponseMultiError) AllErrors() []error { return m }

// GenerateBrokerReportResponseValidationError is the validation error returned
// by GenerateBrokerReportResponse.Validate if the designated constraints
// aren't met.
type GenerateBrokerReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateBrokerReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateBrokerReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateBrokerReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateBrokerReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateBrokerReportResponseValidationError) ErrorName() string {
	return "GenerateBrokerReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateBrokerReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateBrokerReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateBrokerReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateBrokerReportResponseValidationError{}

// Validate checks the field values on GetBrokerReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBrokerReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBrokerReportRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBrokerReportRequestMultiError, or nil if none found.
func (m *GetBrokerReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBrokerReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	if m.Page != nil {
		// no validation rules for Page
	}

	if len(errors) > 0 {
		return GetBrokerReportRequestMultiError(errors)
	}

	return nil
}

// GetBrokerReportRequestMultiError is an error wrapping multiple validation
// errors returned by GetBrokerReportRequest.ValidateAll() if the designated
// constraints aren't met.
type GetBrokerReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBrokerReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBrokerReportRequestMultiError) AllErrors() []error { return m }

// GetBrokerReportRequestValidationError is the validation error returned by
// GetBrokerReportRequest.Validate if the designated constraints aren't met.
type GetBrokerReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBrokerReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBrokerReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBrokerReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBrokerReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBrokerReportRequestValidationError) ErrorName() string {
	return "GetBrokerReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetBrokerReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBrokerReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBrokerReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBrokerReportRequestValidationError{}

// Validate checks the field values on GetBrokerReportResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetBrokerReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBrokerReportResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBrokerReportResponseMultiError, or nil if none found.
func (m *GetBrokerReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBrokerReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBrokerReport() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetBrokerReportResponseValidationError{
						field:  fmt.Sprintf("BrokerReport[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetBrokerReportResponseValidationError{
						field:  fmt.Sprintf("BrokerReport[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetBrokerReportResponseValidationError{
					field:  fmt.Sprintf("BrokerReport[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ItemsCount

	// no validation rules for PagesCount

	// no validation rules for Page

	if len(errors) > 0 {
		return GetBrokerReportResponseMultiError(errors)
	}

	return nil
}

// GetBrokerReportResponseMultiError is an error wrapping multiple validation
// errors returned by GetBrokerReportResponse.ValidateAll() if the designated
// constraints aren't met.
type GetBrokerReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBrokerReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBrokerReportResponseMultiError) AllErrors() []error { return m }

// GetBrokerReportResponseValidationError is the validation error returned by
// GetBrokerReportResponse.Validate if the designated constraints aren't met.
type GetBrokerReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBrokerReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBrokerReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBrokerReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBrokerReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBrokerReportResponseValidationError) ErrorName() string {
	return "GetBrokerReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetBrokerReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBrokerReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBrokerReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBrokerReportResponseValidationError{}

// Validate checks the field values on BrokerReport with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BrokerReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BrokerReport with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BrokerReportMultiError, or
// nil if none found.
func (m *BrokerReport) ValidateAll() error {
	return m.validate(true)
}

func (m *BrokerReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TradeId

	// no validation rules for OrderId

	// no validation rules for Figi

	// no validation rules for ExecuteSign

	if all {
		switch v := interface{}(m.GetTradeDatetime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "TradeDatetime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "TradeDatetime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTradeDatetime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "TradeDatetime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Exchange

	// no validation rules for ClassCode

	// no validation rules for Direction

	// no validation rules for Name

	// no validation rules for Ticker

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetOrderAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "OrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "OrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrderAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "OrderAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAciValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "AciValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "AciValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAciValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "AciValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotalOrderAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "TotalOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "TotalOrderAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotalOrderAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "TotalOrderAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBrokerCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "BrokerCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "BrokerCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBrokerCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "BrokerCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExchangeCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "ExchangeCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "ExchangeCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExchangeCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "ExchangeCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExchangeClearingCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "ExchangeClearingCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "ExchangeClearingCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExchangeClearingCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "ExchangeClearingCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRepoRate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "RepoRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "RepoRate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepoRate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "RepoRate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Party

	if all {
		switch v := interface{}(m.GetClearValueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "ClearValueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "ClearValueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClearValueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "ClearValueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSecValueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "SecValueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BrokerReportValidationError{
					field:  "SecValueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecValueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BrokerReportValidationError{
				field:  "SecValueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for BrokerStatus

	// no validation rules for SeparateAgreementType

	// no validation rules for SeparateAgreementNumber

	// no validation rules for SeparateAgreementDate

	// no validation rules for DeliveryType

	if len(errors) > 0 {
		return BrokerReportMultiError(errors)
	}

	return nil
}

// BrokerReportMultiError is an error wrapping multiple validation errors
// returned by BrokerReport.ValidateAll() if the designated constraints aren't met.
type BrokerReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BrokerReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BrokerReportMultiError) AllErrors() []error { return m }

// BrokerReportValidationError is the validation error returned by
// BrokerReport.Validate if the designated constraints aren't met.
type BrokerReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BrokerReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BrokerReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BrokerReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BrokerReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BrokerReportValidationError) ErrorName() string { return "BrokerReportValidationError" }

// Error satisfies the builtin error interface
func (e BrokerReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBrokerReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BrokerReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BrokerReportValidationError{}

// Validate checks the field values on GetDividendsForeignIssuerRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetDividendsForeignIssuerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDividendsForeignIssuerRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDividendsForeignIssuerRequestMultiError, or nil if none found.
func (m *GetDividendsForeignIssuerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDividendsForeignIssuerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *GetDividendsForeignIssuerRequest_GenerateDivForeignIssuerReport:
		if v == nil {
			err := GetDividendsForeignIssuerRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenerateDivForeignIssuerReport()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerRequestValidationError{
						field:  "GenerateDivForeignIssuerReport",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerRequestValidationError{
						field:  "GenerateDivForeignIssuerReport",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenerateDivForeignIssuerReport()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDividendsForeignIssuerRequestValidationError{
					field:  "GenerateDivForeignIssuerReport",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GetDividendsForeignIssuerRequest_GetDivForeignIssuerReport:
		if v == nil {
			err := GetDividendsForeignIssuerRequestValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetDivForeignIssuerReport()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerRequestValidationError{
						field:  "GetDivForeignIssuerReport",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerRequestValidationError{
						field:  "GetDivForeignIssuerReport",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetDivForeignIssuerReport()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDividendsForeignIssuerRequestValidationError{
					field:  "GetDivForeignIssuerReport",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return GetDividendsForeignIssuerRequestMultiError(errors)
	}

	return nil
}

// GetDividendsForeignIssuerRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetDividendsForeignIssuerRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDividendsForeignIssuerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDividendsForeignIssuerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDividendsForeignIssuerRequestMultiError) AllErrors() []error { return m }

// GetDividendsForeignIssuerRequestValidationError is the validation error
// returned by GetDividendsForeignIssuerRequest.Validate if the designated
// constraints aren't met.
type GetDividendsForeignIssuerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDividendsForeignIssuerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDividendsForeignIssuerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDividendsForeignIssuerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDividendsForeignIssuerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDividendsForeignIssuerRequestValidationError) ErrorName() string {
	return "GetDividendsForeignIssuerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDividendsForeignIssuerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDividendsForeignIssuerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDividendsForeignIssuerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDividendsForeignIssuerRequestValidationError{}

// Validate checks the field values on GetDividendsForeignIssuerResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetDividendsForeignIssuerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDividendsForeignIssuerResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetDividendsForeignIssuerResponseMultiError, or nil if none found.
func (m *GetDividendsForeignIssuerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDividendsForeignIssuerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *GetDividendsForeignIssuerResponse_GenerateDivForeignIssuerReportResponse:
		if v == nil {
			err := GetDividendsForeignIssuerResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGenerateDivForeignIssuerReportResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerResponseValidationError{
						field:  "GenerateDivForeignIssuerReportResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerResponseValidationError{
						field:  "GenerateDivForeignIssuerReportResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGenerateDivForeignIssuerReportResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDividendsForeignIssuerResponseValidationError{
					field:  "GenerateDivForeignIssuerReportResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *GetDividendsForeignIssuerResponse_DivForeignIssuerReport:
		if v == nil {
			err := GetDividendsForeignIssuerResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDivForeignIssuerReport()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerResponseValidationError{
						field:  "DivForeignIssuerReport",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerResponseValidationError{
						field:  "DivForeignIssuerReport",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDivForeignIssuerReport()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDividendsForeignIssuerResponseValidationError{
					field:  "DivForeignIssuerReport",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return GetDividendsForeignIssuerResponseMultiError(errors)
	}

	return nil
}

// GetDividendsForeignIssuerResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetDividendsForeignIssuerResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDividendsForeignIssuerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDividendsForeignIssuerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDividendsForeignIssuerResponseMultiError) AllErrors() []error { return m }

// GetDividendsForeignIssuerResponseValidationError is the validation error
// returned by GetDividendsForeignIssuerResponse.Validate if the designated
// constraints aren't met.
type GetDividendsForeignIssuerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDividendsForeignIssuerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDividendsForeignIssuerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDividendsForeignIssuerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDividendsForeignIssuerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDividendsForeignIssuerResponseValidationError) ErrorName() string {
	return "GetDividendsForeignIssuerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDividendsForeignIssuerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDividendsForeignIssuerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDividendsForeignIssuerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDividendsForeignIssuerResponseValidationError{}

// Validate checks the field values on
// GenerateDividendsForeignIssuerReportRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenerateDividendsForeignIssuerReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GenerateDividendsForeignIssuerReportRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GenerateDividendsForeignIssuerReportRequestMultiError, or nil if none found.
func (m *GenerateDividendsForeignIssuerReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateDividendsForeignIssuerReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateDividendsForeignIssuerReportRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateDividendsForeignIssuerReportRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateDividendsForeignIssuerReportRequestValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateDividendsForeignIssuerReportRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateDividendsForeignIssuerReportRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateDividendsForeignIssuerReportRequestValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateDividendsForeignIssuerReportRequestMultiError(errors)
	}

	return nil
}

// GenerateDividendsForeignIssuerReportRequestMultiError is an error wrapping
// multiple validation errors returned by
// GenerateDividendsForeignIssuerReportRequest.ValidateAll() if the designated
// constraints aren't met.
type GenerateDividendsForeignIssuerReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateDividendsForeignIssuerReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateDividendsForeignIssuerReportRequestMultiError) AllErrors() []error { return m }

// GenerateDividendsForeignIssuerReportRequestValidationError is the validation
// error returned by GenerateDividendsForeignIssuerReportRequest.Validate if
// the designated constraints aren't met.
type GenerateDividendsForeignIssuerReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateDividendsForeignIssuerReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateDividendsForeignIssuerReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateDividendsForeignIssuerReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateDividendsForeignIssuerReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateDividendsForeignIssuerReportRequestValidationError) ErrorName() string {
	return "GenerateDividendsForeignIssuerReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateDividendsForeignIssuerReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateDividendsForeignIssuerReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateDividendsForeignIssuerReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateDividendsForeignIssuerReportRequestValidationError{}

// Validate checks the field values on GetDividendsForeignIssuerReportRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetDividendsForeignIssuerReportRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetDividendsForeignIssuerReportRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GetDividendsForeignIssuerReportRequestMultiError, or nil if none found.
func (m *GetDividendsForeignIssuerReportRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDividendsForeignIssuerReportRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	if m.Page != nil {
		// no validation rules for Page
	}

	if len(errors) > 0 {
		return GetDividendsForeignIssuerReportRequestMultiError(errors)
	}

	return nil
}

// GetDividendsForeignIssuerReportRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetDividendsForeignIssuerReportRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDividendsForeignIssuerReportRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDividendsForeignIssuerReportRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDividendsForeignIssuerReportRequestMultiError) AllErrors() []error { return m }

// GetDividendsForeignIssuerReportRequestValidationError is the validation
// error returned by GetDividendsForeignIssuerReportRequest.Validate if the
// designated constraints aren't met.
type GetDividendsForeignIssuerReportRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDividendsForeignIssuerReportRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDividendsForeignIssuerReportRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDividendsForeignIssuerReportRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDividendsForeignIssuerReportRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDividendsForeignIssuerReportRequestValidationError) ErrorName() string {
	return "GetDividendsForeignIssuerReportRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDividendsForeignIssuerReportRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDividendsForeignIssuerReportRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDividendsForeignIssuerReportRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDividendsForeignIssuerReportRequestValidationError{}

// Validate checks the field values on
// GenerateDividendsForeignIssuerReportResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenerateDividendsForeignIssuerReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GenerateDividendsForeignIssuerReportResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GenerateDividendsForeignIssuerReportResponseMultiError, or nil if none found.
func (m *GenerateDividendsForeignIssuerReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateDividendsForeignIssuerReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	if len(errors) > 0 {
		return GenerateDividendsForeignIssuerReportResponseMultiError(errors)
	}

	return nil
}

// GenerateDividendsForeignIssuerReportResponseMultiError is an error wrapping
// multiple validation errors returned by
// GenerateDividendsForeignIssuerReportResponse.ValidateAll() if the
// designated constraints aren't met.
type GenerateDividendsForeignIssuerReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateDividendsForeignIssuerReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateDividendsForeignIssuerReportResponseMultiError) AllErrors() []error { return m }

// GenerateDividendsForeignIssuerReportResponseValidationError is the
// validation error returned by
// GenerateDividendsForeignIssuerReportResponse.Validate if the designated
// constraints aren't met.
type GenerateDividendsForeignIssuerReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateDividendsForeignIssuerReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateDividendsForeignIssuerReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateDividendsForeignIssuerReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateDividendsForeignIssuerReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateDividendsForeignIssuerReportResponseValidationError) ErrorName() string {
	return "GenerateDividendsForeignIssuerReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateDividendsForeignIssuerReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateDividendsForeignIssuerReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateDividendsForeignIssuerReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateDividendsForeignIssuerReportResponseValidationError{}

// Validate checks the field values on GetDividendsForeignIssuerReportResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetDividendsForeignIssuerReportResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetDividendsForeignIssuerReportResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// GetDividendsForeignIssuerReportResponseMultiError, or nil if none found.
func (m *GetDividendsForeignIssuerReportResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDividendsForeignIssuerReportResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDividendsForeignIssuerReport() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerReportResponseValidationError{
						field:  fmt.Sprintf("DividendsForeignIssuerReport[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDividendsForeignIssuerReportResponseValidationError{
						field:  fmt.Sprintf("DividendsForeignIssuerReport[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDividendsForeignIssuerReportResponseValidationError{
					field:  fmt.Sprintf("DividendsForeignIssuerReport[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ItemsCount

	// no validation rules for PagesCount

	// no validation rules for Page

	if len(errors) > 0 {
		return GetDividendsForeignIssuerReportResponseMultiError(errors)
	}

	return nil
}

// GetDividendsForeignIssuerReportResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetDividendsForeignIssuerReportResponse.ValidateAll() if the designated
// constraints aren't met.
type GetDividendsForeignIssuerReportResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDividendsForeignIssuerReportResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDividendsForeignIssuerReportResponseMultiError) AllErrors() []error { return m }

// GetDividendsForeignIssuerReportResponseValidationError is the validation
// error returned by GetDividendsForeignIssuerReportResponse.Validate if the
// designated constraints aren't met.
type GetDividendsForeignIssuerReportResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDividendsForeignIssuerReportResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDividendsForeignIssuerReportResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDividendsForeignIssuerReportResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDividendsForeignIssuerReportResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDividendsForeignIssuerReportResponseValidationError) ErrorName() string {
	return "GetDividendsForeignIssuerReportResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDividendsForeignIssuerReportResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDividendsForeignIssuerReportResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDividendsForeignIssuerReportResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDividendsForeignIssuerReportResponseValidationError{}

// Validate checks the field values on DividendsForeignIssuerReport with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DividendsForeignIssuerReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DividendsForeignIssuerReport with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DividendsForeignIssuerReportMultiError, or nil if none found.
func (m *DividendsForeignIssuerReport) ValidateAll() error {
	return m.validate(true)
}

func (m *DividendsForeignIssuerReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRecordDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "RecordDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "RecordDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecordDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendsForeignIssuerReportValidationError{
				field:  "RecordDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaymentDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "PaymentDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "PaymentDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendsForeignIssuerReportValidationError{
				field:  "PaymentDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SecurityName

	// no validation rules for Isin

	// no validation rules for IssuerCountry

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetDividend()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "Dividend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "Dividend",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDividend()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendsForeignIssuerReportValidationError{
				field:  "Dividend",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExternalCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "ExternalCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "ExternalCommission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExternalCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendsForeignIssuerReportValidationError{
				field:  "ExternalCommission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDividendGross()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "DividendGross",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "DividendGross",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDividendGross()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendsForeignIssuerReportValidationError{
				field:  "DividendGross",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTax()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "Tax",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "Tax",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTax()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendsForeignIssuerReportValidationError{
				field:  "Tax",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDividendAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "DividendAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DividendsForeignIssuerReportValidationError{
					field:  "DividendAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDividendAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DividendsForeignIssuerReportValidationError{
				field:  "DividendAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Currency

	if len(errors) > 0 {
		return DividendsForeignIssuerReportMultiError(errors)
	}

	return nil
}

// DividendsForeignIssuerReportMultiError is an error wrapping multiple
// validation errors returned by DividendsForeignIssuerReport.ValidateAll() if
// the designated constraints aren't met.
type DividendsForeignIssuerReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DividendsForeignIssuerReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DividendsForeignIssuerReportMultiError) AllErrors() []error { return m }

// DividendsForeignIssuerReportValidationError is the validation error returned
// by DividendsForeignIssuerReport.Validate if the designated constraints
// aren't met.
type DividendsForeignIssuerReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DividendsForeignIssuerReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DividendsForeignIssuerReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DividendsForeignIssuerReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DividendsForeignIssuerReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DividendsForeignIssuerReportValidationError) ErrorName() string {
	return "DividendsForeignIssuerReportValidationError"
}

// Error satisfies the builtin error interface
func (e DividendsForeignIssuerReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDividendsForeignIssuerReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DividendsForeignIssuerReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DividendsForeignIssuerReportValidationError{}

// Validate checks the field values on PortfolioStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PortfolioStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PortfolioStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PortfolioStreamRequestMultiError, or nil if none found.
func (m *PortfolioStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PortfolioStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPingSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PortfolioStreamRequestValidationError{
					field:  "PingSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PortfolioStreamRequestValidationError{
					field:  "PingSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPingSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PortfolioStreamRequestValidationError{
				field:  "PingSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PortfolioStreamRequestMultiError(errors)
	}

	return nil
}

// PortfolioStreamRequestMultiError is an error wrapping multiple validation
// errors returned by PortfolioStreamRequest.ValidateAll() if the designated
// constraints aren't met.
type PortfolioStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PortfolioStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PortfolioStreamRequestMultiError) AllErrors() []error { return m }

// PortfolioStreamRequestValidationError is the validation error returned by
// PortfolioStreamRequest.Validate if the designated constraints aren't met.
type PortfolioStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PortfolioStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PortfolioStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PortfolioStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PortfolioStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PortfolioStreamRequestValidationError) ErrorName() string {
	return "PortfolioStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PortfolioStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPortfolioStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PortfolioStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PortfolioStreamRequestValidationError{}

// Validate checks the field values on PortfolioStreamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PortfolioStreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PortfolioStreamResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PortfolioStreamResponseMultiError, or nil if none found.
func (m *PortfolioStreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PortfolioStreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *PortfolioStreamResponse_Subscriptions:
		if v == nil {
			err := PortfolioStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscriptions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PortfolioStreamResponseValidationError{
						field:  "Subscriptions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PortfolioStreamResponseValidationError{
						field:  "Subscriptions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscriptions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PortfolioStreamResponseValidationError{
					field:  "Subscriptions",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PortfolioStreamResponse_Portfolio:
		if v == nil {
			err := PortfolioStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPortfolio()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PortfolioStreamResponseValidationError{
						field:  "Portfolio",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PortfolioStreamResponseValidationError{
						field:  "Portfolio",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPortfolio()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PortfolioStreamResponseValidationError{
					field:  "Portfolio",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PortfolioStreamResponse_Ping:
		if v == nil {
			err := PortfolioStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPing()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PortfolioStreamResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PortfolioStreamResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPing()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PortfolioStreamResponseValidationError{
					field:  "Ping",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PortfolioStreamResponseMultiError(errors)
	}

	return nil
}

// PortfolioStreamResponseMultiError is an error wrapping multiple validation
// errors returned by PortfolioStreamResponse.ValidateAll() if the designated
// constraints aren't met.
type PortfolioStreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PortfolioStreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PortfolioStreamResponseMultiError) AllErrors() []error { return m }

// PortfolioStreamResponseValidationError is the validation error returned by
// PortfolioStreamResponse.Validate if the designated constraints aren't met.
type PortfolioStreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PortfolioStreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PortfolioStreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PortfolioStreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PortfolioStreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PortfolioStreamResponseValidationError) ErrorName() string {
	return "PortfolioStreamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PortfolioStreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPortfolioStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PortfolioStreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PortfolioStreamResponseValidationError{}

// Validate checks the field values on PortfolioSubscriptionResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PortfolioSubscriptionResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PortfolioSubscriptionResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PortfolioSubscriptionResultMultiError, or nil if none found.
func (m *PortfolioSubscriptionResult) ValidateAll() error {
	return m.validate(true)
}

func (m *PortfolioSubscriptionResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PortfolioSubscriptionResultValidationError{
						field:  fmt.Sprintf("Accounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PortfolioSubscriptionResultValidationError{
						field:  fmt.Sprintf("Accounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PortfolioSubscriptionResultValidationError{
					field:  fmt.Sprintf("Accounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TrackingId

	// no validation rules for StreamId

	if len(errors) > 0 {
		return PortfolioSubscriptionResultMultiError(errors)
	}

	return nil
}

// PortfolioSubscriptionResultMultiError is an error wrapping multiple
// validation errors returned by PortfolioSubscriptionResult.ValidateAll() if
// the designated constraints aren't met.
type PortfolioSubscriptionResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PortfolioSubscriptionResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PortfolioSubscriptionResultMultiError) AllErrors() []error { return m }

// PortfolioSubscriptionResultValidationError is the validation error returned
// by PortfolioSubscriptionResult.Validate if the designated constraints
// aren't met.
type PortfolioSubscriptionResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PortfolioSubscriptionResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PortfolioSubscriptionResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PortfolioSubscriptionResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PortfolioSubscriptionResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PortfolioSubscriptionResultValidationError) ErrorName() string {
	return "PortfolioSubscriptionResultValidationError"
}

// Error satisfies the builtin error interface
func (e PortfolioSubscriptionResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPortfolioSubscriptionResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PortfolioSubscriptionResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PortfolioSubscriptionResultValidationError{}

// Validate checks the field values on AccountSubscriptionStatus with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AccountSubscriptionStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AccountSubscriptionStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AccountSubscriptionStatusMultiError, or nil if none found.
func (m *AccountSubscriptionStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *AccountSubscriptionStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for SubscriptionStatus

	if len(errors) > 0 {
		return AccountSubscriptionStatusMultiError(errors)
	}

	return nil
}

// AccountSubscriptionStatusMultiError is an error wrapping multiple validation
// errors returned by AccountSubscriptionStatus.ValidateAll() if the
// designated constraints aren't met.
type AccountSubscriptionStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AccountSubscriptionStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AccountSubscriptionStatusMultiError) AllErrors() []error { return m }

// AccountSubscriptionStatusValidationError is the validation error returned by
// AccountSubscriptionStatus.Validate if the designated constraints aren't met.
type AccountSubscriptionStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AccountSubscriptionStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AccountSubscriptionStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AccountSubscriptionStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AccountSubscriptionStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AccountSubscriptionStatusValidationError) ErrorName() string {
	return "AccountSubscriptionStatusValidationError"
}

// Error satisfies the builtin error interface
func (e AccountSubscriptionStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAccountSubscriptionStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AccountSubscriptionStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AccountSubscriptionStatusValidationError{}

// Validate checks the field values on GetOperationsByCursorRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOperationsByCursorRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperationsByCursorRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOperationsByCursorRequestMultiError, or nil if none found.
func (m *GetOperationsByCursorRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperationsByCursorRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	if m.InstrumentId != nil {
		// no validation rules for InstrumentId
	}

	if m.From != nil {

		if all {
			switch v := interface{}(m.GetFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOperationsByCursorRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOperationsByCursorRequestValidationError{
						field:  "From",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOperationsByCursorRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.To != nil {

		if all {
			switch v := interface{}(m.GetTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOperationsByCursorRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOperationsByCursorRequestValidationError{
						field:  "To",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOperationsByCursorRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Cursor != nil {
		// no validation rules for Cursor
	}

	if m.Limit != nil {
		// no validation rules for Limit
	}

	if m.State != nil {
		// no validation rules for State
	}

	if m.WithoutCommissions != nil {
		// no validation rules for WithoutCommissions
	}

	if m.WithoutTrades != nil {
		// no validation rules for WithoutTrades
	}

	if m.WithoutOvernights != nil {
		// no validation rules for WithoutOvernights
	}

	if len(errors) > 0 {
		return GetOperationsByCursorRequestMultiError(errors)
	}

	return nil
}

// GetOperationsByCursorRequestMultiError is an error wrapping multiple
// validation errors returned by GetOperationsByCursorRequest.ValidateAll() if
// the designated constraints aren't met.
type GetOperationsByCursorRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperationsByCursorRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperationsByCursorRequestMultiError) AllErrors() []error { return m }

// GetOperationsByCursorRequestValidationError is the validation error returned
// by GetOperationsByCursorRequest.Validate if the designated constraints
// aren't met.
type GetOperationsByCursorRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperationsByCursorRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperationsByCursorRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperationsByCursorRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperationsByCursorRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperationsByCursorRequestValidationError) ErrorName() string {
	return "GetOperationsByCursorRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperationsByCursorRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperationsByCursorRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperationsByCursorRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperationsByCursorRequestValidationError{}

// Validate checks the field values on GetOperationsByCursorResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOperationsByCursorResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOperationsByCursorResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetOperationsByCursorResponseMultiError, or nil if none found.
func (m *GetOperationsByCursorResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOperationsByCursorResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HasNext

	// no validation rules for NextCursor

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOperationsByCursorResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOperationsByCursorResponseValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOperationsByCursorResponseValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetOperationsByCursorResponseMultiError(errors)
	}

	return nil
}

// GetOperationsByCursorResponseMultiError is an error wrapping multiple
// validation errors returned by GetOperationsByCursorResponse.ValidateAll()
// if the designated constraints aren't met.
type GetOperationsByCursorResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOperationsByCursorResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOperationsByCursorResponseMultiError) AllErrors() []error { return m }

// GetOperationsByCursorResponseValidationError is the validation error
// returned by GetOperationsByCursorResponse.Validate if the designated
// constraints aren't met.
type GetOperationsByCursorResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOperationsByCursorResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOperationsByCursorResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOperationsByCursorResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOperationsByCursorResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOperationsByCursorResponseValidationError) ErrorName() string {
	return "GetOperationsByCursorResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOperationsByCursorResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOperationsByCursorResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOperationsByCursorResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOperationsByCursorResponseValidationError{}

// Validate checks the field values on OperationItem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperationItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OperationItemMultiError, or
// nil if none found.
func (m *OperationItem) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cursor

	// no validation rules for BrokerAccountId

	// no validation rules for Id

	// no validation rules for ParentOperationId

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	// no validation rules for Description

	// no validation rules for State

	// no validation rules for InstrumentUid

	// no validation rules for Figi

	// no validation rules for InstrumentType

	// no validation rules for InstrumentKind

	// no validation rules for PositionUid

	if all {
		switch v := interface{}(m.GetPayment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Payment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Payment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "Payment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCommission()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Commission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Commission",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommission()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "Commission",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetYield()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Yield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "Yield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetYield()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "Yield",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetYieldRelative()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "YieldRelative",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "YieldRelative",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetYieldRelative()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "YieldRelative",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAccruedInt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "AccruedInt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "AccruedInt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccruedInt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "AccruedInt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	// no validation rules for QuantityRest

	// no validation rules for QuantityDone

	if all {
		switch v := interface{}(m.GetCancelDateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "CancelDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "CancelDateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCancelDateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "CancelDateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CancelReason

	if all {
		switch v := interface{}(m.GetTradesInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "TradesInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemValidationError{
					field:  "TradesInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTradesInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemValidationError{
				field:  "TradesInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AssetUid

	for idx, item := range m.GetChildOperations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationItemValidationError{
						field:  fmt.Sprintf("ChildOperations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationItemValidationError{
						field:  fmt.Sprintf("ChildOperations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationItemValidationError{
					field:  fmt.Sprintf("ChildOperations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OperationItemMultiError(errors)
	}

	return nil
}

// OperationItemMultiError is an error wrapping multiple validation errors
// returned by OperationItem.ValidateAll() if the designated constraints
// aren't met.
type OperationItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationItemMultiError) AllErrors() []error { return m }

// OperationItemValidationError is the validation error returned by
// OperationItem.Validate if the designated constraints aren't met.
type OperationItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationItemValidationError) ErrorName() string { return "OperationItemValidationError" }

// Error satisfies the builtin error interface
func (e OperationItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationItemValidationError{}

// Validate checks the field values on OperationItemTrades with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationItemTrades) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationItemTrades with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationItemTradesMultiError, or nil if none found.
func (m *OperationItemTrades) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationItemTrades) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTrades() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationItemTradesValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationItemTradesValidationError{
						field:  fmt.Sprintf("Trades[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationItemTradesValidationError{
					field:  fmt.Sprintf("Trades[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OperationItemTradesMultiError(errors)
	}

	return nil
}

// OperationItemTradesMultiError is an error wrapping multiple validation
// errors returned by OperationItemTrades.ValidateAll() if the designated
// constraints aren't met.
type OperationItemTradesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationItemTradesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationItemTradesMultiError) AllErrors() []error { return m }

// OperationItemTradesValidationError is the validation error returned by
// OperationItemTrades.Validate if the designated constraints aren't met.
type OperationItemTradesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationItemTradesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationItemTradesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationItemTradesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationItemTradesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationItemTradesValidationError) ErrorName() string {
	return "OperationItemTradesValidationError"
}

// Error satisfies the builtin error interface
func (e OperationItemTradesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationItemTrades.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationItemTradesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationItemTradesValidationError{}

// Validate checks the field values on OperationItemTrade with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationItemTrade) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationItemTrade with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationItemTradeMultiError, or nil if none found.
func (m *OperationItemTrade) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationItemTrade) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Num

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemTradeValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemTradeValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemTradeValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetPrice()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemTradeValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemTradeValidationError{
					field:  "Price",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrice()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemTradeValidationError{
				field:  "Price",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetYield()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemTradeValidationError{
					field:  "Yield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemTradeValidationError{
					field:  "Yield",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetYield()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemTradeValidationError{
				field:  "Yield",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetYieldRelative()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationItemTradeValidationError{
					field:  "YieldRelative",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationItemTradeValidationError{
					field:  "YieldRelative",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetYieldRelative()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationItemTradeValidationError{
				field:  "YieldRelative",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationItemTradeMultiError(errors)
	}

	return nil
}

// OperationItemTradeMultiError is an error wrapping multiple validation errors
// returned by OperationItemTrade.ValidateAll() if the designated constraints
// aren't met.
type OperationItemTradeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationItemTradeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationItemTradeMultiError) AllErrors() []error { return m }

// OperationItemTradeValidationError is the validation error returned by
// OperationItemTrade.Validate if the designated constraints aren't met.
type OperationItemTradeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationItemTradeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationItemTradeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationItemTradeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationItemTradeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationItemTradeValidationError) ErrorName() string {
	return "OperationItemTradeValidationError"
}

// Error satisfies the builtin error interface
func (e OperationItemTradeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationItemTrade.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationItemTradeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationItemTradeValidationError{}

// Validate checks the field values on PositionsStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PositionsStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsStreamRequestMultiError, or nil if none found.
func (m *PositionsStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WithInitialPositions

	if all {
		switch v := interface{}(m.GetPingSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PositionsStreamRequestValidationError{
					field:  "PingSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PositionsStreamRequestValidationError{
					field:  "PingSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPingSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PositionsStreamRequestValidationError{
				field:  "PingSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PositionsStreamRequestMultiError(errors)
	}

	return nil
}

// PositionsStreamRequestMultiError is an error wrapping multiple validation
// errors returned by PositionsStreamRequest.ValidateAll() if the designated
// constraints aren't met.
type PositionsStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsStreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsStreamRequestMultiError) AllErrors() []error { return m }

// PositionsStreamRequestValidationError is the validation error returned by
// PositionsStreamRequest.Validate if the designated constraints aren't met.
type PositionsStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsStreamRequestValidationError) ErrorName() string {
	return "PositionsStreamRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PositionsStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsStreamRequestValidationError{}

// Validate checks the field values on PositionsStreamResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PositionsStreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsStreamResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsStreamResponseMultiError, or nil if none found.
func (m *PositionsStreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsStreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Payload.(type) {
	case *PositionsStreamResponse_Subscriptions:
		if v == nil {
			err := PositionsStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSubscriptions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsStreamResponseValidationError{
						field:  "Subscriptions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsStreamResponseValidationError{
						field:  "Subscriptions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSubscriptions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsStreamResponseValidationError{
					field:  "Subscriptions",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PositionsStreamResponse_Position:
		if v == nil {
			err := PositionsStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPosition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsStreamResponseValidationError{
						field:  "Position",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsStreamResponseValidationError{
						field:  "Position",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPosition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsStreamResponseValidationError{
					field:  "Position",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PositionsStreamResponse_Ping:
		if v == nil {
			err := PositionsStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPing()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsStreamResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsStreamResponseValidationError{
						field:  "Ping",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPing()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsStreamResponseValidationError{
					field:  "Ping",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PositionsStreamResponse_InitialPositions:
		if v == nil {
			err := PositionsStreamResponseValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInitialPositions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsStreamResponseValidationError{
						field:  "InitialPositions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsStreamResponseValidationError{
						field:  "InitialPositions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInitialPositions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsStreamResponseValidationError{
					field:  "InitialPositions",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PositionsStreamResponseMultiError(errors)
	}

	return nil
}

// PositionsStreamResponseMultiError is an error wrapping multiple validation
// errors returned by PositionsStreamResponse.ValidateAll() if the designated
// constraints aren't met.
type PositionsStreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsStreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsStreamResponseMultiError) AllErrors() []error { return m }

// PositionsStreamResponseValidationError is the validation error returned by
// PositionsStreamResponse.Validate if the designated constraints aren't met.
type PositionsStreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsStreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsStreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsStreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsStreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsStreamResponseValidationError) ErrorName() string {
	return "PositionsStreamResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PositionsStreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsStreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsStreamResponseValidationError{}

// Validate checks the field values on PositionsSubscriptionResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PositionsSubscriptionResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsSubscriptionResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsSubscriptionResultMultiError, or nil if none found.
func (m *PositionsSubscriptionResult) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsSubscriptionResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAccounts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionsSubscriptionResultValidationError{
						field:  fmt.Sprintf("Accounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionsSubscriptionResultValidationError{
						field:  fmt.Sprintf("Accounts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionsSubscriptionResultValidationError{
					field:  fmt.Sprintf("Accounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for TrackingId

	// no validation rules for StreamId

	if len(errors) > 0 {
		return PositionsSubscriptionResultMultiError(errors)
	}

	return nil
}

// PositionsSubscriptionResultMultiError is an error wrapping multiple
// validation errors returned by PositionsSubscriptionResult.ValidateAll() if
// the designated constraints aren't met.
type PositionsSubscriptionResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsSubscriptionResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsSubscriptionResultMultiError) AllErrors() []error { return m }

// PositionsSubscriptionResultValidationError is the validation error returned
// by PositionsSubscriptionResult.Validate if the designated constraints
// aren't met.
type PositionsSubscriptionResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsSubscriptionResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsSubscriptionResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsSubscriptionResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsSubscriptionResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsSubscriptionResultValidationError) ErrorName() string {
	return "PositionsSubscriptionResultValidationError"
}

// Error satisfies the builtin error interface
func (e PositionsSubscriptionResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsSubscriptionResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsSubscriptionResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsSubscriptionResultValidationError{}

// Validate checks the field values on PositionsSubscriptionStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PositionsSubscriptionStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsSubscriptionStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PositionsSubscriptionStatusMultiError, or nil if none found.
func (m *PositionsSubscriptionStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsSubscriptionStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for SubscriptionStatus

	if len(errors) > 0 {
		return PositionsSubscriptionStatusMultiError(errors)
	}

	return nil
}

// PositionsSubscriptionStatusMultiError is an error wrapping multiple
// validation errors returned by PositionsSubscriptionStatus.ValidateAll() if
// the designated constraints aren't met.
type PositionsSubscriptionStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsSubscriptionStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsSubscriptionStatusMultiError) AllErrors() []error { return m }

// PositionsSubscriptionStatusValidationError is the validation error returned
// by PositionsSubscriptionStatus.Validate if the designated constraints
// aren't met.
type PositionsSubscriptionStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsSubscriptionStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsSubscriptionStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsSubscriptionStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsSubscriptionStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsSubscriptionStatusValidationError) ErrorName() string {
	return "PositionsSubscriptionStatusValidationError"
}

// Error satisfies the builtin error interface
func (e PositionsSubscriptionStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsSubscriptionStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsSubscriptionStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsSubscriptionStatusValidationError{}

// Validate checks the field values on PositionData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PositionData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionData with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PositionDataMultiError, or
// nil if none found.
func (m *PositionData) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	for idx, item := range m.GetMoney() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionDataValidationError{
						field:  fmt.Sprintf("Money[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionDataValidationError{
						field:  fmt.Sprintf("Money[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionDataValidationError{
					field:  fmt.Sprintf("Money[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSecurities() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionDataValidationError{
						field:  fmt.Sprintf("Securities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionDataValidationError{
						field:  fmt.Sprintf("Securities[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionDataValidationError{
					field:  fmt.Sprintf("Securities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFutures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionDataValidationError{
						field:  fmt.Sprintf("Futures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionDataValidationError{
						field:  fmt.Sprintf("Futures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionDataValidationError{
					field:  fmt.Sprintf("Futures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOptions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PositionDataValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PositionDataValidationError{
						field:  fmt.Sprintf("Options[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PositionDataValidationError{
					field:  fmt.Sprintf("Options[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PositionDataValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PositionDataValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PositionDataValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PositionDataMultiError(errors)
	}

	return nil
}

// PositionDataMultiError is an error wrapping multiple validation errors
// returned by PositionData.ValidateAll() if the designated constraints aren't met.
type PositionDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionDataMultiError) AllErrors() []error { return m }

// PositionDataValidationError is the validation error returned by
// PositionData.Validate if the designated constraints aren't met.
type PositionDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionDataValidationError) ErrorName() string { return "PositionDataValidationError" }

// Error satisfies the builtin error interface
func (e PositionDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionDataValidationError{}

// Validate checks the field values on PositionsMoney with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PositionsMoney) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PositionsMoney with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PositionsMoneyMultiError,
// or nil if none found.
func (m *PositionsMoney) ValidateAll() error {
	return m.validate(true)
}

func (m *PositionsMoney) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAvailableValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PositionsMoneyValidationError{
					field:  "AvailableValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PositionsMoneyValidationError{
					field:  "AvailableValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvailableValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PositionsMoneyValidationError{
				field:  "AvailableValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBlockedValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PositionsMoneyValidationError{
					field:  "BlockedValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PositionsMoneyValidationError{
					field:  "BlockedValue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockedValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PositionsMoneyValidationError{
				field:  "BlockedValue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PositionsMoneyMultiError(errors)
	}

	return nil
}

// PositionsMoneyMultiError is an error wrapping multiple validation errors
// returned by PositionsMoney.ValidateAll() if the designated constraints
// aren't met.
type PositionsMoneyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PositionsMoneyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PositionsMoneyMultiError) AllErrors() []error { return m }

// PositionsMoneyValidationError is the validation error returned by
// PositionsMoney.Validate if the designated constraints aren't met.
type PositionsMoneyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PositionsMoneyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PositionsMoneyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PositionsMoneyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PositionsMoneyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PositionsMoneyValidationError) ErrorName() string { return "PositionsMoneyValidationError" }

// Error satisfies the builtin error interface
func (e PositionsMoneyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPositionsMoney.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PositionsMoneyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PositionsMoneyValidationError{}

// Validate checks the field values on ChildOperationItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChildOperationItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChildOperationItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChildOperationItemMultiError, or nil if none found.
func (m *ChildOperationItem) ValidateAll() error {
	return m.validate(true)
}

func (m *ChildOperationItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InstrumentUid

	if all {
		switch v := interface{}(m.GetPayment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ChildOperationItemValidationError{
					field:  "Payment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ChildOperationItemValidationError{
					field:  "Payment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ChildOperationItemValidationError{
				field:  "Payment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ChildOperationItemMultiError(errors)
	}

	return nil
}

// ChildOperationItemMultiError is an error wrapping multiple validation errors
// returned by ChildOperationItem.ValidateAll() if the designated constraints
// aren't met.
type ChildOperationItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChildOperationItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChildOperationItemMultiError) AllErrors() []error { return m }

// ChildOperationItemValidationError is the validation error returned by
// ChildOperationItem.Validate if the designated constraints aren't met.
type ChildOperationItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChildOperationItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChildOperationItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChildOperationItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChildOperationItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChildOperationItemValidationError) ErrorName() string {
	return "ChildOperationItemValidationError"
}

// Error satisfies the builtin error interface
func (e ChildOperationItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChildOperationItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChildOperationItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChildOperationItemValidationError{}
