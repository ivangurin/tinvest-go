// Code generated by mockery v2.50.0. DO NOT EDIT.

package mocks

import (
	context "context"
	contractv1 "tinvest-go/internal/pb"

	grpc "google.golang.org/grpc"

	mock "github.com/stretchr/testify/mock"
)

// InstrumentsAPIMock is an autogenerated mock type for the InstrumentsAPIMock type
type InstrumentsAPIMock struct {
	mock.Mock
}

type InstrumentsAPIMock_Expecter struct {
	mock *mock.Mock
}

func (_m *InstrumentsAPIMock) EXPECT() *InstrumentsAPIMock_Expecter {
	return &InstrumentsAPIMock_Expecter{mock: &_m.Mock}
}

// BondBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) BondBy(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption) (*contractv1.BondResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BondBy")
	}

	var r0 *contractv1.BondResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.BondResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) *contractv1.BondResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.BondResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_BondBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BondBy'
type InstrumentsAPIMock_BondBy_Call struct {
	*mock.Call
}

// BondBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) BondBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_BondBy_Call {
	return &InstrumentsAPIMock_BondBy_Call{Call: _e.mock.On("BondBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_BondBy_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_BondBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_BondBy_Call) Return(_a0 *contractv1.BondResponse, _a1 error) *InstrumentsAPIMock_BondBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_BondBy_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.BondResponse, error)) *InstrumentsAPIMock_BondBy_Call {
	_c.Call.Return(run)
	return _c
}

// Bonds provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) Bonds(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption) (*contractv1.BondsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Bonds")
	}

	var r0 *contractv1.BondsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.BondsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) *contractv1.BondsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.BondsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_Bonds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Bonds'
type InstrumentsAPIMock_Bonds_Call struct {
	*mock.Call
}

// Bonds is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) Bonds(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_Bonds_Call {
	return &InstrumentsAPIMock_Bonds_Call{Call: _e.mock.On("Bonds",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_Bonds_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_Bonds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_Bonds_Call) Return(_a0 *contractv1.BondsResponse, _a1 error) *InstrumentsAPIMock_Bonds_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_Bonds_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.BondsResponse, error)) *InstrumentsAPIMock_Bonds_Call {
	_c.Call.Return(run)
	return _c
}

// Currencies provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) Currencies(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption) (*contractv1.CurrenciesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Currencies")
	}

	var r0 *contractv1.CurrenciesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.CurrenciesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) *contractv1.CurrenciesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.CurrenciesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_Currencies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Currencies'
type InstrumentsAPIMock_Currencies_Call struct {
	*mock.Call
}

// Currencies is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) Currencies(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_Currencies_Call {
	return &InstrumentsAPIMock_Currencies_Call{Call: _e.mock.On("Currencies",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_Currencies_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_Currencies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_Currencies_Call) Return(_a0 *contractv1.CurrenciesResponse, _a1 error) *InstrumentsAPIMock_Currencies_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_Currencies_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.CurrenciesResponse, error)) *InstrumentsAPIMock_Currencies_Call {
	_c.Call.Return(run)
	return _c
}

// CurrencyBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) CurrencyBy(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption) (*contractv1.CurrencyResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CurrencyBy")
	}

	var r0 *contractv1.CurrencyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.CurrencyResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) *contractv1.CurrencyResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.CurrencyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_CurrencyBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrencyBy'
type InstrumentsAPIMock_CurrencyBy_Call struct {
	*mock.Call
}

// CurrencyBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) CurrencyBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_CurrencyBy_Call {
	return &InstrumentsAPIMock_CurrencyBy_Call{Call: _e.mock.On("CurrencyBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_CurrencyBy_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_CurrencyBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_CurrencyBy_Call) Return(_a0 *contractv1.CurrencyResponse, _a1 error) *InstrumentsAPIMock_CurrencyBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_CurrencyBy_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.CurrencyResponse, error)) *InstrumentsAPIMock_CurrencyBy_Call {
	_c.Call.Return(run)
	return _c
}

// EditFavorites provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) EditFavorites(ctx context.Context, in *contractv1.EditFavoritesRequest, opts ...grpc.CallOption) (*contractv1.EditFavoritesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EditFavorites")
	}

	var r0 *contractv1.EditFavoritesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.EditFavoritesRequest, ...grpc.CallOption) (*contractv1.EditFavoritesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.EditFavoritesRequest, ...grpc.CallOption) *contractv1.EditFavoritesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.EditFavoritesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.EditFavoritesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_EditFavorites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EditFavorites'
type InstrumentsAPIMock_EditFavorites_Call struct {
	*mock.Call
}

// EditFavorites is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.EditFavoritesRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) EditFavorites(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_EditFavorites_Call {
	return &InstrumentsAPIMock_EditFavorites_Call{Call: _e.mock.On("EditFavorites",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_EditFavorites_Call) Run(run func(ctx context.Context, in *contractv1.EditFavoritesRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_EditFavorites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.EditFavoritesRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_EditFavorites_Call) Return(_a0 *contractv1.EditFavoritesResponse, _a1 error) *InstrumentsAPIMock_EditFavorites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_EditFavorites_Call) RunAndReturn(run func(context.Context, *contractv1.EditFavoritesRequest, ...grpc.CallOption) (*contractv1.EditFavoritesResponse, error)) *InstrumentsAPIMock_EditFavorites_Call {
	_c.Call.Return(run)
	return _c
}

// EtfBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) EtfBy(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption) (*contractv1.EtfResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EtfBy")
	}

	var r0 *contractv1.EtfResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.EtfResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) *contractv1.EtfResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.EtfResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_EtfBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EtfBy'
type InstrumentsAPIMock_EtfBy_Call struct {
	*mock.Call
}

// EtfBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) EtfBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_EtfBy_Call {
	return &InstrumentsAPIMock_EtfBy_Call{Call: _e.mock.On("EtfBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_EtfBy_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_EtfBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_EtfBy_Call) Return(_a0 *contractv1.EtfResponse, _a1 error) *InstrumentsAPIMock_EtfBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_EtfBy_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.EtfResponse, error)) *InstrumentsAPIMock_EtfBy_Call {
	_c.Call.Return(run)
	return _c
}

// Etfs provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) Etfs(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption) (*contractv1.EtfsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Etfs")
	}

	var r0 *contractv1.EtfsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.EtfsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) *contractv1.EtfsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.EtfsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_Etfs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Etfs'
type InstrumentsAPIMock_Etfs_Call struct {
	*mock.Call
}

// Etfs is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) Etfs(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_Etfs_Call {
	return &InstrumentsAPIMock_Etfs_Call{Call: _e.mock.On("Etfs",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_Etfs_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_Etfs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_Etfs_Call) Return(_a0 *contractv1.EtfsResponse, _a1 error) *InstrumentsAPIMock_Etfs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_Etfs_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.EtfsResponse, error)) *InstrumentsAPIMock_Etfs_Call {
	_c.Call.Return(run)
	return _c
}

// FindInstrument provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) FindInstrument(ctx context.Context, in *contractv1.FindInstrumentRequest, opts ...grpc.CallOption) (*contractv1.FindInstrumentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FindInstrument")
	}

	var r0 *contractv1.FindInstrumentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.FindInstrumentRequest, ...grpc.CallOption) (*contractv1.FindInstrumentResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.FindInstrumentRequest, ...grpc.CallOption) *contractv1.FindInstrumentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.FindInstrumentResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.FindInstrumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_FindInstrument_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindInstrument'
type InstrumentsAPIMock_FindInstrument_Call struct {
	*mock.Call
}

// FindInstrument is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.FindInstrumentRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) FindInstrument(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_FindInstrument_Call {
	return &InstrumentsAPIMock_FindInstrument_Call{Call: _e.mock.On("FindInstrument",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_FindInstrument_Call) Run(run func(ctx context.Context, in *contractv1.FindInstrumentRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_FindInstrument_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.FindInstrumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_FindInstrument_Call) Return(_a0 *contractv1.FindInstrumentResponse, _a1 error) *InstrumentsAPIMock_FindInstrument_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_FindInstrument_Call) RunAndReturn(run func(context.Context, *contractv1.FindInstrumentRequest, ...grpc.CallOption) (*contractv1.FindInstrumentResponse, error)) *InstrumentsAPIMock_FindInstrument_Call {
	_c.Call.Return(run)
	return _c
}

// FutureBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) FutureBy(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption) (*contractv1.FutureResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for FutureBy")
	}

	var r0 *contractv1.FutureResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.FutureResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) *contractv1.FutureResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.FutureResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_FutureBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FutureBy'
type InstrumentsAPIMock_FutureBy_Call struct {
	*mock.Call
}

// FutureBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) FutureBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_FutureBy_Call {
	return &InstrumentsAPIMock_FutureBy_Call{Call: _e.mock.On("FutureBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_FutureBy_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_FutureBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_FutureBy_Call) Return(_a0 *contractv1.FutureResponse, _a1 error) *InstrumentsAPIMock_FutureBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_FutureBy_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.FutureResponse, error)) *InstrumentsAPIMock_FutureBy_Call {
	_c.Call.Return(run)
	return _c
}

// Futures provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) Futures(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption) (*contractv1.FuturesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Futures")
	}

	var r0 *contractv1.FuturesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.FuturesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) *contractv1.FuturesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.FuturesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_Futures_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Futures'
type InstrumentsAPIMock_Futures_Call struct {
	*mock.Call
}

// Futures is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) Futures(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_Futures_Call {
	return &InstrumentsAPIMock_Futures_Call{Call: _e.mock.On("Futures",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_Futures_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_Futures_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_Futures_Call) Return(_a0 *contractv1.FuturesResponse, _a1 error) *InstrumentsAPIMock_Futures_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_Futures_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.FuturesResponse, error)) *InstrumentsAPIMock_Futures_Call {
	_c.Call.Return(run)
	return _c
}

// GetAccruedInterests provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetAccruedInterests(ctx context.Context, in *contractv1.GetAccruedInterestsRequest, opts ...grpc.CallOption) (*contractv1.GetAccruedInterestsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAccruedInterests")
	}

	var r0 *contractv1.GetAccruedInterestsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetAccruedInterestsRequest, ...grpc.CallOption) (*contractv1.GetAccruedInterestsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetAccruedInterestsRequest, ...grpc.CallOption) *contractv1.GetAccruedInterestsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetAccruedInterestsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetAccruedInterestsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetAccruedInterests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAccruedInterests'
type InstrumentsAPIMock_GetAccruedInterests_Call struct {
	*mock.Call
}

// GetAccruedInterests is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetAccruedInterestsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetAccruedInterests(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetAccruedInterests_Call {
	return &InstrumentsAPIMock_GetAccruedInterests_Call{Call: _e.mock.On("GetAccruedInterests",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetAccruedInterests_Call) Run(run func(ctx context.Context, in *contractv1.GetAccruedInterestsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetAccruedInterests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetAccruedInterestsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetAccruedInterests_Call) Return(_a0 *contractv1.GetAccruedInterestsResponse, _a1 error) *InstrumentsAPIMock_GetAccruedInterests_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetAccruedInterests_Call) RunAndReturn(run func(context.Context, *contractv1.GetAccruedInterestsRequest, ...grpc.CallOption) (*contractv1.GetAccruedInterestsResponse, error)) *InstrumentsAPIMock_GetAccruedInterests_Call {
	_c.Call.Return(run)
	return _c
}

// GetAssetBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetAssetBy(ctx context.Context, in *contractv1.AssetRequest, opts ...grpc.CallOption) (*contractv1.AssetResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssetBy")
	}

	var r0 *contractv1.AssetResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.AssetRequest, ...grpc.CallOption) (*contractv1.AssetResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.AssetRequest, ...grpc.CallOption) *contractv1.AssetResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.AssetResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.AssetRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetAssetBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAssetBy'
type InstrumentsAPIMock_GetAssetBy_Call struct {
	*mock.Call
}

// GetAssetBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.AssetRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetAssetBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetAssetBy_Call {
	return &InstrumentsAPIMock_GetAssetBy_Call{Call: _e.mock.On("GetAssetBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetAssetBy_Call) Run(run func(ctx context.Context, in *contractv1.AssetRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetAssetBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.AssetRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetAssetBy_Call) Return(_a0 *contractv1.AssetResponse, _a1 error) *InstrumentsAPIMock_GetAssetBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetAssetBy_Call) RunAndReturn(run func(context.Context, *contractv1.AssetRequest, ...grpc.CallOption) (*contractv1.AssetResponse, error)) *InstrumentsAPIMock_GetAssetBy_Call {
	_c.Call.Return(run)
	return _c
}

// GetAssetFundamentals provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetAssetFundamentals(ctx context.Context, in *contractv1.GetAssetFundamentalsRequest, opts ...grpc.CallOption) (*contractv1.GetAssetFundamentalsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssetFundamentals")
	}

	var r0 *contractv1.GetAssetFundamentalsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetAssetFundamentalsRequest, ...grpc.CallOption) (*contractv1.GetAssetFundamentalsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetAssetFundamentalsRequest, ...grpc.CallOption) *contractv1.GetAssetFundamentalsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetAssetFundamentalsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetAssetFundamentalsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetAssetFundamentals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAssetFundamentals'
type InstrumentsAPIMock_GetAssetFundamentals_Call struct {
	*mock.Call
}

// GetAssetFundamentals is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetAssetFundamentalsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetAssetFundamentals(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetAssetFundamentals_Call {
	return &InstrumentsAPIMock_GetAssetFundamentals_Call{Call: _e.mock.On("GetAssetFundamentals",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetAssetFundamentals_Call) Run(run func(ctx context.Context, in *contractv1.GetAssetFundamentalsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetAssetFundamentals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetAssetFundamentalsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetAssetFundamentals_Call) Return(_a0 *contractv1.GetAssetFundamentalsResponse, _a1 error) *InstrumentsAPIMock_GetAssetFundamentals_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetAssetFundamentals_Call) RunAndReturn(run func(context.Context, *contractv1.GetAssetFundamentalsRequest, ...grpc.CallOption) (*contractv1.GetAssetFundamentalsResponse, error)) *InstrumentsAPIMock_GetAssetFundamentals_Call {
	_c.Call.Return(run)
	return _c
}

// GetAssetReports provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetAssetReports(ctx context.Context, in *contractv1.GetAssetReportsRequest, opts ...grpc.CallOption) (*contractv1.GetAssetReportsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssetReports")
	}

	var r0 *contractv1.GetAssetReportsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetAssetReportsRequest, ...grpc.CallOption) (*contractv1.GetAssetReportsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetAssetReportsRequest, ...grpc.CallOption) *contractv1.GetAssetReportsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetAssetReportsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetAssetReportsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetAssetReports_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAssetReports'
type InstrumentsAPIMock_GetAssetReports_Call struct {
	*mock.Call
}

// GetAssetReports is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetAssetReportsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetAssetReports(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetAssetReports_Call {
	return &InstrumentsAPIMock_GetAssetReports_Call{Call: _e.mock.On("GetAssetReports",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetAssetReports_Call) Run(run func(ctx context.Context, in *contractv1.GetAssetReportsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetAssetReports_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetAssetReportsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetAssetReports_Call) Return(_a0 *contractv1.GetAssetReportsResponse, _a1 error) *InstrumentsAPIMock_GetAssetReports_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetAssetReports_Call) RunAndReturn(run func(context.Context, *contractv1.GetAssetReportsRequest, ...grpc.CallOption) (*contractv1.GetAssetReportsResponse, error)) *InstrumentsAPIMock_GetAssetReports_Call {
	_c.Call.Return(run)
	return _c
}

// GetAssets provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetAssets(ctx context.Context, in *contractv1.AssetsRequest, opts ...grpc.CallOption) (*contractv1.AssetsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAssets")
	}

	var r0 *contractv1.AssetsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.AssetsRequest, ...grpc.CallOption) (*contractv1.AssetsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.AssetsRequest, ...grpc.CallOption) *contractv1.AssetsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.AssetsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.AssetsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetAssets_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAssets'
type InstrumentsAPIMock_GetAssets_Call struct {
	*mock.Call
}

// GetAssets is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.AssetsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetAssets(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetAssets_Call {
	return &InstrumentsAPIMock_GetAssets_Call{Call: _e.mock.On("GetAssets",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetAssets_Call) Run(run func(ctx context.Context, in *contractv1.AssetsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetAssets_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.AssetsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetAssets_Call) Return(_a0 *contractv1.AssetsResponse, _a1 error) *InstrumentsAPIMock_GetAssets_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetAssets_Call) RunAndReturn(run func(context.Context, *contractv1.AssetsRequest, ...grpc.CallOption) (*contractv1.AssetsResponse, error)) *InstrumentsAPIMock_GetAssets_Call {
	_c.Call.Return(run)
	return _c
}

// GetBondCoupons provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetBondCoupons(ctx context.Context, in *contractv1.GetBondCouponsRequest, opts ...grpc.CallOption) (*contractv1.GetBondCouponsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBondCoupons")
	}

	var r0 *contractv1.GetBondCouponsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetBondCouponsRequest, ...grpc.CallOption) (*contractv1.GetBondCouponsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetBondCouponsRequest, ...grpc.CallOption) *contractv1.GetBondCouponsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetBondCouponsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetBondCouponsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetBondCoupons_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBondCoupons'
type InstrumentsAPIMock_GetBondCoupons_Call struct {
	*mock.Call
}

// GetBondCoupons is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetBondCouponsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetBondCoupons(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetBondCoupons_Call {
	return &InstrumentsAPIMock_GetBondCoupons_Call{Call: _e.mock.On("GetBondCoupons",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetBondCoupons_Call) Run(run func(ctx context.Context, in *contractv1.GetBondCouponsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetBondCoupons_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetBondCouponsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetBondCoupons_Call) Return(_a0 *contractv1.GetBondCouponsResponse, _a1 error) *InstrumentsAPIMock_GetBondCoupons_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetBondCoupons_Call) RunAndReturn(run func(context.Context, *contractv1.GetBondCouponsRequest, ...grpc.CallOption) (*contractv1.GetBondCouponsResponse, error)) *InstrumentsAPIMock_GetBondCoupons_Call {
	_c.Call.Return(run)
	return _c
}

// GetBondEvents provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetBondEvents(ctx context.Context, in *contractv1.GetBondEventsRequest, opts ...grpc.CallOption) (*contractv1.GetBondEventsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBondEvents")
	}

	var r0 *contractv1.GetBondEventsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetBondEventsRequest, ...grpc.CallOption) (*contractv1.GetBondEventsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetBondEventsRequest, ...grpc.CallOption) *contractv1.GetBondEventsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetBondEventsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetBondEventsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetBondEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBondEvents'
type InstrumentsAPIMock_GetBondEvents_Call struct {
	*mock.Call
}

// GetBondEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetBondEventsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetBondEvents(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetBondEvents_Call {
	return &InstrumentsAPIMock_GetBondEvents_Call{Call: _e.mock.On("GetBondEvents",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetBondEvents_Call) Run(run func(ctx context.Context, in *contractv1.GetBondEventsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetBondEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetBondEventsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetBondEvents_Call) Return(_a0 *contractv1.GetBondEventsResponse, _a1 error) *InstrumentsAPIMock_GetBondEvents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetBondEvents_Call) RunAndReturn(run func(context.Context, *contractv1.GetBondEventsRequest, ...grpc.CallOption) (*contractv1.GetBondEventsResponse, error)) *InstrumentsAPIMock_GetBondEvents_Call {
	_c.Call.Return(run)
	return _c
}

// GetBrandBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetBrandBy(ctx context.Context, in *contractv1.GetBrandRequest, opts ...grpc.CallOption) (*contractv1.Brand, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBrandBy")
	}

	var r0 *contractv1.Brand
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetBrandRequest, ...grpc.CallOption) (*contractv1.Brand, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetBrandRequest, ...grpc.CallOption) *contractv1.Brand); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.Brand)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetBrandRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetBrandBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBrandBy'
type InstrumentsAPIMock_GetBrandBy_Call struct {
	*mock.Call
}

// GetBrandBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetBrandRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetBrandBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetBrandBy_Call {
	return &InstrumentsAPIMock_GetBrandBy_Call{Call: _e.mock.On("GetBrandBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetBrandBy_Call) Run(run func(ctx context.Context, in *contractv1.GetBrandRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetBrandBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetBrandRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetBrandBy_Call) Return(_a0 *contractv1.Brand, _a1 error) *InstrumentsAPIMock_GetBrandBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetBrandBy_Call) RunAndReturn(run func(context.Context, *contractv1.GetBrandRequest, ...grpc.CallOption) (*contractv1.Brand, error)) *InstrumentsAPIMock_GetBrandBy_Call {
	_c.Call.Return(run)
	return _c
}

// GetBrands provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetBrands(ctx context.Context, in *contractv1.GetBrandsRequest, opts ...grpc.CallOption) (*contractv1.GetBrandsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetBrands")
	}

	var r0 *contractv1.GetBrandsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetBrandsRequest, ...grpc.CallOption) (*contractv1.GetBrandsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetBrandsRequest, ...grpc.CallOption) *contractv1.GetBrandsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetBrandsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetBrandsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetBrands_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBrands'
type InstrumentsAPIMock_GetBrands_Call struct {
	*mock.Call
}

// GetBrands is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetBrandsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetBrands(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetBrands_Call {
	return &InstrumentsAPIMock_GetBrands_Call{Call: _e.mock.On("GetBrands",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetBrands_Call) Run(run func(ctx context.Context, in *contractv1.GetBrandsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetBrands_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetBrandsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetBrands_Call) Return(_a0 *contractv1.GetBrandsResponse, _a1 error) *InstrumentsAPIMock_GetBrands_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetBrands_Call) RunAndReturn(run func(context.Context, *contractv1.GetBrandsRequest, ...grpc.CallOption) (*contractv1.GetBrandsResponse, error)) *InstrumentsAPIMock_GetBrands_Call {
	_c.Call.Return(run)
	return _c
}

// GetConsensusForecasts provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetConsensusForecasts(ctx context.Context, in *contractv1.GetConsensusForecastsRequest, opts ...grpc.CallOption) (*contractv1.GetConsensusForecastsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConsensusForecasts")
	}

	var r0 *contractv1.GetConsensusForecastsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetConsensusForecastsRequest, ...grpc.CallOption) (*contractv1.GetConsensusForecastsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetConsensusForecastsRequest, ...grpc.CallOption) *contractv1.GetConsensusForecastsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetConsensusForecastsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetConsensusForecastsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetConsensusForecasts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConsensusForecasts'
type InstrumentsAPIMock_GetConsensusForecasts_Call struct {
	*mock.Call
}

// GetConsensusForecasts is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetConsensusForecastsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetConsensusForecasts(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetConsensusForecasts_Call {
	return &InstrumentsAPIMock_GetConsensusForecasts_Call{Call: _e.mock.On("GetConsensusForecasts",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetConsensusForecasts_Call) Run(run func(ctx context.Context, in *contractv1.GetConsensusForecastsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetConsensusForecasts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetConsensusForecastsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetConsensusForecasts_Call) Return(_a0 *contractv1.GetConsensusForecastsResponse, _a1 error) *InstrumentsAPIMock_GetConsensusForecasts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetConsensusForecasts_Call) RunAndReturn(run func(context.Context, *contractv1.GetConsensusForecastsRequest, ...grpc.CallOption) (*contractv1.GetConsensusForecastsResponse, error)) *InstrumentsAPIMock_GetConsensusForecasts_Call {
	_c.Call.Return(run)
	return _c
}

// GetCountries provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetCountries(ctx context.Context, in *contractv1.GetCountriesRequest, opts ...grpc.CallOption) (*contractv1.GetCountriesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCountries")
	}

	var r0 *contractv1.GetCountriesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetCountriesRequest, ...grpc.CallOption) (*contractv1.GetCountriesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetCountriesRequest, ...grpc.CallOption) *contractv1.GetCountriesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetCountriesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetCountriesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetCountries_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCountries'
type InstrumentsAPIMock_GetCountries_Call struct {
	*mock.Call
}

// GetCountries is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetCountriesRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetCountries(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetCountries_Call {
	return &InstrumentsAPIMock_GetCountries_Call{Call: _e.mock.On("GetCountries",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetCountries_Call) Run(run func(ctx context.Context, in *contractv1.GetCountriesRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetCountries_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetCountriesRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetCountries_Call) Return(_a0 *contractv1.GetCountriesResponse, _a1 error) *InstrumentsAPIMock_GetCountries_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetCountries_Call) RunAndReturn(run func(context.Context, *contractv1.GetCountriesRequest, ...grpc.CallOption) (*contractv1.GetCountriesResponse, error)) *InstrumentsAPIMock_GetCountries_Call {
	_c.Call.Return(run)
	return _c
}

// GetDividends provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetDividends(ctx context.Context, in *contractv1.GetDividendsRequest, opts ...grpc.CallOption) (*contractv1.GetDividendsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDividends")
	}

	var r0 *contractv1.GetDividendsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetDividendsRequest, ...grpc.CallOption) (*contractv1.GetDividendsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetDividendsRequest, ...grpc.CallOption) *contractv1.GetDividendsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetDividendsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetDividendsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetDividends_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDividends'
type InstrumentsAPIMock_GetDividends_Call struct {
	*mock.Call
}

// GetDividends is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetDividendsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetDividends(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetDividends_Call {
	return &InstrumentsAPIMock_GetDividends_Call{Call: _e.mock.On("GetDividends",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetDividends_Call) Run(run func(ctx context.Context, in *contractv1.GetDividendsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetDividends_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetDividendsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetDividends_Call) Return(_a0 *contractv1.GetDividendsResponse, _a1 error) *InstrumentsAPIMock_GetDividends_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetDividends_Call) RunAndReturn(run func(context.Context, *contractv1.GetDividendsRequest, ...grpc.CallOption) (*contractv1.GetDividendsResponse, error)) *InstrumentsAPIMock_GetDividends_Call {
	_c.Call.Return(run)
	return _c
}

// GetFavorites provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetFavorites(ctx context.Context, in *contractv1.GetFavoritesRequest, opts ...grpc.CallOption) (*contractv1.GetFavoritesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFavorites")
	}

	var r0 *contractv1.GetFavoritesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetFavoritesRequest, ...grpc.CallOption) (*contractv1.GetFavoritesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetFavoritesRequest, ...grpc.CallOption) *contractv1.GetFavoritesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetFavoritesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetFavoritesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetFavorites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFavorites'
type InstrumentsAPIMock_GetFavorites_Call struct {
	*mock.Call
}

// GetFavorites is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetFavoritesRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetFavorites(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetFavorites_Call {
	return &InstrumentsAPIMock_GetFavorites_Call{Call: _e.mock.On("GetFavorites",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetFavorites_Call) Run(run func(ctx context.Context, in *contractv1.GetFavoritesRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetFavorites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetFavoritesRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetFavorites_Call) Return(_a0 *contractv1.GetFavoritesResponse, _a1 error) *InstrumentsAPIMock_GetFavorites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetFavorites_Call) RunAndReturn(run func(context.Context, *contractv1.GetFavoritesRequest, ...grpc.CallOption) (*contractv1.GetFavoritesResponse, error)) *InstrumentsAPIMock_GetFavorites_Call {
	_c.Call.Return(run)
	return _c
}

// GetForecastBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetForecastBy(ctx context.Context, in *contractv1.GetForecastRequest, opts ...grpc.CallOption) (*contractv1.GetForecastResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetForecastBy")
	}

	var r0 *contractv1.GetForecastResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetForecastRequest, ...grpc.CallOption) (*contractv1.GetForecastResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetForecastRequest, ...grpc.CallOption) *contractv1.GetForecastResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetForecastResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetForecastRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetForecastBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetForecastBy'
type InstrumentsAPIMock_GetForecastBy_Call struct {
	*mock.Call
}

// GetForecastBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetForecastRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetForecastBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetForecastBy_Call {
	return &InstrumentsAPIMock_GetForecastBy_Call{Call: _e.mock.On("GetForecastBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetForecastBy_Call) Run(run func(ctx context.Context, in *contractv1.GetForecastRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetForecastBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetForecastRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetForecastBy_Call) Return(_a0 *contractv1.GetForecastResponse, _a1 error) *InstrumentsAPIMock_GetForecastBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetForecastBy_Call) RunAndReturn(run func(context.Context, *contractv1.GetForecastRequest, ...grpc.CallOption) (*contractv1.GetForecastResponse, error)) *InstrumentsAPIMock_GetForecastBy_Call {
	_c.Call.Return(run)
	return _c
}

// GetFuturesMargin provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetFuturesMargin(ctx context.Context, in *contractv1.GetFuturesMarginRequest, opts ...grpc.CallOption) (*contractv1.GetFuturesMarginResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetFuturesMargin")
	}

	var r0 *contractv1.GetFuturesMarginResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetFuturesMarginRequest, ...grpc.CallOption) (*contractv1.GetFuturesMarginResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.GetFuturesMarginRequest, ...grpc.CallOption) *contractv1.GetFuturesMarginResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.GetFuturesMarginResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.GetFuturesMarginRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetFuturesMargin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetFuturesMargin'
type InstrumentsAPIMock_GetFuturesMargin_Call struct {
	*mock.Call
}

// GetFuturesMargin is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.GetFuturesMarginRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetFuturesMargin(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetFuturesMargin_Call {
	return &InstrumentsAPIMock_GetFuturesMargin_Call{Call: _e.mock.On("GetFuturesMargin",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetFuturesMargin_Call) Run(run func(ctx context.Context, in *contractv1.GetFuturesMarginRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetFuturesMargin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.GetFuturesMarginRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetFuturesMargin_Call) Return(_a0 *contractv1.GetFuturesMarginResponse, _a1 error) *InstrumentsAPIMock_GetFuturesMargin_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetFuturesMargin_Call) RunAndReturn(run func(context.Context, *contractv1.GetFuturesMarginRequest, ...grpc.CallOption) (*contractv1.GetFuturesMarginResponse, error)) *InstrumentsAPIMock_GetFuturesMargin_Call {
	_c.Call.Return(run)
	return _c
}

// GetInstrumentBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) GetInstrumentBy(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption) (*contractv1.InstrumentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetInstrumentBy")
	}

	var r0 *contractv1.InstrumentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.InstrumentResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) *contractv1.InstrumentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.InstrumentResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_GetInstrumentBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetInstrumentBy'
type InstrumentsAPIMock_GetInstrumentBy_Call struct {
	*mock.Call
}

// GetInstrumentBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) GetInstrumentBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_GetInstrumentBy_Call {
	return &InstrumentsAPIMock_GetInstrumentBy_Call{Call: _e.mock.On("GetInstrumentBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_GetInstrumentBy_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_GetInstrumentBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_GetInstrumentBy_Call) Return(_a0 *contractv1.InstrumentResponse, _a1 error) *InstrumentsAPIMock_GetInstrumentBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_GetInstrumentBy_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.InstrumentResponse, error)) *InstrumentsAPIMock_GetInstrumentBy_Call {
	_c.Call.Return(run)
	return _c
}

// Indicatives provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) Indicatives(ctx context.Context, in *contractv1.IndicativesRequest, opts ...grpc.CallOption) (*contractv1.IndicativesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Indicatives")
	}

	var r0 *contractv1.IndicativesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.IndicativesRequest, ...grpc.CallOption) (*contractv1.IndicativesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.IndicativesRequest, ...grpc.CallOption) *contractv1.IndicativesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.IndicativesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.IndicativesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_Indicatives_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Indicatives'
type InstrumentsAPIMock_Indicatives_Call struct {
	*mock.Call
}

// Indicatives is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.IndicativesRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) Indicatives(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_Indicatives_Call {
	return &InstrumentsAPIMock_Indicatives_Call{Call: _e.mock.On("Indicatives",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_Indicatives_Call) Run(run func(ctx context.Context, in *contractv1.IndicativesRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_Indicatives_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.IndicativesRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_Indicatives_Call) Return(_a0 *contractv1.IndicativesResponse, _a1 error) *InstrumentsAPIMock_Indicatives_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_Indicatives_Call) RunAndReturn(run func(context.Context, *contractv1.IndicativesRequest, ...grpc.CallOption) (*contractv1.IndicativesResponse, error)) *InstrumentsAPIMock_Indicatives_Call {
	_c.Call.Return(run)
	return _c
}

// OptionBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) OptionBy(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption) (*contractv1.OptionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OptionBy")
	}

	var r0 *contractv1.OptionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.OptionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) *contractv1.OptionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.OptionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_OptionBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OptionBy'
type InstrumentsAPIMock_OptionBy_Call struct {
	*mock.Call
}

// OptionBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) OptionBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_OptionBy_Call {
	return &InstrumentsAPIMock_OptionBy_Call{Call: _e.mock.On("OptionBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_OptionBy_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_OptionBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_OptionBy_Call) Return(_a0 *contractv1.OptionResponse, _a1 error) *InstrumentsAPIMock_OptionBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_OptionBy_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.OptionResponse, error)) *InstrumentsAPIMock_OptionBy_Call {
	_c.Call.Return(run)
	return _c
}

// Options provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) Options(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption) (*contractv1.OptionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 *contractv1.OptionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.OptionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) *contractv1.OptionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.OptionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_Options_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Options'
type InstrumentsAPIMock_Options_Call struct {
	*mock.Call
}

// Options is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) Options(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_Options_Call {
	return &InstrumentsAPIMock_Options_Call{Call: _e.mock.On("Options",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_Options_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_Options_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_Options_Call) Return(_a0 *contractv1.OptionsResponse, _a1 error) *InstrumentsAPIMock_Options_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_Options_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.OptionsResponse, error)) *InstrumentsAPIMock_Options_Call {
	_c.Call.Return(run)
	return _c
}

// OptionsBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) OptionsBy(ctx context.Context, in *contractv1.FilterOptionsRequest, opts ...grpc.CallOption) (*contractv1.OptionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OptionsBy")
	}

	var r0 *contractv1.OptionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.FilterOptionsRequest, ...grpc.CallOption) (*contractv1.OptionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.FilterOptionsRequest, ...grpc.CallOption) *contractv1.OptionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.OptionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.FilterOptionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_OptionsBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OptionsBy'
type InstrumentsAPIMock_OptionsBy_Call struct {
	*mock.Call
}

// OptionsBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.FilterOptionsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) OptionsBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_OptionsBy_Call {
	return &InstrumentsAPIMock_OptionsBy_Call{Call: _e.mock.On("OptionsBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_OptionsBy_Call) Run(run func(ctx context.Context, in *contractv1.FilterOptionsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_OptionsBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.FilterOptionsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_OptionsBy_Call) Return(_a0 *contractv1.OptionsResponse, _a1 error) *InstrumentsAPIMock_OptionsBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_OptionsBy_Call) RunAndReturn(run func(context.Context, *contractv1.FilterOptionsRequest, ...grpc.CallOption) (*contractv1.OptionsResponse, error)) *InstrumentsAPIMock_OptionsBy_Call {
	_c.Call.Return(run)
	return _c
}

// ShareBy provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) ShareBy(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption) (*contractv1.ShareResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShareBy")
	}

	var r0 *contractv1.ShareResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.ShareResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) *contractv1.ShareResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.ShareResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_ShareBy_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShareBy'
type InstrumentsAPIMock_ShareBy_Call struct {
	*mock.Call
}

// ShareBy is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) ShareBy(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_ShareBy_Call {
	return &InstrumentsAPIMock_ShareBy_Call{Call: _e.mock.On("ShareBy",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_ShareBy_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_ShareBy_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_ShareBy_Call) Return(_a0 *contractv1.ShareResponse, _a1 error) *InstrumentsAPIMock_ShareBy_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_ShareBy_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentRequest, ...grpc.CallOption) (*contractv1.ShareResponse, error)) *InstrumentsAPIMock_ShareBy_Call {
	_c.Call.Return(run)
	return _c
}

// Shares provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) Shares(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption) (*contractv1.SharesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Shares")
	}

	var r0 *contractv1.SharesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.SharesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) *contractv1.SharesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.SharesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_Shares_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shares'
type InstrumentsAPIMock_Shares_Call struct {
	*mock.Call
}

// Shares is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.InstrumentsRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) Shares(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_Shares_Call {
	return &InstrumentsAPIMock_Shares_Call{Call: _e.mock.On("Shares",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_Shares_Call) Run(run func(ctx context.Context, in *contractv1.InstrumentsRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_Shares_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.InstrumentsRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_Shares_Call) Return(_a0 *contractv1.SharesResponse, _a1 error) *InstrumentsAPIMock_Shares_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_Shares_Call) RunAndReturn(run func(context.Context, *contractv1.InstrumentsRequest, ...grpc.CallOption) (*contractv1.SharesResponse, error)) *InstrumentsAPIMock_Shares_Call {
	_c.Call.Return(run)
	return _c
}

// TradingSchedules provides a mock function with given fields: ctx, in, opts
func (_m *InstrumentsAPIMock) TradingSchedules(ctx context.Context, in *contractv1.TradingSchedulesRequest, opts ...grpc.CallOption) (*contractv1.TradingSchedulesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TradingSchedules")
	}

	var r0 *contractv1.TradingSchedulesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.TradingSchedulesRequest, ...grpc.CallOption) (*contractv1.TradingSchedulesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *contractv1.TradingSchedulesRequest, ...grpc.CallOption) *contractv1.TradingSchedulesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*contractv1.TradingSchedulesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *contractv1.TradingSchedulesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InstrumentsAPIMock_TradingSchedules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TradingSchedules'
type InstrumentsAPIMock_TradingSchedules_Call struct {
	*mock.Call
}

// TradingSchedules is a helper method to define mock.On call
//   - ctx context.Context
//   - in *contractv1.TradingSchedulesRequest
//   - opts ...grpc.CallOption
func (_e *InstrumentsAPIMock_Expecter) TradingSchedules(ctx interface{}, in interface{}, opts ...interface{}) *InstrumentsAPIMock_TradingSchedules_Call {
	return &InstrumentsAPIMock_TradingSchedules_Call{Call: _e.mock.On("TradingSchedules",
		append([]interface{}{ctx, in}, opts...)...)}
}

func (_c *InstrumentsAPIMock_TradingSchedules_Call) Run(run func(ctx context.Context, in *contractv1.TradingSchedulesRequest, opts ...grpc.CallOption)) *InstrumentsAPIMock_TradingSchedules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]grpc.CallOption, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(grpc.CallOption)
			}
		}
		run(args[0].(context.Context), args[1].(*contractv1.TradingSchedulesRequest), variadicArgs...)
	})
	return _c
}

func (_c *InstrumentsAPIMock_TradingSchedules_Call) Return(_a0 *contractv1.TradingSchedulesResponse, _a1 error) *InstrumentsAPIMock_TradingSchedules_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *InstrumentsAPIMock_TradingSchedules_Call) RunAndReturn(run func(context.Context, *contractv1.TradingSchedulesRequest, ...grpc.CallOption) (*contractv1.TradingSchedulesResponse, error)) *InstrumentsAPIMock_TradingSchedules_Call {
	_c.Call.Return(run)
	return _c
}

// NewInstrumentsAPIMock creates a new instance of InstrumentsAPIMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewInstrumentsAPIMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *InstrumentsAPIMock {
	mock := &InstrumentsAPIMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
